<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mybatis | hide on bush</title><meta name="keywords" content="框架,mybatis"><meta name="author" content="sry king"><meta name="copyright" content="sry king"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.概念&#x2F;使用方法向的问题1.1 什么是Mybatis?（1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 （3）">
<meta property="og:type" content="article">
<meta property="og:title" content="mybatis">
<meta property="og:url" content="https://hu16839007.github.io.git/2021/06/11/mybatis/index.html">
<meta property="og:site_name" content="hide on bush">
<meta property="og:description" content="1.概念&#x2F;使用方法向的问题1.1 什么是Mybatis?（1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 （3）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hu16839007.github.io.git/img/mybatis.jpg">
<meta property="article:published_time" content="2021-06-10T20:43:49.418Z">
<meta property="article:modified_time" content="2021-06-10T23:57:48.769Z">
<meta property="article:author" content="sry king">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hu16839007.github.io.git/img/mybatis.jpg"><link rel="shortcut icon" href="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1611688293,2175392062&fm=26&gp=0.jpg"><link rel="canonical" href="https://hu16839007.github.io.git/2021/06/11/mybatis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-11 07:57:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3862012102,3146387484&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/mybatis.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">hide on bush</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mybatis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-10T20:43:49.418Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-10T23:57:48.769Z" title="更新于 2021-06-11 07:57:48">2021-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/%E6%A1%86%E6%9E%B6/">框架</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/%E6%A1%86%E6%9E%B6/mybatis/">mybatis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-概念-使用方法向的问题"><a href="#1-概念-使用方法向的问题" class="headerlink" title="1.概念/使用方法向的问题"></a><strong>1.概念/使用方法向的问题</strong></h2><h3 id="1-1-什么是Mybatis"><a href="#1-1-什么是Mybatis" class="headerlink" title="1.1 什么是Mybatis?"></a><strong>1.1 什么是Mybatis?</strong></h3><p>（1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。</p>
<h3 id="1-2-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2 为什么说<strong>Mybatis是半ORM框架?与Hibernate有哪些不同?</strong></h3><p>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。Hibernate是个完整的ORM框架，而MyBatis只完成了关系-&gt;对象，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>（1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>（2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询（hql好难用哦）。</p>
<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3-Mybaits的优点"><a href="#1-3-Mybaits的优点" class="headerlink" title="1.3 Mybaits的优点?"></a><strong>1.3 Mybaits的优点?</strong></h3><p>（1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>（4）能够与Spring很好的集成；</p>
<p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-MyBatis框架的缺点"><a href="#1-4-MyBatis框架的缺点" class="headerlink" title="1.4 MyBatis框架的缺点?"></a><strong>1.4 MyBatis框架的缺点?</strong></h3><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5-和-的区别"><a href="#1-5-和-的区别" class="headerlink" title="1.5 #{}和${}的区别?"></a><strong>1.5 #{}和${}的区别?</strong></h3><p>（1）${}是properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>（2）#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，举例：</span><br><span class="line">order by $&#123;param&#125;，则解析成的sql为：</span><br><span class="line">order by    id</span><br><span class="line"> </span><br><span class="line">#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，举例：</span><br><span class="line">select * from table where name &#x3D; #&#123;param&#125;，则解析成的sql为：</span><br><span class="line">select * from table where name &#x3D;   &quot;id&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 怎么解决<strong>实体类中的属性名和表中的字段名不一样的问题?</strong></h3><p>（1）通过在查询的sql语句中定义字段名的别名，使字段名的别名和实体类的属性名一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultetype&#x3D;&quot;com.en.entity.user&quot;&gt;</span><br><span class="line">       select user_id as id, user_no as no from test where user_id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>（2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type&#x3D;”me.gacl.domain.order” id&#x3D;”orderresultmap”&gt;</span><br><span class="line">     &lt;!–用id标签来映射主键字段–&gt;</span><br><span class="line">     &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;user_id&quot;&gt;</span><br><span class="line">     &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;</span><br><span class="line">     &lt;result property&#x3D;&quot;no&quot; column&#x3D;&quot;user_no&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;reslutMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-如何在mapper中传递多个参数"><a href="#1-7-如何在mapper中传递多个参数" class="headerlink" title="1.7 如何在mapper中传递多个参数?"></a><strong>1.7 如何在mapper中传递多个参数?</strong></h3><p>（1）使用 @param 注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);</span><br></pre></td></tr></table></figure>

<p>（2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap();</span><br><span class="line">map.put(&quot;start&quot;, start);</span><br><span class="line">map.put(&quot;end&quot;, end);</span><br><span class="line">sqlSession.selectList(&quot;student.selectUser&quot;, map);</span><br></pre></td></tr></table></figure>

<h3 id="1-8-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8 MyBatis的接口绑定有哪些实现方式？"></a><strong>1.8 MyBatis的接口绑定有哪些实现方式？</strong></h3><p>接口绑定有两种实现方式：</p>
<p>（1）一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)</span><br><span class="line">@Results(id &#x3D; &quot;distTypeMap&quot;,value &#x3D;&#123;@Result(id &#x3D;true,property&#x3D;&quot;id&quot;,column&#x3D;&quot;ID&quot;)</span><br><span class="line">            ,@Result(property&#x3D;&quot;code&quot;,column&#x3D;&quot;CODE&quot;)</span><br><span class="line">            ,@Result(property&#x3D;&quot;name&quot;,column&#x3D;&quot;NAME&quot;)</span><br><span class="line">            ,@Result(property &#x3D; &quot;dictDtos&quot; ,column &#x3D; &quot;ID&quot;,many &#x3D; @Many(select&#x3D;&quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,fetchType &#x3D; FetchType.EAGER))</span><br><span class="line">    &#125;)</span><br><span class="line">List&lt;SysDictTypeDto&gt; getAllDist();</span><br></pre></td></tr></table></figure>

<p>（2）另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;queryFileDisposeInfo&quot; parameterType&#x3D;&quot;FileDisposeVo&quot; resultMap&#x3D;&quot;illegalcollection-map&quot;&gt;</span><br><span class="line">   SELECT </span><br><span class="line">        BATCH_NUMBER,</span><br><span class="line">        FINISH_DATE,</span><br><span class="line">        FILE_NAME,</span><br><span class="line">        FILE_SIZE,</span><br><span class="line">        DATA_SIZE,</span><br><span class="line">        FILE_TYPE,</span><br><span class="line">        ORG_CODE</span><br><span class="line">   FROM </span><br><span class="line">        T_FILE_DISPOSE</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>（1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>（2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>（3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>（4）Mapper.xml文件中的namespace即是mapper接口的类路径;</p>
<h2 id="2-源码向的问题"><a href="#2-源码向的问题" class="headerlink" title="2.源码向的问题"></a><strong>2.源码向的问题</strong></h2><h3 id="2-1-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1 解释下MyBatis面向Mapper编程工作原理？"></a>2.1 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的动态代理，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了接口全限名+方法名的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id &#x3D; applyCurrentNamespace(id, false);</span><br><span class="line"></span><br><span class="line">public String applyCurrentNamespace(String base, boolean isReference) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F;返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)</span><br><span class="line">   return currentNamespace + &quot;.&quot; + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200920171405540.png"></p>
<h3 id="2-3-Mybatis动态sql执行原理"><a href="#2-3-Mybatis动态sql执行原理" class="headerlink" title="2.3 Mybatis动态sql执行原理?"></a><strong>2.3 Mybatis动态sql执行原理?</strong></h3><p>（1）初始化阶段：通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>（2）代理阶段：先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>（3）数据读写阶段：通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4-Mybatis的一级、二级缓存实现原理"><a href="#2-4-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4 Mybatis的一级、二级缓存实现原理?"></a><strong>2.4 Mybatis的一级、二级缓存实现原理?</strong></h3><p>（1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092018550771.png"></p>
<p>（2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)级别。Mybatis默认不打开二级缓存，可以在config文件中xml<settings><setting name="cacheEnabled" value="true"/></settings>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920190114946.png"></p>
<p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-Mybatis是如何进行分页的？"><a href="#2-5-Mybatis是如何进行分页的？" class="headerlink" title="2.5 Mybatis是如何进行分页的？"></a><strong>2.5 Mybatis是如何进行分页的？</strong></h3><p>（1）SQL分页(物理分页)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryStudentsBySql&quot; parameterType&#x3D;&quot;map&quot; resultMap&#x3D;&quot;studentmapper&quot;&gt; </span><br><span class="line">           select * from student limit #&#123;start&#125; , #&#123;end&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>（2）使用RowBounds实现分页(逻辑分页)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service:</span><br><span class="line">publicList queryRolesByPage(String roleName,intstart,int limit) &#123;</span><br><span class="line">     returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dao:</span><br><span class="line">     public List queryUsersByPage(String userName, RowBounds rowBounds);</span><br></pre></td></tr></table></figure>

<p>（3）使用分页插件PageHelper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userMapper.queryByPage(userParam);</span><br><span class="line">        Json json &#x3D; new Json();</span><br><span class="line">        return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a><strong>2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png"></p>
<p><strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p><strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p><strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p><strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<h3 id="2-7-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7 Mybatis中如何指定使用哪一种Executor执行器？"></a><strong>2.7 Mybatis中如何指定使用哪一种Executor执行器？</strong></h3><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920183713811.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20200920183657317.png"></h3><h3 id="2-8-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a><strong>2.8 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092018294130.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200920183022252.png"></p>
<p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9-Mybatis中用到了哪些设计模式？"><a href="#2-9-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9 Mybatis中用到了哪些设计模式？"></a><strong>2.9 Mybatis中用到了哪些设计模式？</strong></h3><p>日志模块：代理模式、适配器模式</p>
<p>数据源模块：代理模式、工厂模式</p>
<p>缓存模块：装饰器模式</p>
<p>初始化阶段：建造者模式</p>
<p>代理阶段：策略模式</p>
<p>数据读写阶段：模板模式</p>
<p>插件化开发：责任链模式</p>
<h2 id="2-MyBatis源码结构"><a href="#2-MyBatis源码结构" class="headerlink" title="2.MyBatis源码结构"></a><strong>2.MyBatis源码结构</strong></h2><h3 id="2-1-源码包功能模块图"><a href="#2-1-源码包功能模块图" class="headerlink" title="2.1 源码包功能模块图"></a>2.1 源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png"></p>
<h3 id="2-2-各包详细功能解析"><a href="#2-2-各包详细功能解析" class="headerlink" title="2.2 各包详细功能解析"></a>2.2 各包详细功能解析</h3><p><strong>org.apache.ibatis.logging：</strong>包含所有mapper 接口中用到的注解</p>
<p><strong>org.apache.ibatis.binding：</strong>生成mapper 接口的动态代理并进行管理</p>
<p><strong>org.apache.ibatis.builder：</strong></p>
<ol>
<li> 包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</li>
<li> BaseBuilder 构建器基类</li>
<li> XMLConfigBuilder 解析configuration.xml配置文件</li>
<li> XMLMapperBuilder 解析Mapper.xml配置文件</li>
<li> XMLStatementBuilder 解析selectupdatedelete 标签</li>
<li> MapperAnnotationBuilder 注解式Mapper</li>
</ol>
<p><strong>org.apache.ibatis.cache：</strong></p>
<ol>
<li> 缓存功能实现、包含各种缓存装饰器</li>
<li> TransactionalCache 二级缓存功能实现</li>
</ol>
<p><strong>org.apache.ibatis.cursor：</strong>实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p><strong>org.apache.ibatis.datasource：</strong>数据源 包括jndi数据源、连接池功能</p>
<p><strong>org.apache.ibatis.executor：</strong></p>
<ol>
<li> 包含SQL语句执行器，核心功能包</li>
<li> 功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</li>
</ol>
<p><strong>org.apache.ibatis.exceptions：</strong>框架异常，常见异常：TooManyResultsException</p>
<p><strong>org.apache.ibatis.io：</strong>资源文件读取</p>
<p><strong>org.apache.ibatis.jdbc：</strong></p>
<ol>
<li> JDBC一些操作</li>
<li> SqlRunner SQL执行</li>
<li> ScriptRunner 脚本执行，可以执行建库语句</li>
</ol>
<p><strong>org.apache.ibatis.logging：</strong></p>
<ol>
<li> 日志功能，实现多种日志框架的对接</li>
<li> org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</li>
</ol>
<p><strong>org.apache.ibatis.mapping：</strong>配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p><strong>org.apache.ibatis.parsing：</strong></p>
<ol>
<li> 解析工具包</li>
<li> GenericTokenParser：解析#{} ${} 这种占位符</li>
<li> XPathParser：XPath形式解析XML</li>
<li> PropertyParser: properties解析器</li>
</ol>
<p><strong>org.apache.ibatis.scripting：</strong>动态SQL语言实现，配置文件中<if> <where> <set> <foreach> <choose> 功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p><strong>org.apache.ibatis.session：</strong></p>
<ol>
<li> 主要实现SqlSession功能，非常核心包</li>
<li> 官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</li>
</ol>
<p><strong>org.apache.ibatis.transaction：</strong>事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p><strong>org.apache.ibatis.type：</strong>类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="啃下MyBatis源码-MyBatis核心流程三大阶段之初始化阶段"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之初始化阶段" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之初始化阶段"></a><strong>啃下MyBatis源码 - MyBatis核心流程三大阶段之初始化阶段</strong></h2><p><strong>1.加载配置文件</strong></p>
<p><strong>2.解析配置文件、将配置文件中的信息装载到Configuration中</strong></p>
<p><strong>3.根据Configuration创建SqlSessionFactory并返回</strong></p>
<p><strong>————————————————————————————————————————–</strong></p>
<p>前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li> 加载配置文件</li>
<li> 解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li> 根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="1-加载配置文件"><a href="#1-加载配置文件" class="headerlink" title="1.加载配置文件"></a><strong>1.加载配置文件</strong></h3><p>下面我们来看一段经典查询操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String resouce &#x3D; &quot;config&#x2F;mybatis&#x2F;mybatis-config.xml&quot;;</span><br><span class="line">InputStream is &#x3D; Resources.getResourceAsStream(resouce);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">user &#x3D; session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);</span><br></pre></td></tr></table></figure>

<p>以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="2-解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#2-解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="2.解析配置文件、将配置文件中的信息装载到Configuration中"></a><strong>2.解析配置文件、将配置文件中的信息装载到Configuration中</strong></h3><p>让我们来看一下梦开始的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(is);</span><br></pre></td></tr></table></figure>

<p>跟进build()方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;创建XMLConfigBuilder对象解析XML配置</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      &#x2F;&#x2F;将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进parse()方法，我们可以看到parser.evalNode(“/configuration”)，evalNode为xml结点解析器，可以解析指定参数结点的信息，再看这个”/configuration”有点眼熟丫，这不就是mybatis.xml的根节点嘛：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">    ...</span><br><span class="line">    parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">    return configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p><strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p><strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p><strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200915222654319.png"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915221915851.png"></p>
<p>Configuration类的源码实在太多，童鞋们先对这个类有个大致印象，了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p><strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br><strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br><strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br><strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915223612191.png"></p>
<p>在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLMapperBuilder mapperParser &#x3D; new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">mapperParser.parse();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      String namespace &#x3D; context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">      ...</span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">      cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line">      parameterMapElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;parameterMap&quot;));</span><br><span class="line">      resultMapElements(context.evalNodes(&quot;&#x2F;mapper&#x2F;resultMap&quot;));</span><br><span class="line">      sqlElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;sql&quot;));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>一一对应官网提供的节点信息进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915224121930.png"></p>
<p>下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">      final XMLStatementBuilder statementParser &#x3D; new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      try &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="3-根据Configuration创建SqlSessionFactory并返回"><a href="#3-根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="3.根据Configuration创建SqlSessionFactory并返回"></a><strong>3.根据Configuration创建SqlSessionFactory并返回</strong></h3><p>第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionFactoryBuilder &#123;</span><br><span class="line">   ...</span><br><span class="line">   public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">      return new DefaultSqlSessionFactory(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此工厂内封装了Configuration对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;</span><br><span class="line">  private final Configuration configuration;</span><br><span class="line">  public DefaultSqlSessionFactory(Configuration configuration) &#123;</span><br><span class="line">    this.configuration &#x3D; configuration;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化阶段图解：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915225840294.png"></p>
<p>至此，MyBatis初始化阶段完成。</p>
<h2 id="啃下MyBatis源码-MyBatis核心流程三大阶段之代理阶段（binding模块分析）"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之代理阶段（binding模块分析）" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之代理阶段（binding模块分析）"></a><strong>啃下MyBatis源码 - MyBatis核心流程三大阶段之代理阶段（binding模块分析）</strong></h2><p><strong>1.MyBatis是如何做到面向Mapper接口编程？</strong></p>
<p><strong>2.代理阶段流程梳理</strong></p>
<p><strong>————————————————————————————————————————–</strong></p>
<h3 id="1-MyBatis是如何做到面向Mapper接口编程？"><a href="#1-MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="1.MyBatis是如何做到面向Mapper接口编程？"></a><strong>1.MyBatis是如何做到面向Mapper接口编程？</strong></h3><p>只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">User uer &#x3D; userMapper.selectByPrimarKey(1);</span><br></pre></td></tr></table></figure>

<p>MyBatis动态代理后执行的为下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">User uer &#x3D; sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);</span><br></pre></td></tr></table></figure>

<p>我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p><strong>1、找到Session中对应的方法执行</strong></p>
<p><strong>2、找到命名空间和方法名</strong></p>
<p><strong>3、传递参数</strong></p>
<p>这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200916211402947.png"></p>
<p><strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MapperRegistry &#123;</span><br><span class="line">   private final Configuration config;</span><br><span class="line">   &#x2F;&#x2F;mapper接口和对应的代理对象工厂之间的关系</span><br><span class="line">   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;key为mapper接口中的某个方法的method对象，value为对应的MapperMethod</span><br><span class="line">  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；<img src="https://img-blog.csdnimg.cn/20200916214700706.png"></p>
<p>接着跟进cachedInvoker(method).invoke(proxy, method, args, sqlSession)方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200916213826490.png"></p>
<p>我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214037965.png"></p>
<p>我们可以看到在PlainMethodInvoker类中封装了一个MapperMethod对象，然后在invoke方法中的execute方法中最终通过增删改查的类型来调用增强的方法，当然调用前先用参数解析器过滤一下参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214239389.png"></p>
<p>那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214959863.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215029787.png"><br>通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916215442588.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215556263.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215523383.png"></p>
<h3 id="2-代理阶段流程梳理"><a href="#2-代理阶段流程梳理" class="headerlink" title="2.代理阶段流程梳理"></a><strong>2.代理阶段流程梳理</strong></h3><p>1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="啃下MyBatis源码-MyBatis核心流程三大阶段之数据读写阶段"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之数据读写阶段" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之数据读写阶段"></a>啃下MyBatis源码 - MyBatis核心流程三大阶段之数据读写阶段</h3><p><strong>1.MyBatis是怎样的封装jdbc操作的</strong></p>
<p><strong>2.sqlSession查询流程图和Executor内部调用流程图</strong></p>
<p><strong>————————————————————————————————————————–</strong></p>
<h3 id="1-MyBatis是怎样的封装jdbc操作的"><a href="#1-MyBatis是怎样的封装jdbc操作的" class="headerlink" title="1.MyBatis是怎样的封装jdbc操作的"></a><strong>1.MyBatis是怎样的封装jdbc操作的</strong></h3><p>我们先来回忆一下jdbc代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.加载驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     </span><br><span class="line">&#x2F;&#x2F;2.获取连接conn</span><br><span class="line">Connection con&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;, &quot;root&quot;, &quot;123&quot;);</span><br><span class="line">&#x2F;&#x2F;3.创建查询接口</span><br><span class="line">Statement sta&#x3D; con.createStatement();</span><br><span class="line">&#x2F;&#x2F;4.执行SQL，返回结果集</span><br><span class="line">ResultSet rs&#x3D; sta.executeQuery(&quot;SELECT * FROM &#96;user&#96;&quot;);</span><br><span class="line">&#x2F;&#x2F;5.对结果集数据进行操作</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setUserName(String.valueOf(rs.getObject(1)));</span><br></pre></td></tr></table></figure>

<p>其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203050838.png"></p>
<p>可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203424287.png"></p>
<p><strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p><strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p><strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p><strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205236272.png"></p>
<p>可以看到只有BaseExecutor和CachingExecutor两个类重写了query方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<cache>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205454850.png"></p>
<p>好的我们继续跟进BaseExecutor的query()方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210415293.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200917210606702.png"></p>
<p>可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210831277.png"></p>
<p>我们跟进默认实现SimpleExecutor的doQuery方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211035123.png"></p>
<p>这段代码有两点值得我们注意，一个是prepareStatement(handler, ms.getStatementLog());这个方法，我们跟进去会发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211124589.png"></p>
<p><strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919104808424.png"></p>
<p><strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p><strong>CallableStatementHandler：</strong>调用存储过程</p>
<p><strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p><strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p><strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211725203.png"></p>
<p>接上文调用SimpleStatementHandler的query方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211854628.png"></p>
<p><strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919110111271.png"></p>
<p>处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li><p> 创建multipleResults集合，保存最终返回的结果。</p>
</li>
<li><p> 取出第一个结果集</p>
</li>
<li><p> 获取对应的resultMap</p>
</li>
<li><p> 根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</p>
</li>
<li><p> resultset.close()关闭结果集，将multipleResults集合返回</p>
</li>
</ol>
<h3 id="2-sqlSession查询流程图和Executor内部调用流程图"><a href="#2-sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="2.sqlSession查询流程图和Executor内部调用流程图"></a><strong>2.sqlSession查询流程图和Executor内部调用流程图</strong></h3><p><strong>sqlSession查询流程图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020091911381497.png"></p>
<p><strong>Executor内部调用流程图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020091911204922.png"></p>
<p>至此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sry king</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hu16839007.github.io.git/2021/06/11/mybatis/">https://hu16839007.github.io.git/2021/06/11/mybatis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hu16839007.github.io.git" target="_blank">hide on bush</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/mybatis/">mybatis</a></div><div class="post_share"><div class="social-share" data-image="/img/mybatis.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/11/spring/"><img class="prev-cover" src="/img/Spring.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/11/hibernate/"><img class="next-cover" src="/img/Hibernate.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hibernate</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/11/springmvc/" title="SpringMvc"><img class="cover" src="/img/SpringMvc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-11</div><div class="title">SpringMvc</div></div></a></div><div><a href="/2021/06/11/hibernate/" title="Hibernate"><img class="cover" src="/img/Hibernate.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-11</div><div class="title">Hibernate</div></div></a></div><div><a href="/2021/06/11/springBoot/" title="SpringBoot"><img class="cover" src="/img/SpringBoot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-11</div><div class="title">SpringBoot</div></div></a></div><div><a href="/2021/06/11/springCloud/" title="SpringCloud"><img class="cover" src="/img/SpringCloud.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-11</div><div class="title">SpringCloud</div></div></a></div><div><a href="/2021/06/11/spring/" title="Spring"><img class="cover" src="/img/Spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-11</div><div class="title">Spring</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3862012102,3146387484&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">sry king</div><div class="author-info__description">Follow your heart, but be quiet for a while first. Learn to trust your heart.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hu16839007/hu16839007.github.io"><i class="fab fa-github"></i><span>Github 项目</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hu16839007" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:441129080@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog 评论系统已更新,欢迎留言评论</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">1.概念&#x2F;使用方法向的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFMybatis"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 什么是Mybatis?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Mybatis%E6%98%AF%E5%8D%8AORM%E6%A1%86%E6%9E%B6-%E4%B8%8EHibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Mybaits%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Mybaits的优点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-MyBatis%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 MyBatis框架的缺点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 #{}和${}的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 怎么解决实体类中的属性名和表中的字段名不一样的问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%A6%82%E4%BD%95%E5%9C%A8mapper%E4%B8%AD%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 如何在mapper中传递多个参数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-MyBatis%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 MyBatis的接口绑定有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E4%BD%BF%E7%94%A8MyBatis-Mapper%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 使用MyBatis Mapper接口开发时有哪些要求？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">2.源码向的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%A3%E9%87%8A%E4%B8%8BMyBatis%E9%9D%A2%E5%90%91Mapper%E7%BC%96%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 解释下MyBatis面向Mapper编程工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88MyBatis-Mapper%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E6%94%AF%E6%8C%81%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 为什么MyBatis Mapper接口中的方法不支持重载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Mybatis%E5%8A%A8%E6%80%81sql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Mybatis动态sql执行原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Mybatis的一级、二级缓存实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Mybatis是如何进行分页的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Mybatis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9BExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Mybatis%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8DExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 Mybatis中如何指定使用哪一种Executor执行器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-Mybatis%E7%9A%84Xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8CMybatis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">2.8 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-Mybatis%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">2.9 Mybatis中用到了哪些设计模式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MyBatis%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">2.MyBatis源码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%BA%90%E7%A0%81%E5%8C%85%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 源码包功能模块图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%90%84%E5%8C%85%E8%AF%A6%E7%BB%86%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 各包详细功能解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%83%E4%B8%8BMyBatis%E6%BA%90%E7%A0%81-MyBatis%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%98%B6%E6%AE%B5%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">4.</span> <span class="toc-text">啃下MyBatis源码 - MyBatis核心流程三大阶段之初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">1.加载配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E5%B0%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A3%85%E8%BD%BD%E5%88%B0Configuration%E4%B8%AD"><span class="toc-number">4.2.</span> <span class="toc-text">2.解析配置文件、将配置文件中的信息装载到Configuration中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%B9%E6%8D%AEConfiguration%E5%88%9B%E5%BB%BASqlSessionFactory%E5%B9%B6%E8%BF%94%E5%9B%9E"><span class="toc-number">4.3.</span> <span class="toc-text">3.根据Configuration创建SqlSessionFactory并返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%83%E4%B8%8BMyBatis%E6%BA%90%E7%A0%81-MyBatis%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%98%B6%E6%AE%B5%E4%B9%8B%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88binding%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">啃下MyBatis源码 - MyBatis核心流程三大阶段之代理阶段（binding模块分析）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MyBatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%9D%A2%E5%90%91Mapper%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1.MyBatis是如何做到面向Mapper接口编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">2.代理阶段流程梳理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%83%E4%B8%8BMyBatis%E6%BA%90%E7%A0%81-MyBatis%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%98%B6%E6%AE%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E9%98%B6%E6%AE%B5"><span class="toc-number">5.3.</span> <span class="toc-text">啃下MyBatis源码 - MyBatis核心流程三大阶段之数据读写阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MyBatis%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%B0%81%E8%A3%85jdbc%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">5.4.</span> <span class="toc-text">1.MyBatis是怎样的封装jdbc操作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-sqlSession%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8CExecutor%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">5.5.</span> <span class="toc-text">2.sqlSession查询流程图和Executor内部调用流程图</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/MySQL%E5%9F%BA%E7%A1%80/" title="Mysql基础"><img src="/img/Mysql%E5%9F%BA%E7%A1%80.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql基础"/></a><div class="content"><a class="title" href="/2021/06/11/MySQL%E5%9F%BA%E7%A1%80/" title="Mysql基础">Mysql基础</a><time datetime="2021-06-10T20:43:49.432Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/Linux/" title="Linux"><img src="/img/Linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2021/06/11/Linux/" title="Linux">Linux</a><time datetime="2021-06-10T20:43:49.431Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/java%E9%9B%86%E5%90%88/" title="java集合"><img src="/img/java%E9%9B%86%E5%90%88.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java集合"/></a><div class="content"><a class="title" href="/2021/06/11/java%E9%9B%86%E5%90%88/" title="java集合">java集合</a><time datetime="2021-06-10T20:43:49.430Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/java%E5%9F%BA%E7%A1%80/" title="java基础面试题"><img src="/img/java%E5%9F%BA%E7%A1%80.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础面试题"/></a><div class="content"><a class="title" href="/2021/06/11/java%E5%9F%BA%E7%A1%80/" title="java基础面试题">java基础面试题</a><time datetime="2021-06-10T20:43:49.429Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/javaWeb/" title="javaWeb"><img src="/img/javaweb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaWeb"/></a><div class="content"><a class="title" href="/2021/06/11/javaWeb/" title="javaWeb">javaWeb</a><time datetime="2021-06-10T20:43:49.427Z" title="发表于 2021-06-11 04:43:49">2021-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/mybatis.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By sry king</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://solomid.top/">Hi, welcome to my blog!</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '9084qsPkM6kcsqP6rOwh13sv-gzGzoHsz',
      appKey: 'L61Kc0kakxBNQLfPvNq4RfH2',
      placeholder: '記得留下你的昵称和邮箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://9084qsPk.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '9084qsPkM6kcsqP6rOwh13sv-gzGzoHsz',
        "X-LC-Key": 'L61Kc0kakxBNQLfPvNq4RfH2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="19723756" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/nipsilon.model.json"},"display":{"position":"right","width":240,"height":430},"mobile":{"show":true},"log":false});</script></body></html>