<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql基础</title>
      <link href="2021/06/11/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/11/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h3><p><strong>数据保存在内存</strong></p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p><p><strong>数据保存在文件</strong></p><p><strong>优点：</strong> 数据永久保存</p><p><strong>缺点：</strong></p><p>1）速度比内存操作慢，频繁的IO操作。</p><p>2）查询数据不方便</p><p><strong>数据保存在数据库</strong></p><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><p><code>第一范式</code>：每个列都不可以再拆分。</p><p><code>第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p><code>第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li><p><code>user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p></li><li><p><code>db权限表</code>：记录各个帐号在各个数据库上的操作权限。</p></li><li><p><code>table_priv权限表</code>：记录数据表级的操作权限。</p></li><li><p><code>columns_priv权限表</code>：记录数据列级的操作权限。</p></li><li><p><code>host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p></li></ul><h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。</p><ul><li><p>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</p></li><li><p>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</p></li><li><p>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</p></li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td></td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td></td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td></td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td></td><td>double</td><td>双精度浮点数</td></tr><tr><td></td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td></td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td></td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td></td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td></td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td><strong>文本、二进制类型</strong></td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td></td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td></td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td></td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td></td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td></td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table><ul><li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。  </p><p><code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。  </p><p><code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p></li><li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。  </p><p>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB  </p><p>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。  </p><p>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p><strong>使用策略：</strong>  </p><p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。  </p><p>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p></li><li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。 ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p></li><li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。看到这里，这道真题是不是就比较容易回答了。</p></li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>常用的存储引擎有以下：</p><ul><li><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p></li><li><p><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p></li><li><p><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p></li></ul><p><strong>MyISAM与InnoDB区别</strong></p><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td></td></tr><tr><td>INSERT、UPDATE、DELETE</td><td></td><td>InnoDB更优</td></tr><tr><td>select count(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam 是堆表</td><td>B+树索引，Innodb 是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul><li><p>插入缓冲（insert buffer)</p></li><li><p>二次写(double write)</p></li><li><p>自适应哈希索引(ahi)</p></li><li><p>预读(read ahead)</p></li></ul><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20210129232413960.png"></p><ol><li><p> <strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p> <strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p></li><li><p> <strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p> <strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ol><h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p></li><li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p></li><li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p></li><li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p></li></ul><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容):</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p><h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p>行级锁，表级锁和页级锁对比</p><p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h3 id="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h3><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p><strong>相关知识点：</strong></p><ol><li><p> innodb对于行的查询使用next-key lock</p></li><li><p> Next-locking keying为了解决Phantom Problem幻读问题</p></li><li><p> 当查询的索引含有唯一属性时，将next-key lock降级为record key</p></li><li><p> Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</p></li><li><p> 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</p></li></ol><h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p><p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p><h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h3><p>视图的特点如下:</p><ul><li><p>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</p></li><li><p>视图是由基本表(实表)产生的表(虚表)。</p></li><li><p>视图的建立和删除不影响基本表。</p></li><li><p>对视图内容的更新(添加，删除和修改)直接影响基本表。</p></li><li><p>当视图来自多个基本表时，不允许添加和删除数据。</p></li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p><p>下面是视图的常见使用场景：</p><ul><li><p>重用SQL语句；</p></li><li><p>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</p></li><li><p>使用表的组成部分而不是整个表；</p></li><li><p>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</p></li><li><p>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p></li></ul><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol><li> 查询简单化。视图能简化用户的操作</li><li> 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li> 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol><li><p> 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p> 这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h3><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p><h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h3><p>在MySQL数据库中有如下六种触发器：</p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul><li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p></li><li><p>候选键：是最小超键，即没有冗余元素的超键。</p></li><li><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p></li><li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p></li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p></li><li><p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p></li><li><p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p></li><li><p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p></li><li><p>CHECK: 用于控制字段的值范围。</p></li></ul><h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul><li>   交叉连接（CROSS JOIN）</li><li>   内连接（INNER JOIN）</li><li>   外连接（LEFT JOIN/RIGHT JOIN）</li><li>   联合查询（UNION与UNION ALL）</li><li>   全连接（FULL JOIN）</li><li>   交叉连接（CROSS JOIN）</li></ul><p>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，</p><p>很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p><p>内连接分为三类</p><ul><li><p>等值连接：ON A.id=B.id</p></li><li><p>不等值连接：ON A.id &gt; B.id</p></li><li><p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</p></li></ul><p>外连接（LEFT JOIN/RIGHT JOIN）</p><ul><li><p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</p></li><li><p>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p></li></ul><p>联合查询（UNION与UNION ALL）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A UNION SELECT * FROM B UNION ...</span><br></pre></td></tr></table></figure><ul><li><p>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</p></li><li><p>如果使用UNION ALL，不会合并重复的记录行</p></li><li><p>效率 UNION ALL高于 UNION </p></li></ul><p>全连接（FULL JOIN）</p><ul><li><p>   MySQL不支持全连接</p></li><li><p>   可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.id&#x3D;B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id&#x3D;B.id</span><br></pre></td></tr></table></figure><p>表连接面试题</p><p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p><p>R表</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td></tr></tbody></table><p>S表</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td></tr></tbody></table><ol><li> 交叉连接(笛卡尔积):</li></ol><p>select r.<code>*</code>,s.<code>*</code> from r,s</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c1</td><td>d1</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c2</td><td>d2</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c2</td><td>d2</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c4</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c4</td><td>d3</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c4</td><td>d3</td></tr></tbody></table><ol start="2"><li><p>内连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r inner join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr></tbody></table><ol start="3"><li><p>左连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r left join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr></tbody></table><ol start="4"><li><p>右连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r right join s on r.c=s.c</p></li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>C</td><td>D</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><ol start="5"><li><p>全表连接的结果（MySql不支持，Oracle支持）：</p><p> select r.<code>*</code>,s.<code>*</code> from r full join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h3><ol><li><p> 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</p></li><li><p> 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</p></li></ol><h3 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a>子查询的三种情况</h3><p>1.子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);   </span><br></pre></td></tr></table></figure><p>2.子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);    </span><br></pre></td></tr></table></figure><p>3.子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1) 查询出2011年以后入职的员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d,  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-1-1&#x27;</span>) e <span class="keyword">where</span> e.dept_id <span class="operator">=</span>  d.id;    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表连接：</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span> <span class="keyword">from</span>  dept d <span class="keyword">inner</span> <span class="keyword">join</span> employee e <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id <span class="keyword">where</span> e.join_date <span class="operator">&gt;</span>  <span class="string">&#x27;2011-1-1&#x27;</span>  </span><br></pre></td></tr></table></figure><h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h3><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p>1.如果查询的两个表大小相当，那么用in和exists差别不大。</p><p>2.如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p><p>3.not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p><h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p><ul><li><p>char表示定长字符串，长度是固定的；</p></li><li><p>如果插入数据的长度小于char的固定长度时，则用空格填充；</p></li><li><p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p></li><li><p>对于char来说，最多能存放的字符个数为255，和编码无关</p></li></ul><p><strong>varchar的特点</strong></p><ul><li><p>varchar表示可变长字符串，长度是可变的；</p></li><li><p>插入的数据是多长，就按照多长来存储；</p></li><li><p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p></li><li><p>对于varchar来说，最多能存放的字符个数为65532</p></li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h3><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p><h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h3><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p><h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h3><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p><h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul><li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p><p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br>char(10) 10位固定字符串，不足补空格 最多10个字符<br>varchar(10) 10位可变字符串，不足补空格 最多10个字符</p></li><li><p>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p></li><li><p>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p></li></ul><h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h3><ul><li><p>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</p></li><li><p>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</p></li></ul><h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的全部或者一部分数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度最快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h3><ul><li><p>如果使用UNION ALL，不会合并重复的记录行</p></li><li><p>效率 UNION ALL 高于 UNION</p></li></ul><h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h3><ol><li><p> 应用服务器与数据库服务器建立一个连接</p></li><li><p> 数据库进程拿到请求sql</p></li><li><p> 解析并生成执行计划，执行</p></li><li><p> 读取数据到内存并进行逻辑处理</p></li><li><p> 通过步骤一的连接，发送结果到客户端</p></li><li><p> 关掉连接，释放资源</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210129233417834.png"></p><h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p><p><code>数据库层面</code>,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. </p><p>这条语句需要load1000000数据然后基本上全部丢弃，只取10条当然比较慢. </p><p>当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.</p><p>这样虽然也load了一百万的数据，但是由于索引覆盖，要查询的所有字段都在索引中，所以速度会很快. </p><p>同时如果ID连续的好，我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>，效率也是不错的，优化的可能性有许多种，但是核心思想都一样，就是减少load的数据.</p><p><code>从需求的角度</code>减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</p><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【推荐】利用延迟关联或者子查询优化超多分页场景。 </span><br><span class="line"></span><br><span class="line">说明：MySQL并不是跳过<span class="keyword">offset</span>行，而是取<span class="keyword">offset</span><span class="operator">+</span>N行，然后返回放弃前<span class="keyword">offset</span>行，返回N行，那当<span class="keyword">offset</span>特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行<span class="keyword">SQL</span>改写。 </span><br><span class="line"></span><br><span class="line">正例：先快速定位需要获取的id段，然后再关联： </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> a, (<span class="keyword">select</span> id <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 LIMIT <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure><h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。</p><p>如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 </span><br></pre></td></tr></table></figure><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last. </span><br></pre></td></tr></table></figure><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行 </span><br></pre></td></tr></table></figure><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p><h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p><p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><p>并且null对索引不友好</p><h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h3 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h3><ul><li><p>访问数据太多导致查询性能下降</p></li><li><p>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</p></li><li><p>确认MySQL服务器是否在分析大量不必要的数据行</p></li><li><p>避免犯如下SQL语句错误</p></li><li><p>查询不需要的数据。解决办法：使用limit解决</p></li><li><p>多表关联返回全部列。解决办法：指定列名</p></li><li><p>总是返回全部列。解决办法：避免使用SELECT *</p></li><li><p>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</p></li><li><p>是否在扫描额外的记录。解决办法：</p></li><li><p>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</p></li><li><p>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</p></li><li><p>改变数据库和表的结构，修改数据表范式</p></li><li><p>重写SQL语句，让优化器可以以更优的方式执行查询。</p></li></ul><h3 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h3><ul><li><p>一个复杂查询还是多个简单查询</p></li><li><p>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</p></li><li><p>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</p></li><li><p>切分查询</p></li><li><p>将一个大的查询分为多个小的相同的查询</p></li><li><p>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</p></li><li><p>分解关联查询，让缓存的效率更高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>在应用层做关联更容易对数据库进行拆分。</p></li><li><p>查询效率会有大幅提升。</p></li><li><p>较少冗余记录的查询。</p></li></ul><h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h3><ul><li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>MyISAM中，没有任何where条件的count(*)非常快。</li><li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>可以使用explain查询近似值，用近似值替代count(*)</li><li>增加汇总表</li><li>使用缓存</li></ul><h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul><li>用关联查询替代</li><li>优化GROUP BY和DISTINCT</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h3><ul><li>UNION ALL的效率高于UNION</li></ul><h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h3><p>解题方法</p><p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p><p>SQL语句优化的一些方法？</p><ul><li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span></span><br></pre></td></tr></table></figure><ul><li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li><li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br></pre></td></tr></table></figure><ul><li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span><span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span>’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> ‘abc<span class="operator">%</span>’</span><br></pre></td></tr></table></figure><ul><li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p><strong>将字段很多的表分解成多个表</strong></p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p><strong>增加中间表</strong></p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p><strong>增加冗余字段</strong></p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意：</strong></p><p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p><h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>1）修复前将mysql服务停止。</li><li>2）打开命令行方式，然后进入到mysql的/bin目录。</li><li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li></ul><p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 </p><p>OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）  </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 基础 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="2021/06/11/Linux/"/>
      <url>2021/06/11/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-概述"><a href="#Linux-概述" class="headerlink" title="Linux 概述"></a>Linux 概述</h2><h3 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h3><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h3 id="Unix和Linux有什么区别？"><a href="#Unix和Linux有什么区别？" class="headerlink" title="Unix和Linux有什么区别？"></a>Unix和Linux有什么区别？</h3><p>Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区别。</p><ol><li><p>开源性<br> Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</p></li><li><p>跨平台性<br> Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。</p></li><li><p>可视化界面<br> Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。</p></li><li><p>硬件环境<br> Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。</p></li><li><p>用户群体<br> Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。<br> 相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用！</p></li></ol><h3 id="什么是-Linux-内核？"><a href="#什么是-Linux-内核？" class="headerlink" title="什么是 Linux 内核？"></a>什么是 Linux 内核？</h3><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p><ol><li> 系统内存管理</li><li> 应用程序管理</li><li> 硬件设备管理</li><li> 文件系统管理</li></ol><h3 id="Linux的基本组件是什么？"><a href="#Linux的基本组件是什么？" class="headerlink" title="Linux的基本组件是什么？"></a>Linux的基本组件是什么？</h3><p>就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</p><h3 id="Linux-的体系结构"><a href="#Linux-的体系结构" class="headerlink" title="Linux 的体系结构"></a>Linux 的体系结构</h3><p>从大的方面讲，Linux 体系结构可以分为两块：</p><p><img src="https://img-blog.csdnimg.cn/20200229173922281.png"></p><ul><li><p>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</p></li><li><p>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</p></li></ul><p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p><ul><li>1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</li><li>2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li></ul><p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成用户空间到内核空间的转移：</p><p>1）系统调用；</p><p>2）硬件中断。</p><h3 id="BASH和DOS之间的基本区别是什么？"><a href="#BASH和DOS之间的基本区别是什么？" class="headerlink" title="BASH和DOS之间的基本区别是什么？"></a>BASH和DOS之间的基本区别是什么？</h3><p>BASH和DOS控制台之间的主要区别在于3个方面：</p><ul><li><p>BASH命令区分大小写，而DOS命令则不区分;</p></li><li><p>在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符</p></li><li><p>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例。</p></li></ul><h3 id="Linux-开机启动过程？"><a href="#Linux-开机启动过程？" class="headerlink" title="Linux 开机启动过程？"></a>Linux 开机启动过程？</h3><blockquote><p>了解即可。</p></blockquote><ul><li><p>1、主机加电自检，加载 BIOS 硬件信息。</p></li><li><p>2、读取 MBR 的引导文件(GRUB、LILO)。</p></li><li><p>3、引导 Linux 内核。</p></li><li><p>4、运行第一个进程 init (进程号永远为 1 )。</p></li><li><p>5、进入相应的运行级别。</p></li><li><p>6、运行终端，输入用户名和密码。</p></li></ul><h3 id="Linux系统缺省的运行级别？"><a href="#Linux系统缺省的运行级别？" class="headerlink" title="Linux系统缺省的运行级别？"></a>Linux系统缺省的运行级别？</h3><ul><li>关机。</li><li>单机用户模式。</li><li>字符界面的多用户模式(不支持网络)。</li><li>字符界面的多用户模式。</li><li>未分配使用。</li><li>图形界面的多用户模式。</li><li>重启。</li></ul><h3 id="Linux-使用的进程间通信方式？"><a href="#Linux-使用的进程间通信方式？" class="headerlink" title="Linux 使用的进程间通信方式？"></a>Linux 使用的进程间通信方式？</h3><blockquote><p>了解即可，不需要太深入。</p></blockquote><ul><li>1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li><li>2、信号(signal) 。</li><li>3、消息队列。</li><li>4、共享内存。</li><li>5、信号量。</li><li>6、套接字(socket) 。</li></ul><h3 id="Linux-有哪些系统日志文件？"><a href="#Linux-有哪些系统日志文件？" class="headerlink" title="Linux 有哪些系统日志文件？"></a>Linux 有哪些系统日志文件？</h3><p>比较重要的是 <code>/var/log/messages</code> 日志文件。</p><blockquote><p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p><p>另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。</p></blockquote><h3 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h3><p>交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p><h3 id="什么是root帐户"><a href="#什么是root帐户" class="headerlink" title="什么是root帐户"></a>什么是root帐户</h3><p>root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</p><h3 id="什么是LILO？"><a href="#什么是LILO？" class="headerlink" title="什么是LILO？"></a>什么是LILO？</h3><p>LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。</p><h3 id="什么是BASH？"><a href="#什么是BASH？" class="headerlink" title="什么是BASH？"></a>什么是BASH？</h3><p>BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。</p><h3 id="什么是GUI？"><a href="#什么是GUI？" class="headerlink" title="什么是GUI？"></a>什么是GUI？</h3><p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p><p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</p><h2 id="磁盘、目录、文件"><a href="#磁盘、目录、文件" class="headerlink" title="磁盘、目录、文件"></a>磁盘、目录、文件</h2><h3 id="简单-Linux-文件系统？"><a href="#简单-Linux-文件系统？" class="headerlink" title="简单 Linux 文件系统？"></a>简单 Linux 文件系统？</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在 Linux 系统中有一个重要的概念：一切都是文件。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><p>Linux 支持 5 种文件类型，如下图所示：<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYzIuaW9jb2Rlci5jbi9iNjg2NTQxN2RkMTI0NWU0ZjNjNGJhODc3Y2U5YzVhYQ?x-oss-process=image/format,png" alt="文件类型"></p><h3 id="Linux-的目录结构是怎样的？"><a href="#Linux-的目录结构是怎样的？" class="headerlink" title="Linux 的目录结构是怎样的？"></a>Linux 的目录结构是怎样的？</h3><blockquote><p>这个问题，一般不会问。更多是实际使用时，需要知道。</p></blockquote><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYzIuaW9jb2Rlci5jbi81YzJmNTRmMjhkNGVhYmJlMTM4ZmQ4Y2JiNzYzYTFmMQ?x-oss-process=image/format,png" alt="Linux的目录结构"></p><p><strong>常见目录说明</strong>：</p><ul><li><strong>/bin</strong>： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li><li><strong>/etc</strong>： 存放系统管理和配置文件；</li><li><strong>/home</strong>： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr</strong>： 用于存放系统应用程序；</li><li><strong>/opt</strong>： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc</strong>： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root</strong>： 超级用户（系统管理员）的主目录（特权阶级o）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev</strong>： 用于存放设备文件；</li><li><strong>/mnt</strong>： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot</strong>： 存放用于系统引导时使用的各种文件；</li><li><strong>/lib</strong>： 存放着和系统运行相关的库文件；</li><li><strong>/tmp</strong>： 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var</strong>： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found</strong>： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h3 id="什么是硬链接和软链接？"><a href="#什么是硬链接和软链接？" class="headerlink" title="什么是硬链接和软链接？"></a>什么是硬链接和软链接？</h3><p>1）硬链接</p><p>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</p><ul><li><p>不足：</p><ul><li><p>不可以在不同文件系统的文件间建立链接；</p></li><li><p>只有超级用户才可以为目录创建硬链接。</p></li></ul></li></ul><p>2）软链接</p><p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p><ul><li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li></ul><p><strong>实际场景下，基本是使用软链接</strong>。总结区别如下：</p><ul><li>硬链接不可以跨分区，软件链可以跨分区。</li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="一台-Linux-系统初始化环境后需要做一些什么安全工作？"><a href="#一台-Linux-系统初始化环境后需要做一些什么安全工作？" class="headerlink" title="一台 Linux 系统初始化环境后需要做一些什么安全工作？"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h3><ul><li><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p><blockquote><p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p></blockquote></li><li><p>2、服务器使用密钥登陆，禁止密码登陆。</p></li><li><p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p></li><li><p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p></li><li><p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p><blockquote><p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p></blockquote></li><li><p>6、修改历史命令记录的条数为 10 条。</p></li><li><p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p></li><li><p>8、做好软件层面的防护。</p><ul><li>8.1 设置 nginx_waf 模块防止 SQL 注入。</li><li>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</li></ul></li></ul><h3 id="什么叫-CC-攻击？什么叫-DDOS-攻击？"><a href="#什么叫-CC-攻击？什么叫-DDOS-攻击？" class="headerlink" title="什么叫 CC 攻击？什么叫 DDOS 攻击？"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h3><ul><li><p>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</p></li><li><p>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</p><blockquote><p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p></blockquote></li></ul><p><strong>怎么预防 CC 攻击和 DDOS 攻击？</strong></p><p>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p><blockquote><p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p></blockquote><h3 id="什么是网站数据库注入？"><a href="#什么是网站数据库注入？" class="headerlink" title="什么是网站数据库注入？"></a>什么是网站数据库注入？</h3><ul><li><p>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</p></li><li><p>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</p></li><li><p>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</p></li></ul><p><strong>如何过滤与预防？</strong></p><p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p><h3 id="Shell-脚本是什么？"><a href="#Shell-脚本是什么？" class="headerlink" title="Shell 脚本是什么？"></a>Shell 脚本是什么？</h3><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p><p><strong>什么是默认登录 Shell ？</strong></p><p>在 Linux 操作系统，<code>&quot;/bin/bash&quot;</code> 是默认登录 Shell，是在创建用户时分配的。</p><p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## chsh &lt;用户名&gt; -s &lt;新shell&gt;</span></span><br><span class="line"><span class="comment">## chsh ThinkWon -s /bin/sh</span></span><br></pre></td></tr></table></figure><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>cat 主要有三大功能：</p><p>1.一次显示整个文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure><p>2.从键盘创建一个文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure><p>只能创建新文件，不能编辑已有文件。</p><p>3.将几个文件合并为一个文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure><ul><li>-b 对非空输出行号</li><li>-n 输出所有行号</li></ul><p><strong>实例</strong>：</p><p>（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n log2012.log log2013.log</span><br></pre></td></tr></table></figure><p>（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b log2012.log log2013.log log.log</span><br></pre></td></tr></table></figure><p>（3）使用 here doc 生成新文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;log.txt &lt;&lt;EOF</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Hello</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">World</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">PWD=$(<span class="built_in">pwd</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">EOF</span></span><br><span class="line">ls -l log.txt</span><br><span class="line">cat log.txt</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">PWD=/opt/soft/test</span><br></pre></td></tr></table></figure><p>（4）反向列示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tac log.txt</span><br><span class="line">PWD=/opt/soft/test</span><br><span class="line">World</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p><p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p><p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。</p><p>以文件 log2012.log 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure><p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。</p><p>如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。</p><p>从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c 当发生改变时，报告处理信息</span><br><span class="line">-R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure><p>权限范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u ：目录或者文件的当前的用户</span><br><span class="line">g ：目录或者文件的当前的群组</span><br><span class="line">o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">a ：所有的用户及群组</span><br></pre></td></tr></table></figure><p>权限代号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r ：读权限，用数字4表示</span><br><span class="line">w ：写权限，用数字2表示</span><br><span class="line">x ：执行权限，用数字1表示</span><br><span class="line">- ：删除权限，用数字0表示</span><br><span class="line">s ：特殊权限</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）增加文件 t.log 所有用户可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x t.log</span><br></pre></td></tr></table></figure><p>（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=r t.log -c</span><br></pre></td></tr></table></figure><p>（3）给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c)</span><br></pre></td></tr></table></figure><p>（4）将 test 目录及其子目录所有文件添加可读权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+r,g+r,o+r -R text/ -c</span><br></pre></td></tr></table></figure><h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c 显示更改的部分的信息</span><br><span class="line">-R 处理指定目录及子目录</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）改变拥有者和群组 并显示改变信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -c mail:mail log2012.log</span><br></pre></td></tr></table></figure><p>（2）改变文件群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -c :mail t.log</span><br></pre></td></tr></table></figure><p>（3）改变文件夹及子文件目录属主及属组为 mail</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -cR mail: test/</span><br></pre></td></tr></table></figure><h3 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i 提示</span><br><span class="line">-r 复制目录及目录内所有项目</span><br><span class="line">-a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -ai a.txt test</span><br></pre></td></tr></table></figure><p>（2）为 a.txt 建议一个链接（快捷方式）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -s a.txt link_a.txt</span><br></pre></td></tr></table></figure><h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><p>用于在文件树中查找文件，并作出相应的处理。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find pathname -options [-print -exec -ok ...]</span><br></pre></td></tr></table></figure><p>命令参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pathname: find命令所查找的目录路径。例如用.来表示当前目录，用&#x2F;来表示系统根目录。</span><br><span class="line">-print： find命令将匹配的文件输出到标准输出。</span><br><span class="line">-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#39;command&#39; &#123;  &#125; \;，注意&#123;   &#125;和\；之间的空格。</span><br><span class="line">-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure><p><strong>命令选项</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-name 按照文件名查找文件</span><br><span class="line">-perm 按文件权限查找文件</span><br><span class="line">-user 按文件属主查找文件</span><br><span class="line">-group  按照文件所属的组来查找文件。</span><br><span class="line">-type  查找某一类型的文件，诸如：</span><br><span class="line">   b - 块设备文件</span><br><span class="line">   d - 目录</span><br><span class="line">   c - 字符设备文件</span><br><span class="line">   l - 符号链接文件</span><br><span class="line">   p - 管道文件</span><br><span class="line">   f - 普通文件</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查找 48 小时内修改过的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -atime -2</span><br></pre></td></tr></table></figure><p>（2）在当前目录查找 以 .log 结尾的文件。 <strong>.</strong> 代表当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &#x27;*.log&#x27;</span><br></pre></td></tr></table></figure><p>（3）查找 /opt 目录下 权限为 777 的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /opt -perm 777</span><br></pre></td></tr></table></figure><p>（4）查找大于 1K 的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -size +1000c</span><br></pre></td></tr></table></figure><p>查找等于 1000 字符的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -size 1000c </span><br></pre></td></tr></table></figure><p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。</p><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示 1.log 文件中前 20 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head 1.log -n 20</span><br></pre></td></tr></table></figure><p>（2）显示 1.log 文件前 20 字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c 20 log2014.log</span><br></pre></td></tr></table></figure><p>（3）显示 t.log最后 10 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n -10 t.log</span><br></pre></td></tr></table></figure><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p><strong>常用命令参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-i  忽略搜索时的大小写</span><br><span class="line">-N  显示每行的行号</span><br><span class="line">-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-s  显示连续空行为一行</span><br><span class="line">&#x2F;字符串：向下搜索“字符串”的功能</span><br><span class="line">?字符串：向上搜索“字符串”的功能</span><br><span class="line">n：重复前一个搜索（与 &#x2F; 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 &#x2F; 或 ? 有关）</span><br><span class="line">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">b  向后翻一页</span><br><span class="line">d  向后翻半页</span><br><span class="line">h  显示帮助界面</span><br><span class="line">Q  退出less 命令</span><br><span class="line">u  向前滚动半页</span><br><span class="line">y  向前滚动一行</span><br><span class="line">空格键 滚动一行</span><br><span class="line">回车键 滚动一页</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]：   向上翻动一页</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）ps 查看进程信息并通过 less 分页显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | less -N</span><br></pre></td></tr></table></figure><p>（2）查看多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 1.log 2.log</span><br></pre></td></tr></table></figure><p>可以使用 n 查看下一个，使用 p 查看前一个。</p><h3 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h3><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p><p>链接分类：软件链接及硬链接</p><p>软链接：</p><ul><li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li><li>2.软链接可以 跨文件系统 ，硬链接不可以</li><li>3.软链接可以对一个不存在的文件名进行链接</li><li>4.软链接可以对目录进行链接</li></ul><p>硬链接:</p><ul><li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>2.不允许给目录创建硬链接</li><li>3.硬链接只有在同一个文件系统中才能创建</li></ul><p><strong>需要注意</strong>：</p><ul><li><p>第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</p></li><li><p>第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p></li><li><p>第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</p></li></ul><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-s 软链接（符号链接）</span><br><span class="line">-v 显示详细处理过程</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）给文件创建软链接，并显示操作信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sv source.log link.log</span><br></pre></td></tr></table></figure><p>（2）给文件创建硬链接，并显示操作信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -v source.log link1.log</span><br></pre></td></tr></table></figure><p>（3）给目录创建软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sv /opt/soft/test/test3 /opt/soft/test/test5</span><br></pre></td></tr></table></figure><h3 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h3><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。</p><p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l num（要显示的行数）</span><br><span class="line">-f   将特定的档案系统排除在外，如将proc排除在外</span><br><span class="line">-r   使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate pwd</span><br></pre></td></tr></table></figure><p>（2）搜索 etc 目录下所有以 sh 开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate /etc/sh</span><br></pre></td></tr></table></figure><p>（3）查找 /var 目录下，以 reason 结尾的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -r &#x27;^/var.*reason$&#x27;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</span><br></pre></td></tr></table></figure><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p><p><strong>命令参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+n      从笫 n 行开始显示</span><br><span class="line">-n       定义屏幕大小为n行</span><br><span class="line">+&#x2F;pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c       从顶部清屏，然后显示</span><br><span class="line">-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l        忽略Ctrl+l（换页）字符</span><br><span class="line">-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s       把连续的多个空行显示为一行</span><br><span class="line">-u       把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure><p><strong>常用操作命令</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter    向下 n 行，需要定义。默认为 1 行</span><br><span class="line">Ctrl+F   向下滚动一屏</span><br><span class="line">空格键  向下滚动一屏</span><br><span class="line">Ctrl+B  返回上一屏</span><br><span class="line">&#x3D;       输出当前行的行号</span><br><span class="line">:f     输出文件名和当前行的行号</span><br><span class="line">V      调用vi编辑器</span><br><span class="line">!命令   调用Shell，并执行命令</span><br><span class="line">q       退出more</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示文件中从第3行起的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +3 text.txt</span><br></pre></td></tr></table></figure><p>（2）在所列出文件目录详细信息，借助管道使每次显示 5 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | more -5</span><br></pre></td></tr></table></figure><p>按空格显示下 5 行。</p><h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p><p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p><p><strong>实例</strong>：</p><p>（1）将文件 test.log 重命名为 test1.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test.log test1.txt</span><br></pre></td></tr></table></figure><p>（2）将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv llog1.txt log2.txt log3.txt /test3</span><br></pre></td></tr></table></figure><p>（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -i log1.txt log2.txt</span><br></pre></td></tr></table></figure><p>（4）移动当前文件夹下的所有文件到上一级目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv * ../</span><br></pre></td></tr></table></figure><h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件…</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）删除任何 .log 文件，删除前逐一询问确认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -i *.log</span><br></pre></td></tr></table></figure><p>（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf test</span><br></pre></td></tr></table></figure><p>（3）删除以 -f 开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -- -f*</span><br></pre></td></tr></table></figure><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f 循环读取（常用于查看递增的日志文件）</span><br><span class="line">-n&lt;行数&gt; 显示行数（从后向前）</span><br></pre></td></tr></table></figure><p>（1）循环读取逐渐增加的文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1 &gt; ping.log &amp;</span><br></pre></td></tr></table></figure><p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f ping.log</span><br></pre></td></tr></table></figure><p>（查看日志）</p><h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure><ul><li><strong>参数说明</strong>：</li><li>a 改变档案的读取时间记录。</li><li>m 改变档案的修改时间记录。</li><li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li><li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li><li>r 使用参考档的时间记录，与 –file 的效果一样。</li><li>d 设定时间与日期，可以使用各种不同的格式。</li><li>t 设定档案的时间记录，格式与 date 指令相同。</li><li>–no-create 不会建立新档案。</li><li>–help 列出指令格式。</li><li>–version 列出版本讯息。</li></ul><p><strong>实例</strong></p><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch testfile <span class="comment">#修改文件的时间属性</span></span> </span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l testfile <span class="comment">#查看文件的时间属性</span></span>  </span><br><span class="line"><span class="meta">#</span><span class="bash">原来文件的修改时间为16:09</span>  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  </span><br></pre></td></tr></table></figure><p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch testfile <span class="comment">#修改文件时间属性为当前系统时间</span></span>  </span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l testfile <span class="comment">#查看文件的时间属性</span></span>  </span><br><span class="line"><span class="meta">#</span><span class="bash">修改后文件的时间属性为当前系统时间</span>  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  </span><br></pre></td></tr></table></figure><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch file <span class="comment">#创建一个名为“file”的新的空白文件</span></span> </span><br></pre></td></tr></table></figure><h3 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a>vim 命令</h3><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><ul><li>打开文件并跳到第 10 行：<code>vim +10 filename.txt</code> 。</li><li>打开文件跳到第一个匹配的行：<code>vim +/search-term filename.txt</code> 。</li><li>以只读模式打开文件：<code>vim -R /etc/passwd</code> 。</li></ul><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNy92aW0tdmktd29ya21vZGVsLnBuZw?x-oss-process=image/format,png"></p><h3 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h3><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b   定位可执行文件。</span><br><span class="line">-m   定位帮助文件。</span><br><span class="line">-s   定位源代码文件。</span><br><span class="line">-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查找 locate 程序相关文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis locate</span><br></pre></td></tr></table></figure><p>（2）查找 locate 的源码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -s locate</span><br></pre></td></tr></table></figure><p>（3）查找 lcoate 的帮助文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -m locate</span><br></pre></td></tr></table></figure><h3 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h3><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">which     查看可执行文件的位置。</span><br><span class="line">whereis 查看文件的位置。</span><br><span class="line">locate  配合数据库查看文件位置。</span><br><span class="line">find        实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure><p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查看 ls 命令是否存在，执行哪个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which ls</span><br></pre></td></tr></table></figure><p>（2）查看 which</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which which</span><br></pre></td></tr></table></figure><p>（3）查看 cd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</span><br></pre></td></tr></table></figure><p>查看当前 PATH 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>或使用 env 查看所有环境变量及对应值</p><h2 id="文档编辑命令"><a href="#文档编辑命令" class="headerlink" title="文档编辑命令"></a>文档编辑命令</h2><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p><p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [option] pattern file|dir</span><br></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-A n --after-context显示匹配字符后n行</span><br><span class="line">-B n --before-context显示匹配字符前n行</span><br><span class="line">-C n --context 显示匹配字符前后n行</span><br><span class="line">-c --count 计算符合样式的列数</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-l 只列出文件内容符合指定的样式的文件名称</span><br><span class="line">-f 从文件中读取关键词</span><br><span class="line">-n 显示匹配内容的所在文件中行数</span><br><span class="line">-R 递归查找文件夹</span><br></pre></td></tr></table></figure><p>grep 的规则表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^  #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 </span><br><span class="line">$  #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 </span><br><span class="line">.  #匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。  </span><br><span class="line">*  #匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。</span><br><span class="line">.*   #一起用代表任意字符。  </span><br><span class="line">[]   #匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。 </span><br><span class="line">[^]  #匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  </span><br><span class="line">\(..\)  #标记匹配字符，如&#39;\(love\)&#39;，love被标记为1。   </span><br><span class="line">\&lt;      #锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。</span><br><span class="line">\&gt;      #锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。</span><br><span class="line">x\&#123;m\&#125;  #重复字符x，m次，如：&#39;0\&#123;5\&#125;&#39;匹配包含5个o的行。 </span><br><span class="line">x\&#123;m,\&#125;  #重复字符x,至少m次，如：&#39;o\&#123;5,\&#125;&#39;匹配至少有5个o的行。  </span><br><span class="line">x\&#123;m,n\&#125;  #重复字符x，至少m次，不多于n次，如：&#39;o\&#123;5,10\&#125;&#39;匹配5--10个o的行。  </span><br><span class="line">\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。  </span><br><span class="line">\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  </span><br><span class="line">\b    #单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep。</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查找指定进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep svn</span><br></pre></td></tr></table></figure><p>（2）查找指定进程个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep svn -c</span><br></pre></td></tr></table></figure><p>（3）从文件中读取关键词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt | grep -f key.log</span><br></pre></td></tr></table></figure><p>（4）从文件夹中递归查找以grep开头的行，并只列出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -lR &#x27;^grep&#x27; /tmp</span><br></pre></td></tr></table></figure><p>（5）查找非x开关的行内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;^[^x]&#x27; test.txt</span><br></pre></td></tr></table></figure><p>（6）显示包含 ed 或者 at 字符的内容行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &#x27;ed|at&#x27; test.txt</span><br></pre></td></tr></table></figure><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [option] file..</span><br></pre></td></tr></table></figure><p><strong>命令参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c 统计字节数</span><br><span class="line">-l 统计行数</span><br><span class="line">-m 统计字符数</span><br><span class="line">-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）查找文件的 行数 单词数 字节数 文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc text.txt</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7     8     70     test.txt</span><br></pre></td></tr></table></figure><p>（2）统计输出结果的行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | wc -l</span><br></pre></td></tr></table></figure><h2 id="磁盘管理命令"><a href="#磁盘管理命令" class="headerlink" title="磁盘管理命令"></a>磁盘管理命令</h2><h3 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h3><p>cd(changeDirectory) 命令语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure><p>说明：切换当前目录至 dirName。</p><p><strong>实例</strong>：</p><p>（1）进入要目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><p>（2）进入 “home” 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>（3）进入上一次工作路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p>（4）把上个命令的参数作为cd参数使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a 全部文件系统列表</span><br><span class="line">-h 以方便阅读的方式显示信息</span><br><span class="line">-i 显示inode信息</span><br><span class="line">-k 区块为1024字节</span><br><span class="line">-l 只显示本地磁盘</span><br><span class="line">-T 列出文件系统类型</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示磁盘使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -l</span><br></pre></td></tr></table></figure><p>（2）以易读方式列出所有文件系统及其类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -haT</span><br></pre></td></tr></table></figure><h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [文件]</span><br></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a 显示目录中所有文件大小</span><br><span class="line">-k 以KB为单位显示文件大小</span><br><span class="line">-m 以MB为单位显示文件大小</span><br><span class="line">-g 以GB为单位显示文件大小</span><br><span class="line">-h 以易读方式显示文件大小</span><br><span class="line">-s 仅显示总计</span><br><span class="line">-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）以易读方式显示文件夹内及子文件夹大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h scf/</span><br></pre></td></tr></table></figure><p>（2）以易读方式显示文件夹内所有文件大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah scf/</span><br></pre></td></tr></table></figure><p>（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -hc test/ scf/</span><br></pre></td></tr></table></figure><p>（4）输出当前目录下各个子目录所使用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -hc --max-depth=1 scf/</span><br></pre></td></tr></table></figure><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p><p><strong>常用参数搭配</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="line">ls -A 列出除.及..的其它文件</span><br><span class="line">ls -r 反序排列</span><br><span class="line">ls -t 以文件修改时间排序</span><br><span class="line">ls -S 以文件大小排序</span><br><span class="line">ls -h 以易读大小显示</span><br><span class="line">ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lhrt</span><br></pre></td></tr></table></figure><p>(2) 按大小反序显示文件详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lrS</span><br></pre></td></tr></table></figure><p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure><p>(4) 列出文件绝对路径（不包含隐藏文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sed &quot;s:^:`pwd`/:&quot;</span><br></pre></td></tr></table></figure><p>(5) 列出文件绝对路径（包含隐藏文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find $pwd -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure><h3 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h3><p>mkdir 命令用于创建文件夹。</p><p>可用选项：</p><ul><li><strong>-m</strong>: 对新建目录设置存取权限，也可以用 chmod 命令设置;</li><li><strong>-p</strong>: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</li></ul><p><strong>实例</strong>：</p><p>（1）当前工作目录下创建名为 t的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir t</span><br></pre></td></tr></table></figure><p>（2）在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/test/t1/t</span><br></pre></td></tr></table></figure><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><p>pwd 命令用于查看当前工作目录路径。</p><p><strong>实例</strong>：</p><p>（1）查看当前路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>（2）查看软链接的实际路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P</span><br></pre></td></tr></table></figure><h3 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h3><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p><strong>注意</strong>：不能删除非空目录</p><p><strong>实例</strong>：</p><p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p parent/child/child11</span><br></pre></td></tr></table></figure><h2 id="网络通讯命令"><a href="#网络通讯命令" class="headerlink" title="网络通讯命令"></a>网络通讯命令</h2><h3 id="ifconfig-命令"><a href="#ifconfig-命令" class="headerlink" title="ifconfig 命令"></a>ifconfig 命令</h3><ul><li>ifconfig 用于查看和配置 Linux 系统的网络接口。</li><li>查看所有网络接口及其状态：<code>ifconfig -a</code> 。</li><li>使用 up 和 down 命令启动或停止某个接口：<code>ifconfig eth0 up</code> 和 <code>ifconfig eth0 down</code> 。</li></ul><h3 id="iptables-命令"><a href="#iptables-命令" class="headerlink" title="iptables 命令"></a>iptables 命令</h3><p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：</p><ul><li><p>把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：<code>iptables \-I INPUT \-s 192.168.1.101 \-p tcp \--dport 80 \-j REJECT</code> 。</p></li><li><p>开启 80 端口，因为web对外都是这个端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEP</span><br></pre></td></tr></table></figure></li><li><p>另外，要注意使用 <code>iptables save</code> 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p></li></ul><h3 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h3><p>Linux netstat命令用于显示网络状态。</p><p>利用netstat指令可让你得知整个Linux系统的网络情况。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-a或–all 显示所有连线中的Socket。</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li><li>-c或–continuous 持续列出网络状态。</li><li>-C或–cache 显示路由器配置的快取信息。</li><li>-e或–extend 显示网络其他相关信息。</li><li>-F或–fib 显示FIB。</li><li>-g或–groups 显示多重广播功能群组组员名单。</li><li>-h或–help 在线帮助。</li><li>-i或–interfaces 显示网络界面信息表单。</li><li>-l或–listening 显示监控中的服务器的Socket。</li><li>-M或–masquerade 显示伪装的网络连线。</li><li>-n或–numeric 直接使用IP地址，而不通过域名服务器。</li><li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。</li><li>-o或–timers 显示计时器。</li><li>-p或–programs 显示正在使用Socket的程序识别码和程序名称。</li><li>-r或–route 显示Routing Table。</li><li>-s或–statistice 显示网络工作信息统计表。</li><li>-t或–tcp 显示TCP传输协议的连线状况。</li><li>-u或–udp 显示UDP传输协议的连线状况。</li><li>-v或–verbose 显示指令执行过程。</li><li>-V或–version 显示版本信息。</li><li>-w或–raw 显示RAW传输协议的连线状况。</li><li>-x或–unix 此参数的效果和指定”-A unix”参数相同。</li><li>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</li></ul><p><strong>实例</strong></p><p><strong>如何查看系统都开启了哪些端口？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~ 13:20 #55]# netstat -lnp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd</span><br><span class="line">tcp        0      0 :::22                       :::*                        LISTEN      1035/sshd</span><br><span class="line">udp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient</span><br><span class="line">Active UNIX domain sockets (only servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node PID/Program name    Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon    /var/run/dbus/system_bus_socket</span><br></pre></td></tr></table></figure><p><strong>如何查看网络连接状况？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~ 13:22 #58]# netstat -an</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED</span><br><span class="line">tcp        0      0 :::22                       :::*                        LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:68                  0.0.0.0:*</span><br></pre></td></tr></table></figure><p><strong>如何统计系统当前进程连接数？</strong></p><ul><li>输入命令 <code>netstat -an | grep ESTABLISHED | wc -l</code> 。</li><li>输出结果 <code>177</code> 。一共有 177 连接数。</li></ul><p><strong>用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数？</strong></p><blockquote><p>严格来说，这个题目考验的是对 awk 的使用。</p></blockquote><p>首先，使用 <code>netstat \-an|grep ESTABLISHED</code> 命令。结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcp        0      0 120.27.146.122:80       113.65.18.33:62721      ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:80       27.43.83.115:47148      ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:58838    106.39.162.96:443       ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:52304    203.208.40.121:443      ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:33194    203.208.40.122:443      ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:53758    101.37.183.144:443      ESTABLISHED</span><br><span class="line">tcp        0      0 120.27.146.122:27017    23.105.193.30:50556     ESTABLISHED</span><br></pre></td></tr></table></figure><h3 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h3><p>Linux ping命令用于检测主机。</p><p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>指定接收包的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 2 www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h3><p>Linux telnet命令用于远端登入。</p><p>执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-8 允许使用8位字符资料，包括输入与输出。</li><li>-a 尝试自动登入远端系统。</li><li>-b&lt;主机别名&gt; 使用别名指定远端主机名称。</li><li>-c 不读取用户专属目录里的.telnetrc文件。</li><li>-d 启动排错模式。</li><li>-e&lt;脱离字符&gt; 设置脱离字符。</li><li>-E 滤除脱离字符。</li><li>-f 此参数的效果和指定”-F”参数相同。</li><li>-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li><li>-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li><li>-K 不自动登入远端主机。</li><li>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</li><li>-L 允许输出8位字符资料。</li><li>-n&lt;记录文件&gt; 指定文件记录相关信息。</li><li>-r 使用类似rlogin指令的用户界面。</li><li>-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</li><li>-x 假设主机有支持数据加密的功能，就使用它。</li><li>-X&lt;认证形态&gt; 关闭指定的认证形态。</li></ul><p><strong>实例</strong></p><p>登录远程主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录IP为 192.168.0.5 的远程主机</span></span><br><span class="line">telnet 192.168.0.5 </span><br></pre></td></tr></table></figure><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><h3 id="date-命令"><a href="#date-命令" class="headerlink" title="date 命令"></a>date 命令</h3><p>显示或设定系统的日期与时间。</p><p>命令参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class="line">-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class="line">-u 　显示GMT。</span><br><span class="line">%H 小时(00-23)</span><br><span class="line">%I 小时(00-12)</span><br><span class="line">%M 分钟(以00-59来表示)</span><br><span class="line">%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。</span><br><span class="line">%S 秒(以本地的惯用法来表示)</span><br><span class="line">%a 星期的缩写。</span><br><span class="line">%A 星期的完整名称。</span><br><span class="line">%d 日期(以01-31来表示)。</span><br><span class="line">%D 日期(含年月日)。</span><br><span class="line">%m 月份(以01-12来表示)。</span><br><span class="line">%y 年份(以00-99来表示)。</span><br><span class="line">%Y 年份(以四位数来表示)。</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示下一天</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%Y%m%d --date=&quot;+1 day&quot;  //显示下一天的日期</span><br></pre></td></tr></table></figure><p>（2）-d参数使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三</span><br><span class="line">date -d &#x27;2 weeks&#x27; 2周后的日期</span><br><span class="line">date -d &#x27;next monday&#x27; (下周一的日期)</span><br><span class="line">date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d</span><br><span class="line">date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d</span><br><span class="line">date -d last-month +%Y%m(上个月是几月)</span><br><span class="line">date -d next-month +%Y%m(下个月是几月)</span><br></pre></td></tr></table></figure><h3 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h3><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p><p><strong>命令参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-b 以Byte显示内存使用情况</span><br><span class="line">-k 以kb为单位显示内存使用情况</span><br><span class="line">-m 以mb为单位显示内存使用情况</span><br><span class="line">-g 以gb为单位显示内存使用情况</span><br><span class="line">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">-t 显示内存使用总合</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示内存使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free</span><br><span class="line">free -k</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><p>（2）以总和的形式显示内存的使用信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -t</span><br></pre></td></tr></table></figure><p>（3）周期性查询内存使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -s 10</span><br></pre></td></tr></table></figure><h3 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h3><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line">-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line">-s  指定发送信号</span><br><span class="line">-u  指定用户</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）先使用ps查找进程pro1，然后用kill杀掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef | grep pro1)</span><br></pre></td></tr></table></figure><h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h3><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p><p>linux上进程有5种状态:</p><ol><li><p> 运行(正在运行或在运行队列中等待)</p></li><li><p> 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p></li><li><p> 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p></li><li><p> 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p></li><li><p> 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p></li></ol><p>ps 工具标识进程的5种状态码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D 不可中断 uninterruptible sleep (usually IO)</span><br><span class="line">R 运行 runnable (on run queue)</span><br><span class="line">S 中断 sleeping</span><br><span class="line">T 停止 traced or stopped</span><br><span class="line">Z 僵死 a defunct (”zombie”) process</span><br></pre></td></tr></table></figure><p><strong>命令参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-A 显示所有进程</span><br><span class="line">a 显示所有进程</span><br><span class="line">-a 显示同一终端下所有进程</span><br><span class="line">c 显示进程真实名称</span><br><span class="line">e 显示环境变量</span><br><span class="line">f 显示进程间的关系</span><br><span class="line">r 显示当前终端运行的进程</span><br><span class="line">-aux 显示所有包含其它使用的进程</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）显示当前所有进程环境变量及进程间关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>（2）显示当前所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A</span><br></pre></td></tr></table></figure><p>（3）与grep联用查找某进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep apache</span><br></pre></td></tr></table></figure><p>（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep &#x27;(cron|syslog)&#x27;</span><br></pre></td></tr></table></figure><h3 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a>rpm 命令</h3><p>Linux rpm 命令用于管理套件。</p><p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统自带jdk</span></span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除系统自带jdk</span></span><br><span class="line">rpm -e --nodeps 查看jdk显示的数据</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装jdk</span></span><br><span class="line">rpm -ivh jdk-7u80-linux-x64.rpm</span><br></pre></td></tr></table></figure><h2 id="Linux常见性能分析命令"><a href="#Linux常见性能分析命令" class="headerlink" title="Linux常见性能分析命令"></a>Linux常见性能分析命令</h2><h3 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h3><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c 显示完整的进程命令</span><br><span class="line">-s 保密模式</span><br><span class="line">-p &lt;进程号&gt; 指定进程显示</span><br><span class="line">-n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35</span><br><span class="line">Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st</span><br><span class="line">Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers</span><br><span class="line">Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  </span><br><span class="line">28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  </span><br></pre></td></tr></table></figure><p>前五行是当前系统情况整体的统计信息区。</p><p><strong>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下</strong>：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p><strong>第二行，Tasks — 任务（进程），具体信息说明如下</strong>：</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p><strong>第三行，cpu状态信息，具体属性说明如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5.9%us — 用户空间占用CPU的百分比。</span><br><span class="line">3.4% sy — 内核空间占用CPU的百分比。</span><br><span class="line">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class="line">90.4% id — 空闲CPU百分比</span><br><span class="line">0.0% wa — IO等待占用CPU的百分比</span><br><span class="line">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class="line">0.2% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p>第四行，内存状态，具体信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32949016k total — 物理内存总量（32GB）</span><br><span class="line">14411180k used — 使用中的内存总量（14GB）</span><br><span class="line">18537836k free — 空闲内存总量（18GB）</span><br><span class="line">169884k buffers — 缓存的内存量 （169M）</span><br></pre></td></tr></table></figure><p><strong>第五行，swap交换分区信息，具体信息说明如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32764556k total — 交换区总量（32GB）</span><br><span class="line">0k used — 使用的交换区总量（0K）</span><br><span class="line">32764556k free — 空闲交换区总量（32GB）</span><br><span class="line">3612636k cached — 缓冲的交换区总量（3.6GB）</span><br></pre></td></tr></table></figure><p><strong>第六行，空行。</strong></p><p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PID — 进程id</span><br><span class="line">USER — 进程所有者</span><br><span class="line">PR — 进程优先级</span><br><span class="line">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES</span><br><span class="line">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA</span><br><span class="line">SHR — 共享内存大小，单位kb</span><br><span class="line">S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</span><br><span class="line">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class="line">%MEM — 进程使用的物理内存百分比</span><br><span class="line">TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒</span><br><span class="line">COMMAND — 进程名称（命令名&#x2F;命令行）</span><br></pre></td></tr></table></figure><p><strong>top 交互命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h 显示top交互命令帮助信息</span><br><span class="line">c 切换显示命令名称和完整命令行</span><br><span class="line">m 以内存使用率排序</span><br><span class="line">P 根据CPU使用百分比大小进行排序</span><br><span class="line">T 根据时间&#x2F;累计时间进行排序</span><br><span class="line">W 将当前设置写入~&#x2F;.toprc文件中</span><br><span class="line">o或者O 改变显示项目的顺序</span><br></pre></td></tr></table></figure><h3 id="yum-命令"><a href="#yum-命令" class="headerlink" title="yum 命令"></a>yum 命令</h3><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><ul><li>1.列出所有可更新的软件清单命令：yum check-update</li><li>2.更新所有软件命令：yum update</li><li>3.仅安装指定的软件命令：yum install &lt;package_name&gt;</li><li>4.仅更新指定的软件命令：yum update &lt;package_name&gt;</li><li>5.列出所有可安裝的软件清单命令：yum list</li><li>6.删除软件包命令：yum remove &lt;package_name&gt;</li><li>7.查找软件包 命令：yum search</li><li>8.清除缓存命令:<ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul></li></ul><p><strong>实例</strong></p><p>安装 pam-devel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# yum install pam-devel</span><br></pre></td></tr></table></figure><h2 id="备份压缩命令"><a href="#备份压缩命令" class="headerlink" title="备份压缩命令"></a>备份压缩命令</h2><h3 id="bzip2-命令"><a href="#bzip2-命令" class="headerlink" title="bzip2 命令"></a>bzip2 命令</h3><ul><li><p>创建 <code>*.bz2</code> 压缩文件：<code>bzip2 test.txt</code> 。</p></li><li><p>解压 <code>*.bz2</code> 文件：<code>bzip2 -d test.txt.bz2</code> 。</p></li></ul><h3 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h3><ul><li><p>创建一个 <code>*.gz</code> 的压缩文件：<code>gzip test.txt</code> 。</p></li><li><p>解压 <code>*.gz</code> 文件：<code>gzip -d test.txt.gz</code> 。</p></li><li><p>显示压缩的比率：<code>gzip -l *.gz</code> 。</p></li></ul><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p><p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p><p><strong>常用参数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c 建立新的压缩文件</span><br><span class="line">-f 指定压缩文件</span><br><span class="line">-r 添加文件到已经压缩文件包中</span><br><span class="line">-u 添加改了和现有的文件到压缩包中</span><br><span class="line">-x 从压缩包中抽取文件</span><br><span class="line">-t 显示压缩文件中的内容</span><br><span class="line">-z 支持gzip压缩</span><br><span class="line">-j 支持bzip2压缩</span><br><span class="line">-Z 支持compress解压文件</span><br><span class="line">-v 显示操作过程</span><br></pre></td></tr></table></figure><p>有关 gzip 及 bzip2 压缩:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz</span><br><span class="line">          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz</span><br><span class="line"></span><br><span class="line">bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2</span><br><span class="line">       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><p>（1）将文件全部打包成 tar 包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</span><br></pre></td></tr></table></figure><p>（2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /tmp/etc.tar.gz /etc</span><br></pre></td></tr></table></figure><p>（3）查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf /tmp/etc.tar.gz</span><br></pre></td></tr></table></figure><p>（4）要压缩打包 /home, /etc ，但不要 /home/dmtsai</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc</span><br></pre></td></tr></table></figure><h3 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h3><ul><li><p>解压 <code>*.zip</code> 文件：<code>unzip test.zip</code> 。</p></li><li><p>查看 <code>*.zip</code> 文件的内容：<code>unzip -l jasper.zip</code> 。</p></li></ul><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><strong>作用：</strong> 能够实时显示系统中各个进程的资源占用情况。类似于windows的任务管理器</p><p><strong>命令参数：</strong></p><ul><li><strong>d：指定每两次屏幕信息刷新之间的时间间隔</strong></li><li><strong>p：通过指定监控进程ID来仅仅监控某个进程的状态</strong></li><li><strong>q：使top没有任何演示的进行刷新</strong></li><li><strong>S：指定累计模式</strong></li><li><strong>s：使top命令在安全模式中运行</strong></li><li><strong>i：使top不显示任何闲置或者僵死进程</strong></li><li><strong>c：显示整个命令行而不只是显示命令名</strong></li></ul><p>终端输入top，显示如下</p><p><img src="https://img-blog.csdnimg.cn/20210208173309353.png"></p><ul><li><p><strong>第一行：表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载（最近1，5，15分钟）</strong></p></li><li><p><strong>第二行：显示的所有启动的进程、目前运行的、挂起的(sleeping)和无用(zombie)的进程</strong></p></li><li><p><strong>第三行：显示的是目前CPU的情况，包括系统占用的比例、用户占用的比例、闲置的比例</strong></p></li><li><p><strong>第四行：显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存</strong></p></li><li><p><strong>第五行：显示交换区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。</strong></p></li><li><p><strong>第六行：显示的项目如下：</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210208173328630.png"></p><p>输入top之后，还可以根据需要进行排序，查看对应信息</p><p>shift+M：按照内存使用进行排序</p><p>shift+P：按照cpu时间排序</p><p>shift+T：按照cpou累计使用时间</p><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p><strong>作用：</strong></p><p>虚拟内存的统计。vmstat可以实时监控cpu运行队列和系统关键的性能指标，如磁盘，上下文交换，cpu使用率等</p><p>命令参数：</p><ul><li><strong>-a：显示活跃和非活跃内存</strong></li><li><strong>-f：显示从系统启动至今的fork数量</strong></li><li><strong>-m：只显示slabinfo</strong></li><li><strong>-n：只在开始时显示一次个字段名称</strong></li><li><strong>-s：显示内存相关统计信息及多种系统活动数量</strong></li><li><strong>delay：属性时间间隔。如果不指定，只显示一条结果</strong></li><li><strong>count：刷新次数。如果不指定刷新次数，但制定了刷新时间间隔，这是刷新次数为无穷</strong></li><li><strong>-d：显示磁盘相关统计信息</strong></li><li><strong>-p：显示制定磁盘分区统计信息</strong></li><li><strong>-S：使用指定单位显示。参数有k、K、m、M，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K</strong></li><li><strong>-V：显示vmstat版本信息</strong></li></ul><p>例子：</p><p>输入vmstat可以看到</p><p><img src="https://img-blog.csdnimg.cn/20210208173411890.png"></p><p><strong>procs</strong></p><p>r列表示等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。</p><p>b列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。</p><p><strong>memory</strong></p><p>swpd 切换到内存交换区的内存数量，或者说是现在可用的交换内存（k）。</p><p>如果swpd不为0，或者比较大，比如100m，只要si、so的值长期为0，系统性能还是正常</p><p>free当前的空闲页面列中内存数量（k），空闲内存</p><p>buff作为buffer cache的内存数量，一般对块设备的读写才需要缓冲</p><p>cache做为page cache的内存数量，一般做为内存系统的cache，如果cache较大，说明用到cahce的文件较多，如果此时IO中bi较小，说明文件系统效率较好</p><p><strong>swap</strong></p><p>si有内存进入交换区数量</p><p>so有内存交换区进入内存数量</p><p><strong>IO</strong></p><p>bi从块设备读入数据的总量（读磁盘）（每秒KB）</p><p>bo块设置吸入数据的总量（写磁盘）（每秒KB）</p><p>这里我们设置的bi+bo参考值为1000，如果超过1000，而且wa值较大应该考虑均衡磁盘负载，可以结合iostat输出来分析。如果bi，bo长期不等于0，表示物理内存容量太小</p><p>system</p><p>显示采集间隔内发生的中断数</p><p>in列表示在某一段时间间隔中观测到的每秒设备中断数</p><p>cs列表示每秒产生的上下文交换次数，如当cs比磁盘I/O和网络信息包速率高得多，都应该进一步调查</p><p><strong>cpu</strong></p><p>表示cpu的使用状态</p><p>us 列显示了用户方式下所花费cpu时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序</p><p>sy 列显示了内核进程花费的cpu时间的百分比。这里us+sy的参考值为80%，如果us+sy大于80%说明可能存在cpu不足</p><p>wa 列显示了IO等待所占有的cpu时间的百分比。这里wa的参考值为30%，如果wa超过30%，说明IO等待严重，这可能是磁盘或者磁盘访问控制器的带宽瓶颈造成的（块操作）</p><p>id 列显示了cpu处在空闲状态的时间百分比，如果id经常小于40，表示中央处理器的符合很重</p><p>最好使用vmstat t [n]命令，例如vmstat 5 5，表示在T(5)秒时间内进行N(5)次采样。如果只使用vmstat，无法反映真正的系统情况。</p><p><img src="https://img-blog.csdnimg.cn/20210208173546831.png"></p><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p><strong>iostat主要用于监控系统设备的IO负载情况</strong></p><ul><li><strong>-d：显示设备（磁盘）使用状态</strong></li><li><strong>-k：某些使用block为单位的列强制使用Kb</strong></li><li><strong>-x：显示更多的统计信息</strong></li><li><strong>-c：获取cpu部分状态值</strong></li></ul><p>例：每个1s刷新一次，共刷新10次</p><p><img src="https://img-blog.csdnimg.cn/20210208173619594.png"></p><p><strong>tps：该设备每秒的传输次数。一次传输即一次I/O</strong></p><p><strong>kB_read/s：每秒从设备读取的数量</strong></p><p><strong>kB_wrtn/s：每秒向设备写入的数量</strong></p><p><strong>kB_read：读取的总数据量（Kb）</strong></p><p><strong>kB_wrtn：写入的总数据量（Kb）</strong></p><p><strong>常见用法</strong></p><p><img src="https://img-blog.csdnimg.cn/20210208173641934.png"></p><p><strong>实例分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20210208173658623.png"></p><p>上面看到磁盘每秒传输次数平均约为400；每秒读取约5M，写入约1M</p><p><img src="https://img-blog.csdnimg.cn/20210208173730943.png"></p><p><strong>sar</strong></p><p>命令行输入sar：</p><p><img src="https://img-blog.csdnimg.cn/20210208173752651.png"></p><ul><li><p><strong>%user：用户模式下消耗的cpu时间的比例</strong></p></li><li><p><strong>%nice：通过nice该表了进程调度优先级的进程，在用户模式下消耗的cpu时间的比例</strong></p></li><li><p><strong>%system：系统模式下消耗的cpu时间的比例</strong></p></li><li><p><strong>%iowait：cpu等待磁盘I/O而导致空闲状态消耗时间的比例。如果过高，表示存在I/O瓶颈</strong></p></li><li><p><strong>%steal：利用Xen等操作系统虚拟化技术时，等待其他虚拟cpu计算占用的时间比例</strong></p></li><li><p><strong>%idle：cpu没有等待磁盘I/O等待空闲状态消耗的时间比例</strong></p></li></ul><p>如果%idle的值高但系统响应慢时，有可能是cpu等待分配内存，此时应加大内存容量</p><p>如果%idle的值持续低于10，则系统的cpu处理能力相对较低，表明系统中最需要解决的资源是CPU</p><h2 id="查看日志用到的常用命令举例"><a href="#查看日志用到的常用命令举例" class="headerlink" title="查看日志用到的常用命令举例"></a>查看日志用到的常用命令举例</h2><p>杀僵尸进程 部分程序员，肯定喜欢下面命令：</p><ul><li><p> ps -ef | grep java (先查java进程ID)</p></li><li><p> kill -9  PID(生产环境谨慎使用)</p></li></ul><p><strong>kill、killall、pkill命令的区别</strong></p><ul><li><p>kill：通过pid来杀死进程</p></li><li><p>killall （killall [参数] [进程名]）：Linux系统中的killall命令用于杀死指定名字的进程（kill processes by name）。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。  </p></li><li><p>pkill：pkill 和killall 应用方法差不多，也是直接杀死运行中的程式；如果你想杀掉单个进程，请用kill 来杀掉。例子： pkill -9 firefox</p></li></ul><p><strong>1.查看日志常用命令</strong></p><p> <strong>tail:</strong>  </p><p> -n  是显示行号；相当于nl命令；例子如下：</p><ul><li><p>tail -100f test.log      实时监控100行日志</p></li><li><p>tail  -n  10  test.log   查询日志尾部最后10行的日志;</p></li><li><p>tail -n +10 test.log    查询10行之后的所有日志;</p></li></ul><p><strong>head:</strong>  </p><p>跟tail是相反的，tail是看后多少行日志；例子如下：</p><ul><li><p>head -n 10  test.log   查询日志文件中的头10行日志;</p></li><li><p>head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;</p></li></ul><p><strong>cat：</strong> </p><p>tac是倒序查看，是cat单词反写；例子如下：</p><p>cat -n test.log |grep “debug”   查询关键字的日志</p><p><strong>2. 应用场景一：按行号查看—过滤出关键字附近的日志</strong></p><p>1）cat -n test.log |grep “debug”  得到关键日志的行号</p><p>2）通常查找出错误日志 cat error.log | grep ‘nick’ , 这时候我们还有个需求就是输出当前这个日志的前后几行：</p><ul><li><p>cat error.log | grep -B 5 ‘nick’ 显示nick及前5行</p></li><li><p>cat error.log | grep -A 5 ‘nick’ 显示nick及后5行</p></li><li><p>cat error.log | grep -C 5 ‘nick’ 显示file文件里匹配nick字串那行以及上下5行</p></li><li><p>cat error.log | grep -n -B10 -A10 5 ‘nick’ 显示file文件里匹配nick字串前后10行</p></li></ul><p><strong>3. 应用场景二：选取日志中特定范围进行分析</strong></p><p>1）cat -n test.log |tail -n +1000|head -n 20   从第1000行开始，显示20行</p><ul><li><p>tail -n +1000表示查询1000行之后的日志</p></li><li><p>head -n 20 则表示在前面的查询结果里再查前20条记录</p></li></ul><p>2）cat catalina.out | head -n 1400| tail -n +1350  显示1350行到1400行 （实现原理都差不多，就是通过语法糖）</p><p>3）按日期截取 ：一般在日志系统中都会记录打印日志的时间，通常我们非常需要查找指定时间端的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;&#x2F;2014-12-17 16:17:20&#x2F;,&#x2F;2014-12-17 16:17:36&#x2F;p&#39;  test.log</span><br></pre></td></tr></table></figure><p>特别说明:该命令中的两个日期值必须是日志文件中包含的值,否则该命令无效.； 先 grep ‘2014-12-17 16:17:20’ test.log 来确定日志中是否有该 时间点</p><p>4）按行数截取</p><p>sed -n ‘10000,20000p’ test.log                </p><p>sed -i ‘/关键词/d’ catalina.out  删除包含关键词的行</p><p><strong>4.应用场景三：日志内容特别多，打印在屏幕上不方便查看</strong></p><p>(1)使用more和less命令</p><p>如： cat -n test.log |grep “debug” |more     这样就分页打印了,通过点击空格键翻页</p><p>(2)使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析</p><p>如：cat -n test.log |grep “debug”  &gt;debug.txt</p><p><strong>5：使用管道进行and or条件处理</strong></p><p>and 使用管道实现，例如：grep -n ‘日志排查’ test.log | grep ‘日志’</p><p>or 用-E，例如：grep -n -E ‘日志排查|hello’ test.log  满足两个关键字的都可以找出来</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2021/06/11/java%E9%9B%86%E5%90%88/"/>
      <url>2021/06/11/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合篇"><a href="#Java集合篇" class="headerlink" title="Java集合篇"></a>Java集合篇</h1><h2 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h2><p>List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p><p>Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。</p><p>Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul><li><p><code>线程是否安全</code>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p></li><li><p><code>效率</code>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p><code>对Null key 和Null value的支持</code>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p></li><li><p><code>初始容量大小和每次扩充容量大小的不同</code> ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</p></li><li><p><code>底层数据结构</code>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li></ul><p>HashMap 中带有初始容量的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-和-HashSet区别？"><a href="#HashMap-和-HashSet区别？" class="headerlink" title="HashMap 和 HashSet区别？"></a>HashMap 和 HashSet区别？</h2><p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone() </code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 put() 向map中添加元素</td><td>调用 add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://img-blog.csdnimg.cn/20210124114013992.png"></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://img-blog.csdnimg.cn/202101241142486.png"></p><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方?"></a>HashMap 的长度为什么是2的幂次方?</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><h3 id="这个算法应该如何设计呢？"><a href="#这个算法应该如何设计呢？" class="headerlink" title="这个算法应该如何设计呢？"></a>这个算法应该如何设计呢？</h3><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><h2 id="HashMap加载因子为什么是-0-75？"><a href="#HashMap加载因子为什么是-0-75？" class="headerlink" title="HashMap加载因子为什么是 0.75？"></a>HashMap加载因子为什么是 0.75？</h2><p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p><p>首先如果加载因子比较大，那么扩容发生的频率就比较低，但是他浪费的空间比较小，不过发生hash冲突的几率就比较大，比如加载因子是1的时候，如果hashmap长度为128，那么可能hashmap的实际存储元素数量在64至128之间的时间段比较多，而这个时间段发生hash冲突就比较大，造成数组中其中一条链表较长，就会影响性能。</p><p>而当加载因子值比较小的时候，扩容的频率就会变高，因此会占用更多的空间，但是元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高，比如设置成0.5，同样128长度的hashmap，当数量达到65的时候就会触发hashmap的扩容，扩容后长度为256，256里面只存储了65个似乎有点浪费了。</p><p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p><p>0.75与泊松分布的关系：当负载因子=0.75，带入泊松分布公式中，计算出来长度为8时，概率=0.00000006，这个0.00000006概率已经很小了，所以链表长度为8时，转换成红黑树</p><h2 id="当有哈希冲突时，HashMap是如何查找并确认元素的？"><a href="#当有哈希冲突时，HashMap是如何查找并确认元素的？" class="headerlink" title="当有哈希冲突时，HashMap是如何查找并确认元素的？"></a>当有哈希冲突时，HashMap是如何查找并确认元素的？</h2><p>通过昨天分析get方法应该已经比较清楚了，如果哈希冲突，还是找到table[index]的第一个Node，然后一个一个去比对链表中的key，key一致则找到，引用put流程图其中一部分如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210124115804339.png"></p><h2 id="JDK-1-8-HashMap-扩容时做了哪些优化？"><a href="#JDK-1-8-HashMap-扩容时做了哪些优化？" class="headerlink" title="JDK 1.8 HashMap 扩容时做了哪些优化？"></a>JDK 1.8 HashMap 扩容时做了哪些优化？</h2><p>在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时，链表结构会转换成红黑树结构，即使在hashcode 完全相同极端情况下，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销，而如果查找链表，时间复杂度会退化到 O(n)。</p><h2 id="HashMap-是线程安全的吗，为什么不是线程安全的？"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的？" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的？"></a>HashMap 是线程安全的吗，为什么不是线程安全的？</h2><p>通过例子来讲解这个不安全的过程，引用上一篇文章的例子，首先一个长度为8的map&lt;Integer,V&gt;，map已经存了key为1、9的两个值，他们都会在map的table[1]上。</p><p>1、首先线程1put一个key=17的值，当程序运行到判断key=9的下一个节点为null准备把key=17的值设置为它的下一个节点时，线程让出资源。</p><p>2、此时执行线程2，对mapput一个key=25的数据，这个数据正常作为key=9的next正常插入。</p><p>3、线程1再次拿到资源继续执行，设置key=9的next为key=17，这样线程2设置的key=25就被覆盖。</p><p>以上的流程示意图如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210124120005804.png"></p><p>关键代码在于HashMap的put代码，详解如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210124120046929.png"></p><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题?"></a>HashMap 多线程操作导致死循环问题?</h2><p>主要原因在于1.8之前并发下的Rehash是头插法，会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，改成了尾插法，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><h3 id="JDK7-头插法源码"><a href="#JDK7-头插法源码" class="headerlink" title="JDK7 头插法源码"></a>JDK7 头插法源码</h3><p><img src="https://img-blog.csdnimg.cn/20210124120145299.png"></p><h3 id="头插法死循环原因"><a href="#头插法死循环原因" class="headerlink" title="头插法死循环原因"></a>头插法死循环原因</h3><p><img src="https://img-blog.csdnimg.cn/20210124120312653.png"></p><h2 id="map和set有什么区别，分别又是怎么实现的？"><a href="#map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="map和set有什么区别，分别又是怎么实现的？"></a>map和set有什么区别，分别又是怎么实现的？</h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p><h3 id="map和set区别在于："><a href="#map和set区别在于：" class="headerlink" title="map和set区别在于："></a>map和set区别在于：</h3><p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p><p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p><p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p><h2 id="map底层为什么用红黑树实现？"><a href="#map底层为什么用红黑树实现？" class="headerlink" title="map底层为什么用红黑树实现？"></a>map底层为什么用红黑树实现？</h2><p>1、红黑树：</p><p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p><p>性质：</p><ol><li><p>每个节点非红即黑</p></li><li><p>根节点是黑的;</p></li><li><p>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p></li><li><p>如果一个节点是红色的，则它的子节点必须是黑色的。</p></li><li><p>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p></li></ol><p>2、平衡二叉树（AVL树）：</p><p>红黑树是在AVL树的基础上提出来的。</p><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p><p>AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p><p>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p><p>3、红黑树较AVL树的优点：</p><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h2 id="请你说明一下TreeMap的底层实现？"><a href="#请你说明一下TreeMap的底层实现？" class="headerlink" title="请你说明一下TreeMap的底层实现？"></a>请你说明一下TreeMap的底层实现？</h2><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现原理"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现原理" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式? 底层具体实现原理?"></a>ConcurrentHashMap线程安全的具体实现方式? 底层具体实现原理?</h2><h3 id="JDK1-7的ConcurrentHashMap："><a href="#JDK1-7的ConcurrentHashMap：" class="headerlink" title="JDK1.7的ConcurrentHashMap："></a>JDK1.7的ConcurrentHashMap：</h3><p><img src="https://img-blog.csdnimg.cn/20210124114658748.png"></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p><p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><p>java static class Segment extends ReentrantLock implements Serializable { }</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><h3 id="JDK1-8的ConcurrentHashMap"><a href="#JDK1-8的ConcurrentHashMap" class="headerlink" title="JDK1.8的ConcurrentHashMap"></a>JDK1.8的ConcurrentHashMap</h3><p><img src="https://img-blog.csdnimg.cn/20210202232133778.png"></p><p><strong>Node：</strong></p><p>作为ConcurrentHashMap中最核心、最重要的内部类，Node担负着重要角色：key-value键值对。所有插入ConCurrentHashMap的中数据都将会包装在Node中。定义如下：</p><p>在Node内部类中，其属性value、next都是带有volatile的。同时其对value的setter方法进行了特殊处理，不允许直接调用其setter方法来修改value的值。最后Node还提供了find方法来赋值map.get()。</p><p><strong>TreeNode：</strong></p><p>在 HashMap 中，其核心的数据结构是链表。而在 ConcurrentHashMap 中，如果链表的数据过长会转换为红黑树来处理。通过将链表的节点包装成 TreeNode 放在 TreeBin 中，然后经由 TreeBin 完成红黑树的转换。</p><p><strong>Tree：</strong></p><p>TreeBin 不负责键值对的包装，用于在链表转换为红黑树时包装 TreeNode 节点，用来构建红黑树。</p><p>转换红黑树的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果table.length&lt;64 就扩大一倍 返回</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//构造了一个TreeBin对象 把所有Node节点包装成TreeNode放进去</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        <span class="comment">//这里只是利用了TreeNode封装 而没有利用TreeNode的next域和parent域</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//在原来index的位置 用TreeBin替换掉原来的Node对象</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap取消了Segment分段锁，采用了 Node数组 + CAS + Synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p><p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别?"></a>ConcurrentHashMap 和 Hashtable 的区别?</h2><ul><li><p><code>底层数据结构</code>： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p><code>实现线程安全的方式（重要）</code>：</p><p>① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></li></ul><h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p><p>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p><p>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h2 id="ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h2><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p><p>性能：ArrayList 在性能方面要优于 Vector。</p><p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h2 id="说一说-ArrayList-的扩容机制吧"><a href="#说一说-ArrayList-的扩容机制吧" class="headerlink" title="说一说 ArrayList 的扩容机制吧?"></a>说一说 ArrayList 的扩容机制吧?</h2><p>ArrayList是List接口的实现类，它是支持根据需要而动态增长的数组。java中标准数组是定长的，在数组被创建之后，它们不能被加长或缩短。这就意味着在创建数组时需要知道数组的所需长度，但有时我们需要动态程序中获取数组长度。ArrayList就是为此而生的。</p><p>因此，了解它的扩容机制对使用它尤为重要。</p><p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据意思可以看出ensureCapacityInternal()是用来扩容的，形参为最小扩容量，进入此方法后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法calculateCapacity(elementData, minCapacity)获取:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureExplicitCapacity方法可以判断是否需要扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最小需要空间比elementData的内存空间要大，则需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重点来了，ArrayList扩容的关键方法grow():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">   <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组，</span></span><br><span class="line">    <span class="comment">// 不够就将数组长度设置为需要的长度</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">       newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">       newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">   <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class="line">   <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">   elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//其实调用了System.arraycopy()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此方法中我们可以清晰的看出其实ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。</p><p><strong>1：ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</strong></p><p>此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p><p><strong>2：如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</strong></p><p>这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p><p><strong>3：数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</strong></p><p>第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span></span><br><span class="line"><span class="comment">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure><p>所以最终数组扩容后的大小为 16。</p><h2 id="请你说一说vector和list的区别"><a href="#请你说一说vector和list的区别" class="headerlink" title="请你说一说vector和list的区别"></a>请你说一说vector和list的区别</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>1、实现原理：采用动态对象数组实现，默认构造方法创建了一个空数组</p><p>2、第一次添加元素，扩展容量为10，之后的扩充算法：原来数组大小+原来数组的一半</p><p>3、当插入、删除位置比较靠前时，与链表比较，不适合进行删除或插入操作</p><p>4、为了防止数组动态扩充次数过多，建议创建ArrayList时，给定初始容量</p><p>5、多线程中使用不安全，适合在单线程访问时使用，效率较高</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>1、实现原理：采用动态数组对象实现，默认构造方法创建了一个大小为10的对象数组</p><p>2、扩充的算法：当增量为0时，扩充为原来的2倍，当增量大于0时，扩充为原来大小+增量</p><p>3、当插入、删除位置比较靠前时，与链表比较，不适合删除或插入操作</p><p>4、为了防止数组动态扩充次数过多，建议创建Vector时，给定初始容量</p><p>5、线程安全，适合在多线程访问时使用，效率较低</p><p>集合的使用注意：<br>若使用集合来存储多个不同类型的元素（对象），那么在处理时会比较麻烦<br>在实际开发中不建议这样使用，我们应该在一个集合中存储相同的类型对象</p><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p><p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p><p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</p><p>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h2 id="阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性</h2><p>1、ArrayList采用的是数组形式来保存对象的，这种方式将对象放在连续的位置中，所以最大的缺点就是插入删除时非常麻烦</p><p>2、LinkedList采用的将对象存放在独立的空间中，而且在每个空间中保存下一个链接的索引，但是缺点就是查找非常麻烦，要从第一个索引开始</p><p>3、ArrayList和Vector都是用数组方式存储数据，此数组元素数要大于实际的存储空间以便进行元素增加和插入操作，他们都允许直接用序号索引元素，但是插入数据元素涉及到元素移动等内存操作，所以索引数据快而插入数据慢</p><p>4、Vector使用了synchronized方法（线程安全），所以在性能上比ArrayList要差些</p><p>5、LinkedList使用双向链方式存储数据，按序号索引数据需要向前或向后遍历数据，索引索引数据慢，插入数据时只需要记录前后项即可，所以插入的速度快</p><h2 id="LinkedList的实现原理总结如下："><a href="#LinkedList的实现原理总结如下：" class="headerlink" title="LinkedList的实现原理总结如下："></a>LinkedList的实现原理总结如下：</h2><p>①数据存储是基于双向链表实现的。</p><p>②插入数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，再插入一个新节点。 双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。</p><p>③删除数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，进行如下操作：node.previous.next = node.next;node.next.previous = node.previous;node = null 。查找节点过程和插入一样。</p><p>④获取数据很慢，需要从Head节点进行查找。</p><p>⑤遍历数据很慢，每次获取数据都需要从头开始。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><h3 id="1、快速失败（fail-fast）"><a href="#1、快速失败（fail-fast）" class="headerlink" title="1、快速失败（fail-fast）"></a>1、快速失败（fail-fast）</h3><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.</p><p><code>原理</code>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><code>注意</code>：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p><code>场景</code>：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h3 id="2、安全失败（fail-safe）"><a href="#2、安全失败（fail-safe）" class="headerlink" title="2、安全失败（fail-safe）"></a>2、安全失败（fail-safe）</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p><code>缺点</code>：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的</p><p><code>场景</code>：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题</title>
      <link href="2021/06/11/java%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/11/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-的8种基本数据类型-及其大小？"><a href="#Java-的8种基本数据类型-及其大小？" class="headerlink" title="Java 的8种基本数据类型 及其大小？"></a>Java 的8种基本数据类型 及其大小？</h2><p><img src="https://img-blog.csdnimg.cn/20210124131220948.png"></p><h2 id="Java-基本类型与引用类型的区别？"><a href="#Java-基本类型与引用类型的区别？" class="headerlink" title="Java 基本类型与引用类型的区别？"></a>Java 基本类型与引用类型的区别？</h2><p>基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所 处的位置/地址）</p><h2 id="自动装箱和拆箱是什么"><a href="#自动装箱和拆箱是什么" class="headerlink" title="自动装箱和拆箱是什么"></a>自动装箱和拆箱是什么</h2><p>自动装箱是Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。</p><p>比如：把int转化成 Integer，double转化成 Double，等等。反之就是自动拆箱。</p><p>原始类型: boolean，char，byte，short，int，long，float，double </p><p>封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><h2 id="字节与字符的区别？"><a href="#字节与字符的区别？" class="headerlink" title="字节与字符的区别？"></a>字节与字符的区别？</h2><p>字节是存储容量的基本单位。</p><p>字符是数子，字母，汉子以及其他语言的各种符号。</p><p>1 字节=8 个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。</p><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向过程：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</p><p>面向对象：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</p><h2 id="java-当中的四种引用"><a href="#java-当中的四种引用" class="headerlink" title="java 当中的四种引用"></a>java 当中的四种引用</h2><p>强引用，软引用，弱引用，虚引用。不同的引用类型主要体现在 GC 上:</p><p><code>强引用</code>：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError  错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为 null，这样一来的话，JVM 在合适的时间就会回收该对象。</p><p><code>软引用</code>：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会<br>被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</p><p><code>弱引用</code>：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM  进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</p><p><code>虚引用</code>：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</p><h2 id="WeakReference-与-SoftReference-的区别"><a href="#WeakReference-与-SoftReference-的区别" class="headerlink" title="WeakReference 与 SoftReference 的区别?"></a>WeakReference 与 SoftReference 的区别?</h2><p>这点在四种引用类型中已经做了解释,这里简单说明一下即可:</p><p>虽 然 WeakReference  与 SoftReference   都 有利 于 提 高 GC  和 内 存的 效 率 ，但 是WeakReference  ，一旦失去最后一个强引用，就会被 GC  回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM  内存不足的时候。</p><h2 id="面向对象和面向过程的区别-1"><a href="#面向对象和面向过程的区别-1" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><code>面向过程</code>：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</p><p><code>面向对象</code>：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</p><h2 id="JDK-和-JRE-的区别？"><a href="#JDK-和-JRE-的区别？" class="headerlink" title="JDK 和 JRE 的区别？"></a>JDK 和 JRE 的区别？</h2><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p><p>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。</p><p>简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别?"></a>重载和重写的区别?</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载发生在一个类中，同名的方法如果有不同的参数列表（类型不同、个数不同、顺序不同）则视为重载。</p><p>重写发生在子类与父类之间，重写要求子类重写之后的方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><h3 id="方法重载的规则："><a href="#方法重载的规则：" class="headerlink" title="方法重载的规则："></a>方法重载的规则：</h3><ul><li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li><li>重载与方法的返回值无关，存在于父类和子类，同类中。</li><li>可以抛出不同的异常，可以有不同修饰符。</li></ul><h3 id="方法重写的规则："><a href="#方法重写的规则：" class="headerlink" title="方法重写的规则："></a>方法重写的规则：</h3><ul><li>参数列表、方法名、返回值类型必须完全一致；</li><li>构造方法不能被重写；</li><li>声明为 final 的方法不能被重写；</li><li>声明为 static 的方法不存在重写（重写和多态联合才有意义）；</li><li>访问权限不能比父类更低；</li><li>重写之后的方法不能抛出更宽泛的异常；</li></ul><h2 id="String-和-StringBuﬀer、StringBuilder-的区别是什么？"><a href="#String-和-StringBuﬀer、StringBuilder-的区别是什么？" class="headerlink" title="String 和 StringBuﬀer、StringBuilder 的区别是什么？"></a>String 和 StringBuﬀer、StringBuilder 的区别是什么？</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private　final　char　value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p><p>AbstractStringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a>对于三者使用的总结：</h3><ul><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ul><h2 id="反射-Class-forName-和-classLoader有什么区别"><a href="#反射-Class-forName-和-classLoader有什么区别" class="headerlink" title="反射 Class.forName 和 classLoader有什么区别"></a>反射 Class.forName 和 classLoader有什么区别</h2><p><strong>第一：Class.forName(“className”);</strong></p><p>其实这种方法调运的是：Class.forName(className,true,ClassLoader.getCallerClassLoader())方法</p><ul><li><p>参数一：className，需要加载的类的名称。</p></li><li><p>参数二：true，是否对class进行初始化（需要initialize）</p></li><li><p>参数三：classLoader，对应的类加载器a</p></li></ul><p><strong>第二：ClassLoader.loadClass(“className”);</strong></p><p>其实这种方法调运的是：ClassLoader.loadClass(name,false)方法</p><ul><li><p>参数一：name,需要加载的类的名称</p></li><li><p>参数二：false，这个类加载以后是否需要去连接（不需要linking）</p></li></ul><p><strong>第三：区别</strong></p><p>可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</p><p>而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</p><h2 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h2><p>代理模式，JDBC链接数据库，Spring</p><h2 id="反射的缺点是什么？如何优化？"><a href="#反射的缺点是什么？如何优化？" class="headerlink" title="反射的缺点是什么？如何优化？"></a>反射的缺点是什么？如何优化？</h2><p><strong>缺点：</strong> java反射是要解析字节码，将内存中的对象进行解析，包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多！ </p><p><strong>提高反射性能的方式有哪些？</strong></p><ol><li><p>setAccessible(true),可以防止安全性检查（做这个很费时）</p></li><li><p>做缓存，把要经常访问的元数据信息放入内存中，class.forName 太耗时</p></li><li><p>getMethods() 等方法尽量少用，尽量调用getMethod(name)指定方法的名称，减少遍历次数</p></li></ol><h2 id="静态代理模式和动态代理模式的区别"><a href="#静态代理模式和动态代理模式的区别" class="headerlink" title="静态代理模式和动态代理模式的区别"></a>静态代理模式和动态代理模式的区别</h2><p><strong>静态：</strong> 由程序员创建代理类。在程序运行前要代理的对象就已经指定了。</p><p><strong>动态：</strong> 在程序运行时运用反射机制动态创建而成。(InvocationHandler的应用)</p><h2 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h2><p>SpringAOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><p>（1）JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用InvocationHandler动态创建一个符合某一接口的的实例,生成目标类的代理对象。</p><p>（2）如果代理类没有实现InvocationHandler接口，那么SpringAOP会选择使用CGLIB来动态代理目标类。CGLIB（CodeGenerationLibrary），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而SpringAOP则无需特定的编译器处理。</p><h2 id="String类中intern-方法如何实现？"><a href="#String类中intern-方法如何实现？" class="headerlink" title="String类中intern()方法如何实现？"></a>String类中intern()方法如何实现？</h2><p>intern()方法设计的初衷，就是重用String对象，以节省内存消耗。这么说可能有点抽象，那么就用例子来证明。也就是会从常量池中首先获取</p><h2 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h2><p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><h2 id="抽象类和接口的区别是什么？"><a href="#抽象类和接口的区别是什么？" class="headerlink" title="抽象类和接口的区别是什么？"></a>抽象类和接口的区别是什么？</h2><p><code>实现</code>：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p><p><code>构造函数</code>：抽象类可以有构造函数；接口不能有。</p><p><code>实现数量</code>：类可以实现很多个接口；但只能继承一个抽象类【java只支持单继承】。</p><p><code>访问修饰符</code>：接口中的方法默认使用 public 修饰；抽象类中的抽象方法可以使用Public和Protected修饰，如果抽象方法修饰符为Private，则报错：The abstract method 方法名 in type Test can only set a visibility modifier, one of public or protected。<br>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定</p><p><code>设计层面</code>：抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p><h2 id="comparable-和-Comparator的区别？"><a href="#comparable-和-Comparator的区别？" class="headerlink" title="comparable 和 Comparator的区别？"></a>comparable 和 Comparator的区别？</h2><ul><li><p>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</p></li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p><h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><p>NullPointerException 空指针异常</p><p>ClassNotFoundException 指定类不存在</p><p>NumberFormatException 字符串转换为数字异常</p><p>IndexOutOfBoundsException 数组下标越界异常</p><p>ClassCastException 数据类型转换异常</p><p>FileNotFoundException 文件未找到异常</p><p>NoSuchMethodException 方法不存在异常</p><p>IOException IO 异常</p><p>SocketException Socket 异常</p><h2 id="什么是动态代理，怎么实现动态代理？"><a href="#什么是动态代理，怎么实现动态代理？" class="headerlink" title="什么是动态代理，怎么实现动态代理？"></a>什么是动态代理，怎么实现动态代理？</h2><p>动态代理是运行时动态生成代理类。 动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h2 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p><p>以下情况需要使用 Java 序列化：</p><p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</p><p>想用套接字在网络上传送对象的时候；</p><p>想通过RMI（远程方法调用）传输对象的时候。</p><h2 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p><p>抽象类是不能被实例化的，就是不能用new调出构造方法创建对象，普通类可以直接实例化。</p><p>如果一个类继承于抽象类，则该子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</p><h2 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><h2 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h2><p>indexOf()：返回指定字符的索引。</p><p>charAt()：返回指定索引处的字符。</p><p>replace()：字符串替换。</p><p>trim()：去除字符串两端空白。</p><p>split()：分割字符串，返回一个分割后的字符串数组。</p><p>getBytes()：返回字符串的 byte 类型数组。</p><p>length()：返回字符串长度。</p><p>toLowerCase()：将字符串转成小写字母。</p><p>toUpperCase()：将字符串转成大写字符。</p><p>substring()：截取字符串。</p><p>equals()：字符串比较。</p><h2 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法；但是包含一个抽象方法的类一定是抽象类。</p><h2 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=“i”的方式，Java 虚拟机会将其分配到常量池中，如果常量池中有”i”，就返回”i”的地址，如果没有就创建”i”，然后返回”i”的地址；而 String str=new String(“i”) 则会被分到堆内存中新开辟一块空间。</p><h2 id="String-属于基础的数据类型吗？"><a href="#String-属于基础的数据类型吗？" class="headerlink" title="String 属于基础的数据类型吗？"></a>String 属于基础的数据类型吗？</h2><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><h2 id="final-在-Java-中有什么作用？"><a href="#final-在-Java-中有什么作用？" class="headerlink" title="final 在 Java 中有什么作用？"></a>final 在 Java 中有什么作用？</h2><p>final 修饰的类叫最终类，该类不能被继承。</p><p>final 修饰的方法不能被重写。</p><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h2 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h2><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p><h2 id="Java-中的-Math-round-1-5-等于多少？"><a href="#Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="Java 中的 Math. round(-1. 5) 等于多少？"></a>Java 中的 Math. round(-1. 5) 等于多少？</h2><p>等于 -1。round()是四舍五入，注意负数5是舍的，例如：Math.round(1.5)值是2，Math.round(-1.5)值是-1。</p><h2 id="与-equals-的区别？"><a href="#与-equals-的区别？" class="headerlink" title="== 与 equals 的区别？"></a>== 与 equals 的区别？</h2><h3 id="解读"><a href="#解读" class="headerlink" title="== 解读:"></a>== 解读:</h3><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><p>基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><h3 id="equals-解读"><a href="#equals-解读" class="headerlink" title="equals 解读:"></a>equals 解读:</h3><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">&quot;精彩猿笔记&quot;</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">&quot;精彩猿笔记&quot;</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。 那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;精彩猿笔记&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;精彩猿笔记&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String anotherString = (String)anObject;</span><br><span class="line"><span class="keyword">int</span> n = value.length;</span><br><span class="line"><span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"><span class="keyword">char</span> v1[] = value;</span><br><span class="line"><span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 </p><p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals时必须重写 hashCode 方法？”</p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函<br>数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高<br>了执行速度。</p><h3 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h3><ol><li><p> 如果两个对象相等，则 hashcode 一定也是相同的</p></li><li><p> 两个对象相等,对两个对象分别调用 equals 方法都返回 true</p></li><li><p> 两个对象有相同的 hashcode 值，它们也不一定是相等的</p></li><li><p> 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p></li><li><p> hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写<br>hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></li></ol><h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><ul><li>名字与类名相同。</li><li>没有返回值，但不能用void声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><h2 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h2><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p><h2 id="Java序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java序列化中如果有些字段不想进行序列化，怎么办？"></a>Java序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用transient关键字修饰。</p><p>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p><h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><p><code>按功能来分</code>：输入流（input）、输出流（output）。 </p><p><code>按类型来分</code>：字节流和字符流。 </p><p><code>字节流和字符流的区别是</code>：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h2 id="BIO、NIO、AIO-有什么区别"><a href="#BIO、NIO、AIO-有什么区别" class="headerlink" title="BIO、NIO、AIO 有什么区别?"></a>BIO、NIO、AIO 有什么区别?</h2><ul><li><p>BIO (Blocking I/O): <strong>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</strong>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p></li><li><p>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p></li><li><p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p></li></ul><h2 id="static-关键字的理解？"><a href="#static-关键字的理解？" class="headerlink" title="static 关键字的理解？"></a>static 关键字的理解？</h2><ul><li><p><code>修饰成员变量和成员方法</code>: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()</p></li><li><p><code>静态代码块</code>: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p></li><li><p><code>静态内部类（static修饰类的话只能修饰内部类）</code>： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</p></li><li><p><code>静态导包(用来导入类中的静态资源，1.5之后的新特性)</code>: 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</p></li></ul><h2 id="super-关键字的理解"><a href="#super-关键字的理解" class="headerlink" title="super 关键字的理解"></a>super 关键字的理解</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。</p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li><p>在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</p></li><li><p>this、super不能用在static方法中。</p></li></ul><p>简单解释一下：</p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p><img src="https://img-blog.csdnimg.cn/20210124134135662.png" alt="在这里插入图片描述"></p><h2 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3*0.1==0.3返回值是什么"></a>3*0.1==0.3返回值是什么</h2><p>false，因为有些浮点数不能完全精确的表示出来。</p><h2 id="shorts1-1-s1-s1-1-该段代码是否有错-有的话怎么改？"><a href="#shorts1-1-s1-s1-1-该段代码是否有错-有的话怎么改？" class="headerlink" title="shorts1=1;s1=s1+1;该段代码是否有错,有的话怎么改？"></a>shorts1=1;s1=s1+1;该段代码是否有错,有的话怎么改？</h2><p>有错误，short类型在进行运算时会自动提升为int类型，也就是说s1+1的运算结果是int类型。</p><h2 id="shorts1-1-s1-1-该段代码是否有错，有的话怎么改？"><a href="#shorts1-1-s1-1-该段代码是否有错，有的话怎么改？" class="headerlink" title="shorts1=1;s1+=1;该段代码是否有错，有的话怎么改？"></a>shorts1=1;s1+=1;该段代码是否有错，有的话怎么改？</h2><p>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型，所以没错。</p><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><p>首先记住&amp;是位操作，而&amp;&amp;是逻辑运算符。另外需要记住逻辑运算符具有短路特性，而&amp;不具备短路特性。</p><h2 id="final-finalize和finally的不同之处"><a href="#final-finalize和finally的不同之处" class="headerlink" title="final,finalize和finally的不同之处"></a>final,finalize和finally的不同之处</h2><p>final是一个修饰符，可以修饰变量、方法和类。如果final修饰变量，意味着该变量的值在初始化后不能被改变。finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用finalize没有保证。finally是一个关键字，与try和catch</p><p>一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。</p><h2 id="深拷贝和浅拷贝的区别是什么"><a href="#深拷贝和浅拷贝的区别是什么" class="headerlink" title="深拷贝和浅拷贝的区别是什么?"></a>深拷贝和浅拷贝的区别是什么?</h2><p><code>浅拷贝</code>：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p><code>深拷贝</code>：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的</p><h2 id="final有哪些用法"><a href="#final有哪些用法" class="headerlink" title="final有哪些用法"></a>final有哪些用法</h2><p>final也是很多面试喜欢问的地方，能回答下以下三点就不错了：</p><p>1.被final修饰的类不可以被继承</p><p>2.被final修饰的方法不可以被重写</p><p>3.被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。</p><p>4.被final修饰的方法，JVM会尝试将其内联，以提高运行效率</p><p>5.被final修饰的常量，在编译阶段会存入常量池中。</p><h2 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h2><p>封装，继承，多态</p><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同，而采用多种不同的行为方式(发送消息就是函数调用)。主要有以下优点：</p><ul><li><p>可替换性：多态对已存在代码具有可替换性</p></li><li><p>可扩充性：增加新的子类不影响已经存在的类结构</p></li><li><p>接口性：多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的。</p></li><li><p>灵活性</p></li><li><p>简化性</p></li></ul><h2 id="代码中如何实现多态"><a href="#代码中如何实现多态" class="headerlink" title="代码中如何实现多态"></a>代码中如何实现多态</h2><p>实现多态主要有以下三种方式：</p><p>1.接口实现</p><p>2.继承父类重写方法</p><p>3.同一类中进行方法重载</p><h2 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a>什么是不可变对象</h2><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如String、Integer及其它包装类。</p><h2 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别?"></a>静态变量和实例变量的区别?</h2><p>静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈。</p><h2 id="Nio"><a href="#Nio" class="headerlink" title="Nio"></a>Nio</h2><h3 id="nio介绍"><a href="#nio介绍" class="headerlink" title="nio介绍"></a>nio介绍</h3><p>NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p><h3 id="Buffer参数"><a href="#Buffer参数" class="headerlink" title="Buffer参数"></a>Buffer参数</h3><ul><li><p>capacity（容量）：缓冲区的容量，不可以为负数，一旦创建了就不能够改变</p></li><li><p>limit（界限）：是缓冲区读写数据的终止点，limit之后的区域无法访问</p></li><li><p>position（起始指针）：是缓冲区读写数据的起始点，初始值为0。position随着数据的加入而改变，例如读取2个数据到Buffer中，则position = 2</p></li><li><p>mark（标记）：该索引能够用于下次读取或者写入，mark在0~position之间，设置该值就会把position移动到mark处</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210131234322524.png"></p><h3 id="Buffer方法"><a href="#Buffer方法" class="headerlink" title="Buffer方法"></a>Buffer方法</h3><ul><li>flip()：读取模式；确定缓冲区数据的起始点和终止点，为输出数据做准备(即写入通道)， 将limit的值改为postion的值，同时将postion归0</li></ul><p>特点: 就是为下一次数据的读取做好准备</p><ul><li>clear()：写入模式；缓冲区初始化，准备再次接收新数据到缓冲区，将limit改为capacity的值，同时将postion归0</li></ul><p>特点: 就是为下一次数据的写入做好准备</p><ul><li><p>get()和put()：获取元素和存放元素。使用clear()之后，无法直接使用get()获取元素，需要使用get(int index)根据索引值来获取相应元素</p></li><li><p>hasRemaining()：判断postion到limit之间是否还有元素。</p></li></ul><h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel(通道)"></a>Channel(通道)</h3><p>Channel原理类似于传统的流对象，区别在于：</p><p>1.Channel能够将指定的部分或者全部文件映射到内存中</p><p>2.程序如果想要读取Channel中的数据，不能够直接读写，必须经过Buffer</p><p>简单来说：<strong>Channel通过Buffer(缓冲区)进行读写操作。read()表示读取通道数据到缓冲区，write()表示把缓冲区数据写入到通道。</strong></p><h3 id="Channel实现类"><a href="#Channel实现类" class="headerlink" title="Channel实现类"></a>Channel实现类</h3><ul><li>FileChannel 和文件相关的通道</li><li>DatagramChannel 和UDP协议传输数据相关的通道</li><li>SocketChannel 和TCP协议相关的数据传输通道</li><li>ServerSocket 和TCP协议相关的数据传输通道</li><li>Pipe.SinkChannel、Pipe.SourceChannel //线程通信管道传输数据</li></ul><h3 id="Selector（选择器）介绍"><a href="#Selector（选择器）介绍" class="headerlink" title="Selector（选择器）介绍"></a>Selector（选择器）介绍</h3><p>我们的NIO模拟的I/O模型就是I/O复用模型。通过只阻塞Selector这一个线程，通过Selector不断的查询Channel中的状态，从而达到了一个线程控制Selector，而一个Selector控制多个Channel的目的。用图表示就是这样。</p><p><img src="https://img-blog.csdnimg.cn/20210131235042390.png"></p><p>通过调用Selector.open()方法来创建一个Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="Selector监听的四种事件"><a href="#Selector监听的四种事件" class="headerlink" title="Selector监听的四种事件"></a>Selector监听的四种事件</h3><ul><li><p>SelectionKey.OP_CONNECT：连接继续事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</p></li><li><p>SelectionKey.OP_ACCEPT：连接就绪事件，服务端收到客户端的一个连接请求会触发</p></li><li><p>SelectionKey.OP_READ：读就绪事件，表示通道中已经有可读的数据了，可以执行读操作</p></li><li><p>SelectionKey.OP_WRITE：写就绪事件，表示已经可以向通道写数据了</p></li></ul><h2 id="NIO空轮询的bug"><a href="#NIO空轮询的bug" class="headerlink" title="NIO空轮询的bug"></a>NIO空轮询的bug</h2><p>这个bug是指 java的NIO在linux下selector.select()时，本来如果轮询的结果为空并且不调用wakeup的方法的话，这个selector.select()应该是一直阻塞的，但是java却会打破阻塞，继续执行，导致程序无限空转，造成CPU使用率100%</p><p><img src="https://img-blog.csdnimg.cn/20210201000407777.png"></p><p>这个bug只出现在linux系统下，因为linux下NIO底层使用的是epoll来实现的，而java的epoll实现存在bug，导致selector出现了这种轮询为空却唤醒的情况。windows下NIO是使用的poll来实现selector的就不存在这种bug</p><p>netty中解决了这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaWeb</title>
      <link href="2021/06/11/javaWeb/"/>
      <url>2021/06/11/javaWeb/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP-和-servlet-有什么区别？"><a href="#JSP-和-servlet-有什么区别？" class="headerlink" title="JSP 和 servlet 有什么区别？"></a>JSP 和 servlet 有什么区别？</h2><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h2 id="JSP-有哪些内置对象？作用分别是什么？"><a href="#JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP 有哪些内置对象？作用分别是什么？"></a>JSP 有哪些内置对象？作用分别是什么？</h2><p>JSP 有 9 大内置对象：</p><p>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</p><p>response：封装服务器对客户端的响应；</p><p>pageContext：通过该对象可以获取其他对象；</p><p>session：封装用户会话的对象；</p><p>application：封装服务器运行环境的对象；</p><p>out：输出服务器响应的输出流对象；</p><p>config：Web 应用的配置对象；</p><p>page：JSP 页面本身（相当于 Java 程序中的 this）；</p><p>exception：封装页面抛出异常的对象。</p><h2 id="说一下-JSP-的-4-种作用域？"><a href="#说一下-JSP-的-4-种作用域？" class="headerlink" title="说一下 JSP 的 4 种作用域？"></a>说一下 JSP 的 4 种作用域？</h2><p>page：代表与一个页面相关的对象和属性。</p><p>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</p><p>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</p><p>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h2 id="说一下-session-的工作原理？"><a href="#说一下-session-的工作原理？" class="headerlink" title="说一下 session 的工作原理？"></a>说一下 session 的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h2 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="Java-Web-如何避免-SQL-注入？"><a href="#Java-Web-如何避免-SQL-注入？" class="headerlink" title="Java Web 如何避免 SQL 注入？"></a>Java Web 如何避免 SQL 注入？</h2><p>使用预处理 PreparedStatement。</p><p>使用正则表达式过滤掉字符中的特殊字符。</p><h2 id="请说一下表达式语言（EL）的隐式对象以及该对象的作用"><a href="#请说一下表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="请说一下表达式语言（EL）的隐式对象以及该对象的作用"></a>请说一下表达式语言（EL）的隐式对象以及该对象的作用</h2><p>EL的隐式对象包括：</p><ul><li><p>pageContext、initParam（访问上下文参数）</p></li><li><p>param（访问请求参数）</p></li><li><p>paramValues、header（访问请求头）</p></li><li><p>headerValues、cookie（访问cookie）</p></li><li><p>applicationScope（访问application作用域）</p></li><li><p>sessionScope（访问session作用域）</p></li><li><p>requestScope（访问request作用域）</p></li><li><p>pageScope（访问page作用域）。</p></li></ul><h2 id="请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"><a href="#请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？" class="headerlink" title="请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"></a>请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？</h2><p>JSP有9个内置对象： </p><ul><li><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数； </p></li><li><p>response：封装服务器对客户端的响应；</p></li><li><p>pageContext：通过该对象可以获取其他对象； </p></li><li><p>session：封装用户会话的对象；</p></li><li><p>application：封装服务器运行环境的对象； </p></li><li><p>out：输出服务器响应的输出流对象； </p></li><li><p>config：Web应用的配置对象；</p></li><li><p>page：JSP页面本身（相当于Java程序中的this）；</p></li><li><p>exception：封装页面抛出异常的对象。</p></li></ul><h2 id="请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"><a href="#请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？" class="headerlink" title="请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"></a>请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？</h2><p>JSP 是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑</p><h2 id="请谈谈你对Javaweb开发中的监听器的理解？"><a href="#请谈谈你对Javaweb开发中的监听器的理解？" class="headerlink" title="请谈谈你对Javaweb开发中的监听器的理解？"></a>请谈谈你对Javaweb开发中的监听器的理解？</h2><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，</p><p>如下所示： </p><p>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。</p><p>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。 </p><p>③HttpSessionListener：对Session的创建和销毁进行监听。</p><p>session的销毁有两种情况：</p><p>1). session超时（可以在web.xml中通过/标签配置超时时间）；</p><p>2). 通过调用session对象的invalidate()方法使session失效。 </p><p>④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。 </p><p>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。 </p><p>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p><h2 id="请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"><a href="#请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？" class="headerlink" title="请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"></a>请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？</h2><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><p>Servlet 通过调用 init () 方法进行初始化。</p><p>Servlet 调用 service() 方法来处理客户端的请求。</p><p>Servlet 通过调用 destroy() 方法终止（结束）。</p><p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p><p>Servlet单实例，减少了产生servlet的开销；</p><h2 id="请简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？"><a href="#请简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？" class="headerlink" title="请简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？"></a>请简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？</h2><p>1.从地址栏显示来说</p><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p><p>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><p>2.从数据共享来说</p><p>forward:转发页面和转发到的页面可以共享request里面的数据.</p><p>redirect:不能共享数据.</p><p>3.从运用地方来说</p><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.</p><p>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.</p><p>4.从效率来说</p><p>forward:高.</p><p>redirect:低.</p><p>redirect的状态码是302</p><h2 id="请谈一谈，get和post的区别？"><a href="#请谈一谈，get和post的区别？" class="headerlink" title="请谈一谈，get和post的区别？"></a>请谈一谈，get和post的区别？</h2><ol><li>携带请求参数的方式</li></ol><ul><li>GET: 通过请求行携带参数, 参数会显示在地址栏</li><li>POST: 通过请求体来携带参数, 参数不会显示在地址栏 </li></ul><ol start="2"><li>服务器端处理请求的方法</li></ol><ul><li>GET: 会调用 Servlet 的 doGet()来处理请求</li><li>POST: 会调用 Servlet 的 doPost()来处理请求 </li></ul><ol start="3"><li>数据大小与安全性</li></ol><ul><li>GET: 大小有限制(小于 2k), 不安全 POST: 大小没有限制, 安全</li></ul><h2 id="请你说说，cookie-和-session-的区别？"><a href="#请你说说，cookie-和-session-的区别？" class="headerlink" title="请你说说，cookie 和 session 的区别？"></a>请你说说，cookie 和 session 的区别？</h2><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><h2 id="jsp-有哪些动作-作用分别是什么"><a href="#jsp-有哪些动作-作用分别是什么" class="headerlink" title="jsp 有哪些动作?作用分别是什么?"></a>jsp 有哪些动作?作用分别是什么?</h2><p>JSP 共有以下 6 种基本动作 </p><ul><li><p>jsp:include:在页面被请求的时候引入一个文件。 </p></li><li><p>jsp:forward:把请求转到一个新的页面。 </p></li><li><p>jsp:useBean:寻找或者实例化一个 JavaBean。</p></li><li><p>jsp:setProperty:设置 JavaBean 的属性。</p></li><li><p>jsp:getProperty:输出某个 JavaBean 的属性。 </p></li><li><p>jsp:plugin:根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记</p></li></ul><h2 id="MVC-的各个部分都有那些技术来实现-如何实现"><a href="#MVC-的各个部分都有那些技术来实现-如何实现" class="headerlink" title="MVC 的各个部分都有那些技术来实现?如何实现?"></a>MVC 的各个部分都有那些技术来实现?如何实现?</h2><p>MVC 是 Model-View-Controller 的简写。</p><p>Model 代表的是应用的业务逻辑(通过 JavaBean，EJB 组件实现)，</p><p>View 是应用的表示面(由 JSP 页面产生)，</p><p>Controller 是提供应用的处理过程控制(一般是一个 Servlet)， </p><p>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这<br>些组件可以进行交互和重用。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc</title>
      <link href="2021/06/11/springmvc/"/>
      <url>2021/06/11/springmvc/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p><p>（2）与Spring框架集成（如IoC容器、AOP等）；</p><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p><p>（4） 支持各种请求资源的映射策略。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p><p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p><p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p><p>作用：根据请求的URL来查找Handler</p><p>（3）处理器适配器HandlerAdapter</p><p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p><p>（4）处理器Handler（需要程序员开发）</p><p>（5）视图解析器 ViewResolver（不需要程序员开发）</p><p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p><p>（6）视图View（需要程序员开发jsp）</p><p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><h3 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h3><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><h3 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h3><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><h3 id="Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h3><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p><p><img src="https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><h3 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h3><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p><p>mvc设计模式的好处</p><p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p><p>2.有利于系统的并行开发，提升开发效率。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="注解原理是什么"><a href="#注解原理是什么" class="headerlink" title="注解原理是什么"></a>注解原理是什么</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h3 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h3 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h3 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h3><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><ul><li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li><li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li></ul><h3 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h3><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p><strong>value， method</strong></p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><p><strong>consumes，produces</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>params，headers</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h3 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h3><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h3 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h3><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)</p><p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h3><p>相同点</p><p>都是基于mvc的表现层框架，都用于web项目的开发。</p><p>不同点</p><p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</p><p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p><p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p><p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p><h3 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h3><p>（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</p><p>（2）重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></p><h3 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p><p>（1）加入Jackson.jar</p><p>（2）在配置文件中配置json的映射</p><p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p><h3 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）get请求中文参数出现乱码解决方法有两个：</p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><p>②另外一种方法对参数进行重新编码：</p><p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h3 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h3><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p><h3 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p><h3 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p><h3 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h3><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h3 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h3 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h3><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> SpringMvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="2021/06/11/springBoot/"/>
      <url>2021/06/11/springBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><p>Spring Boot 主要有如下优点：</p><ol><li> 容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li> 开箱即用，远离繁琐的配置。</li><li> 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li> 没有代码生成，也不需要XML配置。</li><li> 避免大量的 Maven 导入和各种版本冲突。</li></ol><h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p><p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p><p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h3 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）properties文件；</p><p>2）YAML文件；</p><p>3）系统环境变量；</p><p>4）命令行参数；</p><p>等等……</p><h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li> 配置有序，在一些特殊的场景下，配置有序很关键</li><li> 支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li> 简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h3 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li></ul><h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p><h3 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ol><li> Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li> Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li> Spring Security 功能强大；Shiro 功能简单</li></ol><h3 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h3><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h3><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><h3 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h3><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p><h3 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h3 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h3><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h2 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h2><h3 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h3><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><ol><li> MongoDB （文档数据库）</li><li> Neo4j（图形数据库）</li><li> Redis（键/值存储）</li><li> Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li> JDBC</li><li> JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h3 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h3><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h3 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h3><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p><h3 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h3><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h3 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h3><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h3 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><h3 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h3><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h3><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><h3 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h3><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p><h3 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h3><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li> 定义了 Java 编译版本为 1.8 。</li><li> 使用 UTF-8 格式编码。</li><li> 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li> 执行打包操作的配置。</li><li> 自动化的资源过滤。</li><li> 自动化的插件配置。</li><li> 针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><h3 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java \-jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><p>1）打包用命令或者放到容器中运行</p><p>2）用 Maven/ Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p><h3 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h3><p>1）继承spring-boot-starter-parent项目</p><p>2）导入spring-boot-dependencies项目依赖</p><h3 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h3><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h3 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h3><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><h3 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h3><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h3 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h3><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><h2 id="SpringBoot启动流程是怎样的？"><a href="#SpringBoot启动流程是怎样的？" class="headerlink" title="SpringBoot启动流程是怎样的？"></a>SpringBoot启动流程是怎样的？</h2><p><img src="https://img-blog.csdnimg.cn/20210130223444859.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>SpringBoot一开始最让我印象深刻的就是通过一个启动类就能启动应用。在SpringBoot以前，启动应用虽然也不麻烦，但是还是有点繁琐，要打包成war包，又要配置tomcat，tomcat又有一个server.xml文件去配置。</p><p>然而SpringBoot则内置了tomcat，通过启动类启动，配置也集中在一个application.yml中，简直不要太舒服。好奇心驱动，于是我很想搞清楚启动类的启动过程，那么开始吧。</p><h3 id="一、启动类"><a href="#一、启动类" class="headerlink" title="一、启动类"></a>一、启动类</h3><p>首先我们看最常见的启动类写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringmvcApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringmvcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把启动类分解一下，实际上就是两部分：</p><ul><li><p>@SpringBootApplication注解</p></li><li><p>一个main()方法，里面调用SpringApplication.run()方法。</p></li></ul><h3 id="二、-SpringBootApplication"><a href="#二、-SpringBootApplication" class="headerlink" title="二、@SpringBootApplication"></a>二、@SpringBootApplication</h3><p>首先看@SpringBootApplication注解的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，@SpringBootApplication注解由三个注解组合而成，分别是：</p><ul><li>@ComponentScan</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><h3 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1 @ComponentScan"></a>2.1 @ComponentScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(ComponentScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解的作用是告诉Spring扫描哪个包下面类，加载符合条件的组件(比如贴有@Component和@Repository等的类)或者bean的定义。</p><p>所以有一个basePackages的属性，如果默认不写，则从声明@ComponentScan所在类的package进行扫描。</p><p>所以启动类最好定义在Root package下，因为一般我们在使用@SpringBootApplication时，都不指定basePackages的。</p><h3 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 @EnableAutoConfiguration"></a>2.2 @EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个复合注解，看起来很多注解，实际上关键在@Import注解，它会加载AutoConfigurationImportSelector类，然后就会触发这个类的selectImports()方法。根据返回的String数组(配置类的Class的名称)加载配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回的String[]数组，是配置类Class的类名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="comment">//返回配置类的类名</span></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一直点下去，就可以找到最后的幕后英雄，就是SpringFactoriesLoader类，通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类。</p><p><img src="https://img-blog.csdnimg.cn/20210130223727415.png"></p><p><img src="https://img-blog.csdnimg.cn/20210130223743342.png"></p><p>这里使用了spring.factories文件的方式加载配置类，提供了很好的扩展性。</p><p>所以@EnableAutoConfiguration注解的作用其实就是开启自动配置，自动配置主要则依靠这种加载方式来实现。</p><h3 id="2-3-SpringBootConfiguration"><a href="#2-3-SpringBootConfiguration" class="headerlink" title="2.3 @SpringBootConfiguration"></a>2.3 @SpringBootConfiguration</h3><p>@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>我们在这里画张图把@SpringBootApplication注解包含的三个注解分别解释一下。</p><p><img src="https://img-blog.csdnimg.cn/20210130223819323.png"></p><h3 id="三、SpringApplication类"><a href="#三、SpringApplication类" class="headerlink" title="三、SpringApplication类"></a>三、SpringApplication类</h3><p>接下来讲main方法里执行的这句代码，这是SpringApplication类的静态方法run()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动类的main方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringmvcApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动类调的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调的是下面的，参数是数组的run方法</span></span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和上面的方法区别在于第一个参数是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际上new一个SpringApplication实例，调的是一个实例方法run()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，发现实际上最后调的并不是静态方法，而是实例方法，需要new一个SpringApplication实例，这个构造器还带有一个primarySources的参数。所以我们直接定位到构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">//断言primarySources不能为null，如果为null，抛出异常提示</span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//启动类传入的Class</span></span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">//判断当前项目类型，有三种：NONE、SERVLET、REACTIVE</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">//设置ApplicationContextInitializer</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">//设置监听器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">//判断主类，初始化入口类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断主类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// Swallow and continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是创建SpringApplication实例做的事情，下面用张图来表示一下。</p><p><img src="https://img-blog.csdnimg.cn/20210130223919499.png"></p><p>创建了SpringApplication实例之后，就完成了SpringApplication类的初始化工作，这个实例里包括监听器、初始化器，项目应用类型，启动类集合，类加载器。如图所示。</p><p><img src="https://img-blog.csdnimg.cn/20210130223935996.png"></p><p>得到SpringApplication实例后，接下来就调用实例方法run()。继续看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建计时器</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    <span class="comment">//开始计时</span></span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">//定义上下文对象</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Headless模式设置</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//加载SpringApplicationRunListeners监听器</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//发送ApplicationStartingEvent事件</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//封装ApplicationArguments对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">//配置环境模块</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="comment">//根据环境信息配置要忽略的bean信息</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">//打印Banner标志</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">//创建ApplicationContext应用上下文</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">//加载SpringBootExceptionReporter</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                         <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        <span class="comment">//ApplicationContext基本属性配置</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//刷新上下文</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">//刷新后的操作，由子类去扩展</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">//计时结束</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送ApplicationStartedEvent事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">//查找容器中注册有CommandLineRunner或者ApplicationRunner的bean，遍历并执行run方法</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//发送ApplicationFailedEvent事件，标志SpringBoot启动失败</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送ApplicationReadyEvent事件，标志SpringApplication已经正在运行，即已经成功启动，可以接收服务请求。</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//报告异常，但是不发送任何事件</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合注释和源码，其实很清晰了，为了加深印象，画张图看一下整个流程。</p><p><img src="https://img-blog.csdnimg.cn/20210130224013774.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>表面启动类看起来就一个@SpringBootApplication注解，一个run()方法。其实是经过高度封装后的结果。我们可以从这个分析中学到很多东西。比如使用了spring.factories文件来完成自动配置，提高了扩展性。在启动时使用观察者模式，以事件发布的形式通知，降低耦合，易于扩展等等。</p><h2 id="Springboot的自动配置原理？"><a href="#Springboot的自动配置原理？" class="headerlink" title="Springboot的自动配置原理？"></a>Springboot的自动配置原理？</h2><p>（1）Springboot应用启动的时候，回去寻找带有SpringBootApplication注解的类，当寻找到这个注解之后。开始解析这个注解</p><p>（2）@SpringBootConfiguration：标记当前类为配置类<br>@EnableAutoConfiguration：开启自动配置<br>@ComponentScan：扫描主类所在的同级包以及下级包里的Bean<br>扫描到这个三个注解之后，底层就开始通过反射+代理机制加载解析各自的子注解，然后开始配置初始换一些环境信息；</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2021/06/11/spring/"/>
      <url>2021/06/11/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h3 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring?"></a>什么是spring?</h3><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早有<strong>Rod Johnson</strong>创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</p><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）</strong>和<strong>面向切面编程（aspect-oriented programming，AOP）</strong>。</p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><h3 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么"></a>Spring框架的设计目标，设计理念，和核心是什么</h3><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p><p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p><p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h3 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h3><p>优点</p><ul><li><p>方便解耦，简化开发</p><p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p></li><li><p>AOP编程的支持</p><p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p></li><li><p>声明式事务的支持</p><p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p></li><li><p>方便程序的测试</p><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p></li><li><p>方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p></li><li><p>降低JavaEE API的使用难度</p><p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p></li></ul><p>缺点</p><ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring依赖反射，反射影响性能</li><li>使用门槛升高，入门Spring需要较长时间</li></ul><h3 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h3><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p><p><strong>Spring价值</strong>：</p><ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li></ul><h3 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h3><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container）</code> 、 <code>AOP（Aspect Oriented Programming）和设备支持（Instrmentation）</code> 、<code>数据访问与集成（Data Access/Integeration）</code> 、 <code>Web</code>、 <code>消息（Messaging）</code> 、 <code>Test</code>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p><p><img src="https://img-blog.csdnimg.cn/2019102923475419.png" alt="在这里插入图片描述"></p><ul><li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li><li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li></ul><h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h3><ol><li> 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li> 单例模式：Bean默认为单例模式。</li><li> 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li> 模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li> 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li></ol><h3 id="详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="详细讲解一下核心容器（spring context应用上下文) 模块"></a>详细讲解一下核心容器（spring context应用上下文) 模块</h3><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><h3 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a>Spring框架中有哪些不同类型的事件</h3><p>Spring 提供了以下5种标准的事件：</p><ol><li><p> 上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p></li><li><p> 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p></li><li><p> 上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p></li><li><p> 上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p></li><li><p> 请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p></li></ol><h3 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>用户程序 - 它使用接口。</li></ul><h3 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li><li>用于远程使用。</li></ul><h2 id="Spring控制反转-IOC-（13）"><a href="#Spring控制反转-IOC-（13）" class="headerlink" title="Spring控制反转(IOC)（13）"></a>Spring控制反转(IOC)（13）</h2><h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h3 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h3><ul><li><p>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</p></li><li><p>解耦，由容器去维护具体的对象</p></li><li><p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p></li></ul><h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><h3 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h3><p>Spring 的 IoC 设计支持以下功能：</p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ul><p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><h3 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>依赖关系</p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li><p>继承MessageSource，因此支持国际化。</p></li><li><p>统一的资源文件访问方式。</p></li><li><p>提供在监听器中注册bean的事件。</p></li><li><p>同时加载多个配置文件。</p></li><li><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p></li></ul><p>加载方式</p><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>创建方式</p><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>注册方式</p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h3 id="Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h3><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 <strong>“低级容器”</strong>。</p><p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><p>BeanFactory和ApplicationContext的关系</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p><p><img src="https://img-blog.csdnimg.cn/20191105111441363.png" alt="img"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p><strong>小结</strong></p><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p> 加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p> 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h3 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p><p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h3 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h3><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h3 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><ul><li>查找定位操作与应用代码完全无关。</li><li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li><li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li></ul><h3 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h3><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><table><thead><tr><th><strong>构造函数注入</strong></th><th><strong>setter</strong> <strong>注入</strong></th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h2 id="Spring-Beans（19）"><a href="#Spring-Beans（19）" class="headerlink" title="Spring Beans（19）"></a>Spring Beans（19）</h2><h3 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h3><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p><h3 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h3><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p><h3 id="如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li></ul><h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h3 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h3><ol><li><p> Set方法注入；</p></li><li><p> 构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p></li><li><p> 静态工厂注入；</p></li><li><p> 实例工厂；</p></li></ol><h3 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h3><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h3 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p><ul><li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li><li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h3 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h3 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h3><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h3 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释Spring框架中bean的生命周期</h3><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p><p><img src="https://img-blog.csdnimg.cn/201911012343410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70"></p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><p>Spring对bean进行实例化；</p><p>Spring将值和bean的引用注入到bean对应的属性中；</p><p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p><p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p><p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p><p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p><p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p><p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p><p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p><h3 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><h3 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h3><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p><h3 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h3><p>Spring提供以下几种集合的配置元素：</p><p>类型用于注入一列值，允许有相同的值。</p><p>类型用于注入一组值，不允许有相同的值。</p><p>类型用于注入一组键值对，键和值都可以为任意类型。</p><p>类型用于注入一组键值对，键和值都只能为String类型。</p><h3 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h3><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><h3 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p><h3 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><ul><li><p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p></li><li><p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p></li><li><p>byType：通过参数的数据类型进行自动装配。</p></li><li><p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p></li><li><p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p></li></ul><h3 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p></li><li><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></li><li><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p></li></ul><h3 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h3><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><h3 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h3><p>可以。</p><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>元素。</p><h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h3 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h3><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h3><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><ul><li><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p></li><li><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p></li></ul><h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p><h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h2 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h2><h3 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h3><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h3 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h3><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><h3 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p><h3 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h3><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h3 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h3><p>JdbcTemplate</p><p>SimpleJdbcTemplate</p><p>NamedParameterJdbcTemplate</p><p>SimpleJdbcInsert</p><p>SimpleJdbcCall</p><h3 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h3><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h3 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>在Spring中有两种方式访问Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul><h3 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h3><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p><ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul><h3 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：</p><p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h3 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h3 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><h3 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ol><li><p> ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p></li><li><p> ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p></li><li><p> ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p></li><li><p> ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p></li><li><p> ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p></li></ol><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h3 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h3><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><h3 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h3><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h2 id="Spring面向切面编程-AOP-（13）"><a href="#Spring面向切面编程-AOP-（13）" class="headerlink" title="Spring面向切面编程(AOP)（13）"></a>Spring面向切面编程(AOP)（13）</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><h3 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ul><li><p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p></li><li><p>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p></li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><blockquote><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><h3 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><p>Advice + Target Object = Proxy</p><h3 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul><h3 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p><h3 id="Spring只支持方法级别的连接点"><a href="#Spring只支持方法级别的连接点" class="headerlink" title="Spring只支持方法级别的连接点"></a>Spring只支持方法级别的连接点</h3><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p><h3 id="在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h3 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ol><li> 前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li> 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li> 返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li><li> 异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li> 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ol><blockquote><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote><h3 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ul><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ul><p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p><img src="https://img-blog.csdnimg.cn/2020021212264438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h3><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h3 id="解释基于注解的切面实现"><a href="#解释基于注解的切面实现" class="headerlink" title="解释基于注解的切面实现"></a>解释基于注解的切面实现</h3><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p><h3 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h3><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p><h2 id="Spring解决循环依赖"><a href="#Spring解决循环依赖" class="headerlink" title="Spring解决循环依赖"></a>Spring解决循环依赖</h2><p>首先， Spring解决循环依赖有两个前提条件：</p><p>1、不全是构造器方法的循环依赖</p><p>2、必须是单例</p><p>基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存, 通过三级缓存提前拿到为初始化的对象</p><p>第一级缓存：用来保存实例化、初始化都完成的对象。</p><p>第二级缓存：用来保存实例化完成， 但是未初始化完成的对象。</p><p>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p><p><img src="https://img-blog.csdnimg.cn/20210130220011857.png"></p><p>假设一个简单的循环依赖场景，A、B互相依赖。</p><p><img src="https://img-blog.csdnimg.cn/2021013022003161.png"></p><p><strong>A对象的创建过程：</strong></p><p>创建对象A，实例化的时候把A对象工厂放入三级缓存</p><p><img src="https://img-blog.csdnimg.cn/20210130220127563.png"></p><p>A注入属性时，发现依赖B，转而去实例化B</p><p>同样创建对象B，注入属性时发现依赖A，一次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。</p><p><img src="https://img-blog.csdnimg.cn/20210130220211597.png"></p><p>接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存</p><p>最后，一级缓存中保存着实例化、初始化都完成的A、B对象</p><p><img src="https://img-blog.csdnimg.cn/20210130220235425.png"></p><p>因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。</p><h2 id="为什么是三级缓存，二级缓存不行吗"><a href="#为什么是三级缓存，二级缓存不行吗" class="headerlink" title="为什么是三级缓存，二级缓存不行吗"></a>为什么是三级缓存，二级缓存不行吗</h2><p>不可以，主要是为了生成代理对象。</p><p>因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。</p><p>使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。</p><p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，BeanPostProcessor去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。</p><p><img src="https://img-blog.csdnimg.cn/20210130220318948.png"></p><h2 id="Spring启动过程"><a href="#Spring启动过程" class="headerlink" title="Spring启动过程"></a>Spring启动过程</h2><p>Spring启动过程是IOC容器的启动过程，本质是创建和初始化bean工厂(BeanFactory).BeanFactory是Spring IOC的核心，Spring使用beanFactory来实例化，配置和管理bean。</p><p>对于web程序，IOC容器启动过程即是建立上下文的过程，web容器会提供一个全局的servletContext上下文环境。</p><p>其启动过程主要包含三个类，ContextLoaderListener，ContextLoader和XmlWebApplicationContext。</p><p>在web.xml中提供ContextLoaderListener上下文监听器，在web容器启动时，会触发容器初始化事件，ContextLoaderListener会监听到这个事件，从而触发ContextInitialized方法完成上下文初始化，这个方法中调用父类ContextLoader的方法完成上下文初始化。</p><p>ContextLoader类中主要完成三件事：</p><p>1）创建WebApplicationContext；</p><p>2）加载对应的Spring配置文件中的bean；（refresh方法，完成bean的加载）</p><p>3）将WebApplicationContext放入servletContext中。</p><p>ContextLoaderListener监听器初始化完之后，开始初始化web.xml中配置的servlet，如DispatcherSevlet</p><p>ContextLoaderListener监听器监听的是servletContext，当web容器初始化后，servletContext发生变化时，会触发相应事件。</p><p><img src="F:/typora/tupian/1614608130932.png" alt="1614608130932"></p><h3 id="触发的事件"><a href="#触发的事件" class="headerlink" title="触发的事件"></a>触发的事件</h3><ul><li>ContextClosedEvent</li><li>ContextRefreshedEvent</li><li>ContextStartedEvent</li><li>ContextStoopedEvent</li><li>RequestHandleEvent</li></ul><p>Spring容器启动后会触发ContextRefreshedEvent事件，想要在某个类加载完毕是干某事，但用了Spring管理对象，这个类又引用了其他类，比较复杂，可以写一个类继承Spring的ApplicationListener监听并监控ContextRefreshedEvent事件。</p><h2 id="Spring中-Autowired注解与-Resource注解的区别"><a href="#Spring中-Autowired注解与-Resource注解的区别" class="headerlink" title="Spring中 @Autowired注解与@Resource注解的区别"></a>Spring中 @Autowired注解与@Resource注解的区别</h2><p><strong>相同点：</strong></p><p>@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。</p><p><strong>不同点：</strong></p><p>（1）<code>提供方</code>：@Autowired是由org.springframework.beans.factory.annotation.Autowired提供，换句话说就是由Spring提供；@Resource是由javax.annotation.Resource提供，即J2EE提供，需要JDK1.6及以上。</p><p>（2）<code>注入方式</code>：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；</p><p>（3）<code>属性</code>：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="2021/06/11/mybatis/"/>
      <url>2021/06/11/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念-使用方法向的问题"><a href="#1-概念-使用方法向的问题" class="headerlink" title="1.概念/使用方法向的问题"></a><strong>1.概念/使用方法向的问题</strong></h2><h3 id="1-1-什么是Mybatis"><a href="#1-1-什么是Mybatis" class="headerlink" title="1.1 什么是Mybatis?"></a><strong>1.1 什么是Mybatis?</strong></h3><p>（1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p><p>（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。</p><h3 id="1-2-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2 为什么说<strong>Mybatis是半ORM框架?与Hibernate有哪些不同?</strong></h3><p>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。Hibernate是个完整的ORM框架，而MyBatis只完成了关系-&gt;对象，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p><p>（1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p><p>（2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询（hql好难用哦）。</p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p><h3 id="1-3-Mybaits的优点"><a href="#1-3-Mybaits的优点" class="headerlink" title="1.3 Mybaits的优点?"></a><strong>1.3 Mybaits的优点?</strong></h3><p>（1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p><p>（4）能够与Spring很好的集成；</p><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><h3 id="1-4-MyBatis框架的缺点"><a href="#1-4-MyBatis框架的缺点" class="headerlink" title="1.4 MyBatis框架的缺点?"></a><strong>1.4 MyBatis框架的缺点?</strong></h3><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h3 id="1-5-和-的区别"><a href="#1-5-和-的区别" class="headerlink" title="1.5 #{}和${}的区别?"></a><strong>1.5 #{}和${}的区别?</strong></h3><p>（1）${}是properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换。</p><p>（2）#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，举例：</span><br><span class="line">order by $&#123;param&#125;，则解析成的sql为：</span><br><span class="line">order by    id</span><br><span class="line"> </span><br><span class="line">#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，举例：</span><br><span class="line">select * from table where name &#x3D; #&#123;param&#125;，则解析成的sql为：</span><br><span class="line">select * from table where name &#x3D;   &quot;id&quot;</span><br></pre></td></tr></table></figure><h3 id="1-6-怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 怎么解决<strong>实体类中的属性名和表中的字段名不一样的问题?</strong></h3><p>（1）通过在查询的sql语句中定义字段名的别名，使字段名的别名和实体类的属性名一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultetype&#x3D;&quot;com.en.entity.user&quot;&gt;</span><br><span class="line">       select user_id as id, user_no as no from test where user_id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>（2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type&#x3D;”me.gacl.domain.order” id&#x3D;”orderresultmap”&gt;</span><br><span class="line">     &lt;!–用id标签来映射主键字段–&gt;</span><br><span class="line">     &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;user_id&quot;&gt;</span><br><span class="line">     &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;</span><br><span class="line">     &lt;result property&#x3D;&quot;no&quot; column&#x3D;&quot;user_no&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;reslutMap&gt;</span><br></pre></td></tr></table></figure><h3 id="1-7-如何在mapper中传递多个参数"><a href="#1-7-如何在mapper中传递多个参数" class="headerlink" title="1.7 如何在mapper中传递多个参数?"></a><strong>1.7 如何在mapper中传递多个参数?</strong></h3><p>（1）使用 @param 注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);</span><br></pre></td></tr></table></figure><p>（2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap();</span><br><span class="line">map.put(&quot;start&quot;, start);</span><br><span class="line">map.put(&quot;end&quot;, end);</span><br><span class="line">sqlSession.selectList(&quot;student.selectUser&quot;, map);</span><br></pre></td></tr></table></figure><h3 id="1-8-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8 MyBatis的接口绑定有哪些实现方式？"></a><strong>1.8 MyBatis的接口绑定有哪些实现方式？</strong></h3><p>接口绑定有两种实现方式：</p><p>（1）一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)</span><br><span class="line">@Results(id &#x3D; &quot;distTypeMap&quot;,value &#x3D;&#123;@Result(id &#x3D;true,property&#x3D;&quot;id&quot;,column&#x3D;&quot;ID&quot;)</span><br><span class="line">            ,@Result(property&#x3D;&quot;code&quot;,column&#x3D;&quot;CODE&quot;)</span><br><span class="line">            ,@Result(property&#x3D;&quot;name&quot;,column&#x3D;&quot;NAME&quot;)</span><br><span class="line">            ,@Result(property &#x3D; &quot;dictDtos&quot; ,column &#x3D; &quot;ID&quot;,many &#x3D; @Many(select&#x3D;&quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,fetchType &#x3D; FetchType.EAGER))</span><br><span class="line">    &#125;)</span><br><span class="line">List&lt;SysDictTypeDto&gt; getAllDist();</span><br></pre></td></tr></table></figure><p>（2）另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;queryFileDisposeInfo&quot; parameterType&#x3D;&quot;FileDisposeVo&quot; resultMap&#x3D;&quot;illegalcollection-map&quot;&gt;</span><br><span class="line">   SELECT </span><br><span class="line">        BATCH_NUMBER,</span><br><span class="line">        FINISH_DATE,</span><br><span class="line">        FILE_NAME,</span><br><span class="line">        FILE_SIZE,</span><br><span class="line">        DATA_SIZE,</span><br><span class="line">        FILE_TYPE,</span><br><span class="line">        ORG_CODE</span><br><span class="line">   FROM </span><br><span class="line">        T_FILE_DISPOSE</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="1-9-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>（1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>（2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>（3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>（4）Mapper.xml文件中的namespace即是mapper接口的类路径;</p><h2 id="2-源码向的问题"><a href="#2-源码向的问题" class="headerlink" title="2.源码向的问题"></a><strong>2.源码向的问题</strong></h2><h3 id="2-1-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1 解释下MyBatis面向Mapper编程工作原理？"></a>2.1 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的动态代理，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p><h3 id="2-2-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了接口全限名+方法名的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id &#x3D; applyCurrentNamespace(id, false);</span><br><span class="line"></span><br><span class="line">public String applyCurrentNamespace(String base, boolean isReference) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F;返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)</span><br><span class="line">   return currentNamespace + &quot;.&quot; + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200920171405540.png"></p><h3 id="2-3-Mybatis动态sql执行原理"><a href="#2-3-Mybatis动态sql执行原理" class="headerlink" title="2.3 Mybatis动态sql执行原理?"></a><strong>2.3 Mybatis动态sql执行原理?</strong></h3><p>（1）初始化阶段：通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>（2）代理阶段：先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>（3）数据读写阶段：通过四种Executor调用四种Handler进行查询和封装数据；</p><h3 id="2-4-Mybatis的一级、二级缓存实现原理"><a href="#2-4-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4 Mybatis的一级、二级缓存实现原理?"></a><strong>2.4 Mybatis的一级、二级缓存实现原理?</strong></h3><p>（1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p><p><img src="https://img-blog.csdnimg.cn/2020092018550771.png"></p><p>（2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)级别。Mybatis默认不打开二级缓存，可以在config文件中xml<settings><setting name="cacheEnabled" value="true"/></settings>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p><p><img src="https://img-blog.csdnimg.cn/20200920190114946.png"></p><p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p><h3 id="2-5-Mybatis是如何进行分页的？"><a href="#2-5-Mybatis是如何进行分页的？" class="headerlink" title="2.5 Mybatis是如何进行分页的？"></a><strong>2.5 Mybatis是如何进行分页的？</strong></h3><p>（1）SQL分页(物理分页)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryStudentsBySql&quot; parameterType&#x3D;&quot;map&quot; resultMap&#x3D;&quot;studentmapper&quot;&gt; </span><br><span class="line">           select * from student limit #&#123;start&#125; , #&#123;end&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>（2）使用RowBounds实现分页(逻辑分页)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service:</span><br><span class="line">publicList queryRolesByPage(String roleName,intstart,int limit) &#123;</span><br><span class="line">     returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dao:</span><br><span class="line">     public List queryUsersByPage(String userName, RowBounds rowBounds);</span><br></pre></td></tr></table></figure><p>（3）使用分页插件PageHelper：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userMapper.queryByPage(userParam);</span><br><span class="line">        Json json &#x3D; new Json();</span><br><span class="line">        return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a><strong>2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png"></p><p><strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p><p><strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p><p><strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p><p><strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p><p><strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p><h3 id="2-7-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7 Mybatis中如何指定使用哪一种Executor执行器？"></a><strong>2.7 Mybatis中如何指定使用哪一种Executor执行器？</strong></h3><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p><p><img src="https://img-blog.csdnimg.cn/20200920183713811.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20200920183657317.png"></h3><h3 id="2-8-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a><strong>2.8 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png"></p><p><img src="https://img-blog.csdnimg.cn/2020092018294130.png"></p><p><img src="https://img-blog.csdnimg.cn/20200920183022252.png"></p><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p><h3 id="2-9-Mybatis中用到了哪些设计模式？"><a href="#2-9-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9 Mybatis中用到了哪些设计模式？"></a><strong>2.9 Mybatis中用到了哪些设计模式？</strong></h3><p>日志模块：代理模式、适配器模式</p><p>数据源模块：代理模式、工厂模式</p><p>缓存模块：装饰器模式</p><p>初始化阶段：建造者模式</p><p>代理阶段：策略模式</p><p>数据读写阶段：模板模式</p><p>插件化开发：责任链模式</p><h2 id="2-MyBatis源码结构"><a href="#2-MyBatis源码结构" class="headerlink" title="2.MyBatis源码结构"></a><strong>2.MyBatis源码结构</strong></h2><h3 id="2-1-源码包功能模块图"><a href="#2-1-源码包功能模块图" class="headerlink" title="2.1 源码包功能模块图"></a>2.1 源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png"></p><h3 id="2-2-各包详细功能解析"><a href="#2-2-各包详细功能解析" class="headerlink" title="2.2 各包详细功能解析"></a>2.2 各包详细功能解析</h3><p><strong>org.apache.ibatis.logging：</strong>包含所有mapper 接口中用到的注解</p><p><strong>org.apache.ibatis.binding：</strong>生成mapper 接口的动态代理并进行管理</p><p><strong>org.apache.ibatis.builder：</strong></p><ol><li> 包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</li><li> BaseBuilder 构建器基类</li><li> XMLConfigBuilder 解析configuration.xml配置文件</li><li> XMLMapperBuilder 解析Mapper.xml配置文件</li><li> XMLStatementBuilder 解析selectupdatedelete 标签</li><li> MapperAnnotationBuilder 注解式Mapper</li></ol><p><strong>org.apache.ibatis.cache：</strong></p><ol><li> 缓存功能实现、包含各种缓存装饰器</li><li> TransactionalCache 二级缓存功能实现</li></ol><p><strong>org.apache.ibatis.cursor：</strong>实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p><p><strong>org.apache.ibatis.datasource：</strong>数据源 包括jndi数据源、连接池功能</p><p><strong>org.apache.ibatis.executor：</strong></p><ol><li> 包含SQL语句执行器，核心功能包</li><li> 功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</li></ol><p><strong>org.apache.ibatis.exceptions：</strong>框架异常，常见异常：TooManyResultsException</p><p><strong>org.apache.ibatis.io：</strong>资源文件读取</p><p><strong>org.apache.ibatis.jdbc：</strong></p><ol><li> JDBC一些操作</li><li> SqlRunner SQL执行</li><li> ScriptRunner 脚本执行，可以执行建库语句</li></ol><p><strong>org.apache.ibatis.logging：</strong></p><ol><li> 日志功能，实现多种日志框架的对接</li><li> org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</li></ol><p><strong>org.apache.ibatis.mapping：</strong>配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p><p><strong>org.apache.ibatis.parsing：</strong></p><ol><li> 解析工具包</li><li> GenericTokenParser：解析#{} ${} 这种占位符</li><li> XPathParser：XPath形式解析XML</li><li> PropertyParser: properties解析器</li></ol><p><strong>org.apache.ibatis.scripting：</strong>动态SQL语言实现，配置文件中<if> <where> <set> <foreach> <choose> 功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p><p><strong>org.apache.ibatis.session：</strong></p><ol><li> 主要实现SqlSession功能，非常核心包</li><li> 官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</li></ol><p><strong>org.apache.ibatis.transaction：</strong>事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p><p><strong>org.apache.ibatis.type：</strong>类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p><h2 id="啃下MyBatis源码-MyBatis核心流程三大阶段之初始化阶段"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之初始化阶段" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之初始化阶段"></a><strong>啃下MyBatis源码 - MyBatis核心流程三大阶段之初始化阶段</strong></h2><p><strong>1.加载配置文件</strong></p><p><strong>2.解析配置文件、将配置文件中的信息装载到Configuration中</strong></p><p><strong>3.根据Configuration创建SqlSessionFactory并返回</strong></p><p><strong>————————————————————————————————————————–</strong></p><p>前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级。</p><p>MyBatis初始化流程大致有三步：</p><ol><li> 加载配置文件</li><li> 解析配置文件、将配置文件中的信息装载到Configuration中。</li><li> 根据Configuration创建SqlSessionFactory并返回。</li></ol><h3 id="1-加载配置文件"><a href="#1-加载配置文件" class="headerlink" title="1.加载配置文件"></a><strong>1.加载配置文件</strong></h3><p>下面我们来看一段经典查询操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String resouce &#x3D; &quot;config&#x2F;mybatis&#x2F;mybatis-config.xml&quot;;</span><br><span class="line">InputStream is &#x3D; Resources.getResourceAsStream(resouce);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">user &#x3D; session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);</span><br></pre></td></tr></table></figure><p>以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p><h3 id="2-解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#2-解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="2.解析配置文件、将配置文件中的信息装载到Configuration中"></a><strong>2.解析配置文件、将配置文件中的信息装载到Configuration中</strong></h3><p>让我们来看一下梦开始的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(is);</span><br></pre></td></tr></table></figure><p>跟进build()方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;创建XMLConfigBuilder对象解析XML配置</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      &#x2F;&#x2F;将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进parse()方法，我们可以看到parser.evalNode(“/configuration”)，evalNode为xml结点解析器，可以解析指定参数结点的信息，再看这个”/configuration”有点眼熟丫，这不就是mybatis.xml的根节点嘛：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">    ...</span><br><span class="line">    parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">    return configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p><p><strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p><p><strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p><p><strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p><p><strong>三大金刚图解：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200915222654319.png"></p><p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png"></p><p>Configuration类的源码实在太多，童鞋们先对这个类有个大致印象，了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p><p><strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br><strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br><strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br><strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p><p>接上面XMLConfigBuilder开始解析”/configuration”节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p><p><img src="https://img-blog.csdnimg.cn/20200915223612191.png"></p><p>在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLMapperBuilder mapperParser &#x3D; new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">mapperParser.parse();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      String namespace &#x3D; context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">      ...</span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">      cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line">      parameterMapElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;parameterMap&quot;));</span><br><span class="line">      resultMapElements(context.evalNodes(&quot;&#x2F;mapper&#x2F;resultMap&quot;));</span><br><span class="line">      sqlElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;sql&quot;));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一一对应官网提供的节点信息进行解析</p><p><img src="https://img-blog.csdnimg.cn/20200915224121930.png"></p><p>下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">      final XMLStatementBuilder statementParser &#x3D; new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      try &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p><h3 id="3-根据Configuration创建SqlSessionFactory并返回"><a href="#3-根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="3.根据Configuration创建SqlSessionFactory并返回"></a><strong>3.根据Configuration创建SqlSessionFactory并返回</strong></h3><p>第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionFactoryBuilder &#123;</span><br><span class="line">   ...</span><br><span class="line">   public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">      return new DefaultSqlSessionFactory(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此工厂内封装了Configuration对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;</span><br><span class="line">  private final Configuration configuration;</span><br><span class="line">  public DefaultSqlSessionFactory(Configuration configuration) &#123;</span><br><span class="line">    this.configuration &#x3D; configuration;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化阶段图解：</p><p><img src="https://img-blog.csdnimg.cn/20200915225840294.png"></p><p>至此，MyBatis初始化阶段完成。</p><h2 id="啃下MyBatis源码-MyBatis核心流程三大阶段之代理阶段（binding模块分析）"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之代理阶段（binding模块分析）" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之代理阶段（binding模块分析）"></a><strong>啃下MyBatis源码 - MyBatis核心流程三大阶段之代理阶段（binding模块分析）</strong></h2><p><strong>1.MyBatis是如何做到面向Mapper接口编程？</strong></p><p><strong>2.代理阶段流程梳理</strong></p><p><strong>————————————————————————————————————————–</strong></p><h3 id="1-MyBatis是如何做到面向Mapper接口编程？"><a href="#1-MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="1.MyBatis是如何做到面向Mapper接口编程？"></a><strong>1.MyBatis是如何做到面向Mapper接口编程？</strong></h3><p>只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">User uer &#x3D; userMapper.selectByPrimarKey(1);</span><br></pre></td></tr></table></figure><p>MyBatis动态代理后执行的为下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">User uer &#x3D; sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);</span><br></pre></td></tr></table></figure><p>我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p><p><strong>1、找到Session中对应的方法执行</strong></p><p><strong>2、找到命名空间和方法名</strong></p><p><strong>3、传递参数</strong></p><p>这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p><p><img src="https://img-blog.csdnimg.cn/20200916211402947.png"></p><p><strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MapperRegistry &#123;</span><br><span class="line">   private final Configuration config;</span><br><span class="line">   &#x2F;&#x2F;mapper接口和对应的代理对象工厂之间的关系</span><br><span class="line">   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;key为mapper接口中的某个方法的method对象，value为对应的MapperMethod</span><br><span class="line">  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；<img src="https://img-blog.csdnimg.cn/20200916214700706.png"></p><p>接着跟进cachedInvoker(method).invoke(proxy, method, args, sqlSession)方法</p><p><img src="https://img-blog.csdnimg.cn/20200916213826490.png"></p><p>我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p><p><img src="https://img-blog.csdnimg.cn/20200916214037965.png"></p><p>我们可以看到在PlainMethodInvoker类中封装了一个MapperMethod对象，然后在invoke方法中的execute方法中最终通过增删改查的类型来调用增强的方法，当然调用前先用参数解析器过滤一下参数。</p><p><img src="https://img-blog.csdnimg.cn/20200916214239389.png"></p><p>那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p><p><img src="https://img-blog.csdnimg.cn/20200916214959863.png"></p><p><img src="https://img-blog.csdnimg.cn/20200916215029787.png"><br>通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p><p><img src="https://img-blog.csdnimg.cn/20200916215442588.png"></p><p><img src="https://img-blog.csdnimg.cn/20200916215556263.png"></p><p><img src="https://img-blog.csdnimg.cn/20200916215523383.png"></p><h3 id="2-代理阶段流程梳理"><a href="#2-代理阶段流程梳理" class="headerlink" title="2.代理阶段流程梳理"></a><strong>2.代理阶段流程梳理</strong></h3><p>1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p><p>2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p><p>3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p><h3 id="啃下MyBatis源码-MyBatis核心流程三大阶段之数据读写阶段"><a href="#啃下MyBatis源码-MyBatis核心流程三大阶段之数据读写阶段" class="headerlink" title="啃下MyBatis源码 - MyBatis核心流程三大阶段之数据读写阶段"></a>啃下MyBatis源码 - MyBatis核心流程三大阶段之数据读写阶段</h3><p><strong>1.MyBatis是怎样的封装jdbc操作的</strong></p><p><strong>2.sqlSession查询流程图和Executor内部调用流程图</strong></p><p><strong>————————————————————————————————————————–</strong></p><h3 id="1-MyBatis是怎样的封装jdbc操作的"><a href="#1-MyBatis是怎样的封装jdbc操作的" class="headerlink" title="1.MyBatis是怎样的封装jdbc操作的"></a><strong>1.MyBatis是怎样的封装jdbc操作的</strong></h3><p>我们先来回忆一下jdbc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.加载驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     </span><br><span class="line">&#x2F;&#x2F;2.获取连接conn</span><br><span class="line">Connection con&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;, &quot;root&quot;, &quot;123&quot;);</span><br><span class="line">&#x2F;&#x2F;3.创建查询接口</span><br><span class="line">Statement sta&#x3D; con.createStatement();</span><br><span class="line">&#x2F;&#x2F;4.执行SQL，返回结果集</span><br><span class="line">ResultSet rs&#x3D; sta.executeQuery(&quot;SELECT * FROM &#96;user&#96;&quot;);</span><br><span class="line">&#x2F;&#x2F;5.对结果集数据进行操作</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setUserName(String.valueOf(rs.getObject(1)));</span><br></pre></td></tr></table></figure><p>其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p><p><img src="https://img-blog.csdnimg.cn/20200917203050838.png"></p><p>可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png"></p><p><strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p><p><strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p><p><strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p><p><strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p><p><strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p><p>一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917205236272.png"></p><p>可以看到只有BaseExecutor和CachingExecutor两个类重写了query方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<cache>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p><p><img src="https://img-blog.csdnimg.cn/20200917205454850.png"></p><p>好的我们继续跟进BaseExecutor的query()方法:</p><p><img src="https://img-blog.csdnimg.cn/20200917210415293.png"></p><p><img src="https://img-blog.csdnimg.cn/20200917210606702.png"></p><p>可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p><p><img src="https://img-blog.csdnimg.cn/20200917210831277.png"></p><p>我们跟进默认实现SimpleExecutor的doQuery方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917211035123.png"></p><p>这段代码有两点值得我们注意，一个是prepareStatement(handler, ms.getStatementLog());这个方法，我们跟进去会发现：</p><p><img src="https://img-blog.csdnimg.cn/20200917211124589.png"></p><p><strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p><p><img src="https://img-blog.csdnimg.cn/20200919104808424.png"></p><p><strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p><p><strong>CallableStatementHandler：</strong>调用存储过程</p><p><strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p><p><strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p><p><strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p><p>RoutingStatementHandler类源码，很清晰的静态代理</p><p><img src="https://img-blog.csdnimg.cn/20200917211725203.png"></p><p>接上文调用SimpleStatementHandler的query方法:</p><p><img src="https://img-blog.csdnimg.cn/20200917211854628.png"></p><p><strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p><p><img src="https://img-blog.csdnimg.cn/20200919110111271.png"></p><p>处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p><ol><li><p> 创建multipleResults集合，保存最终返回的结果。</p></li><li><p> 取出第一个结果集</p></li><li><p> 获取对应的resultMap</p></li><li><p> 根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</p></li><li><p> resultset.close()关闭结果集，将multipleResults集合返回</p></li></ol><h3 id="2-sqlSession查询流程图和Executor内部调用流程图"><a href="#2-sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="2.sqlSession查询流程图和Executor内部调用流程图"></a><strong>2.sqlSession查询流程图和Executor内部调用流程图</strong></h3><p><strong>sqlSession查询流程图：</strong></p><p><img src="https://img-blog.csdnimg.cn/2020091911381497.png"></p><p><strong>Executor内部调用流程图：</strong></p><p><img src="https://img-blog.csdnimg.cn/2020091911204922.png"></p><p>至此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate</title>
      <link href="2021/06/11/hibernate/"/>
      <url>2021/06/11/hibernate/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate是如何延迟加载-懒加载"><a href="#Hibernate是如何延迟加载-懒加载" class="headerlink" title="Hibernate是如何延迟加载(懒加载)?"></a>Hibernate是如何延迟加载(懒加载)?</h2><p>通过设置属性<code>lazy</code>进行设置是否需要懒加载</p><p>当Hibernate在查询数据的时候，数据并没有存在与内存中，<strong>当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载</strong>，他节省了服务器的内存开销，从而提高了服务器的性能。</p><h2 id="hibernate的三种状态之间如何转换"><a href="#hibernate的三种状态之间如何转换" class="headerlink" title="hibernate的三种状态之间如何转换"></a>hibernate的三种状态之间如何转换</h2><p>Hibernate中对象的状态：</p><ul><li><strong>临时/瞬时状态</strong></li><li><strong>持久化状态</strong></li><li><strong>游离状态</strong></li></ul><h3 id="临时-瞬时状态"><a href="#临时-瞬时状态" class="headerlink" title="临时/瞬时状态"></a>临时/瞬时状态</h3><p>当我们<strong>直接new出来的对象就是临时/瞬时状态的</strong>..</p><ul><li><strong>该对象还没有被持久化【没有保存在数据库中】</strong></li><li><strong>不受Session的管理</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20210203001942107.png" alt="在这里插入图片描述"></p><h3 id="持久化状态"><a href="#持久化状态" class="headerlink" title="持久化状态"></a>持久化状态</h3><p><strong>当保存在数据库中的对象就是持久化状态了</strong></p><ul><li><strong>当调用session的save/saveOrUpdate/get/load/list等方法的时候，对象就是持久化状态</strong></li><li><strong>在数据库有对应的数据</strong></li><li><strong>受Session的管理</strong></li><li><strong>当对对象属性进行更改的时候，会反映到数据库中!</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20210203002029387.png" alt="在这里插入图片描述"></p><p>我们来测试一下：<strong>当对对象属性进行更改的时候，会反映到数据库中!</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.save(idCard);</span><br><span class="line">idCard.setIdCardName(&quot;我是测试持久化对象&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210203002101522.png" alt="在这里插入图片描述"></p><h3 id="游离状态"><a href="#游离状态" class="headerlink" title="游离状态"></a>游离状态</h3><p><strong>当Session关闭了以后，持久化的对象就变成了游离状态了…</strong></p><ul><li><strong>不处于session的管理</strong></li><li><strong>数据库中有对应的记录</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20210203002142521.png"></p><p>有了上面的基础，我们就很容易说出它们之间的转换了</p><ul><li><strong>new出来的对象是瞬时状态-&gt;保存到数据库中(受Session管理)就是持久化状态-&gt;将session close掉就是游离状态</strong></li></ul><h2 id="比较hibernate的三种检索策略优缺点"><a href="#比较hibernate的三种检索策略优缺点" class="headerlink" title="比较hibernate的三种检索策略优缺点"></a>比较hibernate的三种检索策略优缺点</h2><blockquote><p>比较hibernate的三种检索策略优缺点</p></blockquote><p><strong>立即检索：</strong></p><ul><li>优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；</li><li>缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；</li><li>立即检索:<code>lazy=false</code>；</li></ul><p><strong>延迟检索：</strong></p><ul><li>优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；</li><li>缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；</li><li>延迟加载：<code>lazy=true</code>；</li></ul><p><strong>迫切左外连接检索：</strong></p><ul><li>优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；</li><li>缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；</li><li>预先抓取： <code>fetch=“join”</code>；</li></ul><h2 id="hibernate都支持哪些缓存策略"><a href="#hibernate都支持哪些缓存策略" class="headerlink" title="hibernate都支持哪些缓存策略"></a>hibernate都支持哪些缓存策略</h2><blockquote><p>hibernate都支持哪些缓存策略</p></blockquote><p>usage的属性有4种：</p><ul><li>放入二级缓存的对象，只读(Read-only);</li><li>非严格的读写(Nonstrict read/write)</li><li>读写； 放入二级缓存的对象可以读、写(Read/write)；</li><li>基于事务的策略(Transactional)</li></ul><h2 id="hibernate里面的sorted-collection-和ordered-collection有什么区别"><a href="#hibernate里面的sorted-collection-和ordered-collection有什么区别" class="headerlink" title="hibernate里面的sorted collection 和ordered collection有什么区别"></a>hibernate里面的sorted collection 和ordered collection有什么区别</h2><blockquote><p>hibernate里面的sorted collection 和ordered collection有什么区别</p></blockquote><p>sorted collection</p><ul><li>是在<strong>内存中通过Java比较器</strong>进行排序的</li></ul><p>ordered collection</p><ul><li>是在<strong>数据库中通过order by</strong>进行排序的</li></ul><p>对于比较大的数据集，<strong>为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。</strong></p><h2 id="说下Hibernate的缓存机制"><a href="#说下Hibernate的缓存机制" class="headerlink" title="说下Hibernate的缓存机制"></a>说下Hibernate的缓存机制</h2><p><strong>一级缓存：</strong></p><ul><li>Hibenate中一级缓存，也叫做session的缓存，<strong>它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！</strong></li><li><strong>只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！</strong></li><li>Session的缓存由hibernate维护，<strong>用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作</strong>。</li></ul><p><strong>二级缓存：</strong></p><ul><li><strong>二级缓存是基于应用程序的缓存，所有的Session都可以使用</strong></li><li>Hibernate提供的二级缓存有默认的实现，且是一种<strong>可插配的缓存框架</strong>！如果用户想用二级缓存，<strong>只需要在hibernate.cfg.xml中配置即可</strong>； 不想用，直接移除，不影响代码。</li><li>如果用户觉得hibernate提供的框架框架不好用，<strong>自己可以换其他的缓存框架或自己实现缓存框架都可以</strong>。</li><li>Hibernate二级缓存：<strong>存储的是常用的类</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20210203001756365.png" alt="在这里插入图片描述"></p><h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a>如何优化Hibernate？</h2><blockquote><p>如何优化Hibernate？</p></blockquote><ul><li>Ø 数据库设计调整</li><li>Ø HQL优化</li><li>Ø API的正确使用(如根据不同的业务类型选用不同的集合及查询API)</li><li>Ø 主配置参数(日志，查询缓存，fetch_size, batch_size等)</li><li>Ø 映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化)</li><li>Ø 一级缓存的管理</li><li>Ø 针对二级缓存，还有许多特有的策略</li></ul><h2 id="谈谈Hibernate中inverse的作用"><a href="#谈谈Hibernate中inverse的作用" class="headerlink" title="谈谈Hibernate中inverse的作用"></a>谈谈Hibernate中inverse的作用</h2><p><strong>inverse属性默认是false</strong>，就是说关系的两端都来维护关系。</p><ul><li>比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)</li><li>如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。</li></ul><p>如果表之间的关联关系是“一对多”的话，那么inverse只能在“一”的一方来配置！</p><h2 id="JDBC-hibernate-和-ibatis-的区别"><a href="#JDBC-hibernate-和-ibatis-的区别" class="headerlink" title="JDBC hibernate 和 ibatis 的区别"></a>JDBC hibernate 和 ibatis 的区别</h2><h3 id="jdbc-手动"><a href="#jdbc-手动" class="headerlink" title="jdbc:手动"></a>jdbc:手动</h3><ul><li>手动写sql</li><li>delete、insert、update要将对象的值一个一个取出传到sql中,不能直接传入一个对象。</li><li>select:返回的是一个resultset，要从ResultSet中一行一行、一个字段一个字段的取出，然后封装到一个对象中，不直接返回一个对象。</li></ul><h3 id="ibatis的特点-半自动化"><a href="#ibatis的特点-半自动化" class="headerlink" title="ibatis的特点:半自动化"></a>ibatis的特点:半自动化</h3><ul><li>sql要手动写</li><li>delete、insert、update:直接传入一个对象</li><li>select:直接返回一个对象</li></ul><h3 id="hibernate-全自动"><a href="#hibernate-全自动" class="headerlink" title="hibernate:全自动"></a>hibernate:全自动</h3><ul><li>不写sql,自动封装</li><li>delete、insert、update:直接传入一个对象</li><li>select:直接返回一个对象</li></ul><h2 id="在数据库中条件查询速度很慢的时候-如何优化"><a href="#在数据库中条件查询速度很慢的时候-如何优化" class="headerlink" title="在数据库中条件查询速度很慢的时候,如何优化?"></a>在数据库中条件查询速度很慢的时候,如何优化?</h2><ol><li> 建索引</li><li> 减少表之间的关联</li><li> 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面</li><li> 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li></ol><h2 id="什么是SessionFactory-她是线程安全么"><a href="#什么是SessionFactory-她是线程安全么" class="headerlink" title="什么是SessionFactory,她是线程安全么"></a>什么是SessionFactory,她是线程安全么</h2><p><strong>SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问</strong>。一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存.</p><h2 id="get和load区别"><a href="#get和load区别" class="headerlink" title="get和load区别"></a>get和load区别</h2><ul><li><p><strong>get()立即查询</strong></p></li><li><p><strong>load()懒加载</strong></p></li><li><p>1）get如果没有找到会返回null， load如果没有找到会抛出异常。</p></li><li><p>2）get会先查一级缓存， 再查二级缓存，然后查数据库；load会先查一级缓存，如果没有找到，就创建代理对象， 等需要的时候去查询二级缓存和数据库。</p></li></ul><h2 id="merge的含义："><a href="#merge的含义：" class="headerlink" title="merge的含义："></a>merge的含义：</h2><blockquote><p>merge的含义：</p></blockquote><ul><li>如果session中<strong>存在相同持久化标识(identifier)的实例</strong>，用用户给出的对象的状态<strong>覆盖旧有的持久实例</strong></li><li>如果session<strong>没有相应的持久实例</strong>，则尝试从数据库中加载，或创建新的持久化实例,最后返回该持久实例</li><li><strong>用户给出的这个对象没有被关联到session上，它依旧是脱管的</strong></li></ul><h2 id="persist和save的区别"><a href="#persist和save的区别" class="headerlink" title="persist和save的区别"></a>persist和save的区别</h2><blockquote><p>persist和save的区别</p></blockquote><ul><li><strong>persist不保证立即执行，可能要等到flush；</strong></li><li><strong>persist不更新缓存；</strong></li><li>save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会<strong>立即执行Sql insert</strong></li><li>使用 save() 方法保存持久化对象时，<strong>该方法返回该持久化对象的标识属性值(即对应记录的主键值)；</strong></li><li>使用 persist() 方法来保存持久化对象时，<strong>该方法没有任何返回值</strong>。</li></ul><h2 id="主键生成-策略有哪些"><a href="#主键生成-策略有哪些" class="headerlink" title="主键生成 策略有哪些"></a>主键生成 策略有哪些</h2><blockquote><p>主键生成 策略有哪些</p></blockquote><p><strong>主键的自动生成策略</strong></p><ul><li>identity 自增长(mysql,db2)</li><li>sequence 自增长(序列)， oracle中自增长是以序列方法实现**</li><li><strong>native 自增长【会根据底层数据库自增长的方式选择identity或sequence】</strong><ul><li><strong>如果是mysql数据库, 采用的自增长方式是identity</strong></li><li><strong>如果是oracle数据库， 使用sequence序列的方式实现自增长</strong></li></ul></li><li>increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)</li></ul><p>指定主键生成策略为<strong>手动指定主键的值</strong></p><ul><li><strong>assigned</strong></li></ul><p>指定主键生成策略为<strong>UUID生成的值</strong></p><ul><li><strong>uuid</strong></li></ul><p><strong>foreign(外键的方式)</strong></p><h2 id="简述hibernate中getCurrentSession和openSession区别"><a href="#简述hibernate中getCurrentSession和openSession区别" class="headerlink" title="简述hibernate中getCurrentSession和openSession区别"></a>简述hibernate中getCurrentSession和openSession区别</h2><ul><li><p>1、getCurrentSession会绑定当前线程，而openSession不会，因为我们把hibernate交给我们的spring来管理之后，我们是有事务配置，这个有事务的线程就会绑定当前的工厂里面的每一个session，而openSession是创建一个新session。</p></li><li><p>2、<strong>getCurrentSession事务是有spring来控制的</strong>，而openSession需要我们手动开启和手动提交事务，</p></li><li><p>3、<strong>getCurrentSession是不需要我们手动关闭的</strong>，因为工厂会自己管理，而openSession需要我们手动关闭。</p></li><li><p>4、而<strong>getCurrentSession需要我们手动设置绑定事务的机制</strong>，有三种设置方式，jdbc本地的Thread、JTA、第三种是spring提供的事务管理机制org.springframework.orm.hibernate4.SpringSessionContext，而且srping默认使用该种事务管理机制</p><h2 id="Hibernate中的命名SQL查询指的是什么"><a href="#Hibernate中的命名SQL查询指的是什么" class="headerlink" title="Hibernate中的命名SQL查询指的是什么?"></a>Hibernate中的命名SQL查询指的是什么?</h2></li><li><p>命名查询指的是用<code>&lt;sql-query&gt;</code>标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。</p></li><li><p>Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。</p></li></ul><h2 id="为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？"><a href="#为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？" class="headerlink" title="为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？"></a>为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？</h2><p>每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为<strong>Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例</strong>。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。</p><h2 id="可不可以将Hibernate的实体类定义为final类"><a href="#可不可以将Hibernate的实体类定义为final类" class="headerlink" title="可不可以将Hibernate的实体类定义为final类?"></a>可不可以将Hibernate的实体类定义为final类?</h2><p>你<strong>可以</strong>将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，<strong>因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，</strong> 如此一来就限制了使用可以提升性能的手段。</p><h3 id="Hibernate-的检索方式有哪些"><a href="#Hibernate-的检索方式有哪些" class="headerlink" title="Hibernate 的检索方式有哪些 ?"></a>Hibernate 的检索方式有哪些 ?</h3><p>① 导航对象图检索 （根据已经加载的对象，导航到其他对象。）<br>② OID检索  （按照对象的OID来检索对象。）<br>③ HQL检索  （使用面向对象的HQL查询语言。）<br>④ QBC检索  （使用QBC(Qurey By Criteria) API来检索对象。）<br>⑤ 本地SQL检索  （使用本地数据库的SQL查询语句。）</p><h3 id="Session的清理和清空有什么区别？"><a href="#Session的清理和清空有什么区别？" class="headerlink" title="Session的清理和清空有什么区别？"></a>Session的清理和清空有什么区别？</h3><p>清理缓存调用的是 session.flush() 方法. 而清空调用的是 session.clear() 方法.<br>Session 清理缓存是指按照缓存中对象的状态的变化来同步更新数据库，但不清空缓存；清空是把Session 的缓存置空, 但不同步更新数据库；  </p><h3 id="hibernate-优缺点"><a href="#hibernate-优缺点" class="headerlink" title="hibernate 优缺点"></a>hibernate 优缺点</h3><p>①. 优点:  </p><blockquote><p>对 JDBC 访问数据库的代码做了封装，简化了数据访问层繁琐的重复性代码<br>映射的灵活性, 它支持各种关系数据库, 从一对一到多对多的各种复杂关系.<br>非侵入性、移植性会好<br>缓存机制: 提供一级缓存和二级缓存  </p></blockquote><p><strong>②. 缺点:</strong>  </p><blockquote><p>无法对 SQL 进行优化<br>框架中使用 ORM原则, 导致配置过于复杂<br>执行效率和原生的JDBC 相比偏差: 特别是在批量数据处理的时候<br>不支持批量修改、删除  </p></blockquote><h3 id="Hibernate-的OpenSessionView-问题"><a href="#Hibernate-的OpenSessionView-问题" class="headerlink" title="Hibernate 的OpenSessionView 问题"></a>Hibernate 的OpenSessionView 问题</h3><p>①. 用于解决懒加载异常, 主要功能就是把 Hibernate Session 和一个请求的线程绑定在一起, 直到页面完整输出, 这样就可以保证页面读取数据的时候 Session 一直是开启的状态, 如果去获取延迟加载对象也不会报错。<br>②. 问题: 如果在业务处理阶段大批量处理数据, 有可能导致一级缓存里的对象占用内存过多导致内存溢出, 另外一个是连接问题: Session 和数据库 Connection 是绑定在一起的, 如果业务处理缓慢也会导致数据库连接得不到及时的释放, 造成连接池连接不够. 所以在并发量较大的项目中不建议使用此种方式, 可以考虑使用迫切左外连接 (LEFT OUTER JOIN FETCH) 或手工对关联的对象进行初始化.<br>③. 配置 Filter 的时候要放在 Struts2 过滤器的前面, 因为它要页面完全显示完后再退出.  </p><p>8.Hibernate 中getCurrentSession() 和 openSession() 的区别 ?<br>①. getCurrentSession() 它会先查看当前线程中是否绑定了 Session, 如果有则直接返回, 如果没有再创建. 而openSession() 则是直接 new 一个新的 Session 并返回。<br>②. 使用ThreadLocal 来实现线程 Session 的隔离。<br>③. getCurrentSession() 在事务提交的时候会自动关闭 Session, 而 openSession() 需要手动关闭.  </p><h3 id="说说-Hibernate-的缓存："><a href="#说说-Hibernate-的缓存：" class="headerlink" title="说说 Hibernate 的缓存："></a>说说 Hibernate 的缓存：</h3><p>Hibernate缓存包括两大类：Hibernate一级缓存和Hibernate二级缓存：  </p><p>1）. Hibernate一级缓存又称为“Session的缓存”，它是内置的，不能被卸载。由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。在第一级缓存中，持久化类的每个实例都具有唯一的OID。  </p><p>2）.Hibernate二级缓存又称为“SessionFactory的缓存”，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory不会启用这个插件。<br>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存删除、更新、增加数据的时候，同时更新缓存。</p><h2 id="hibernate工作原理："><a href="#hibernate工作原理：" class="headerlink" title="hibernate工作原理："></a><strong>hibernate工作原理：</strong></h2><p>1.通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件<br>2.由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息<br>3.通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory<br>4.Session session = sf.openSession();//打开Sesssion<br>5.Transaction tx = session.beginTransaction();//创建并启动事务Transation<br>6.persistent operate操作数据，持久化操作<br>7.tx.commit();//提交事务<br>8.关闭Session<br>9.关闭SesstionFactory</p><h2 id="为什么要用hibernate："><a href="#为什么要用hibernate：" class="headerlink" title="为什么要用hibernate："></a>为什么要用hibernate：</h2><ol><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。  </li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作  </li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。  </li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ol><h2 id="Hibernate是如何延迟加载-get与load的区别"><a href="#Hibernate是如何延迟加载-get与load的区别" class="headerlink" title="Hibernate是如何延迟加载?get与load的区别"></a>Hibernate是如何延迟加载?get与load的区别</h2><ol><li><p>对于Hibernate get方法，Hibernate会确认一下该id对应的数据是否存在，首先在session缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据 库中没有就返回null。这个相对比较简单，也没有太大的争议。主要要说明的一点就是在这个版本(bibernate3.2以上)中get方法也会查找二级缓存！</p></li><li><p>Hibernate load方法加载实体对象的时候，根据映射文件上类级别的lazy属性的配置(默认为true)，分情况讨论：</p></li></ol><p>(1)若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。</p><p>(2)若为false,就跟Hibernateget方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException。</p><p>这里get和load有两个重要区别:</p><p>如果未能发现符合条件的记录，Hibernate get方法返回null，而load方法会抛出一个ObjectNotFoundException。</p><p>load方法可返回没有加载实体数据的代 理类实例，而get方法永远返回有实体数据的对象。</p><p>总之对于get和load的根本区别，hibernate对于 load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方 法，hibernate一定要获取到真实的数据，否则返回null。</p><h2 id="Hibernate中怎样实现类之间的关系-如：一对多、多对多的关系"><a href="#Hibernate中怎样实现类之间的关系-如：一对多、多对多的关系" class="headerlink" title="Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)"></a>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)</h2><p>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many。</p><h2 id="Hibernate的缓存机制："><a href="#Hibernate的缓存机制：" class="headerlink" title="Hibernate的缓存机制："></a>Hibernate的缓存机制：</h2><p><strong>Hibernate缓存的作用：</strong><br>    Hibernate是一个持久层框架，经常访问物理数据库，为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据</p><p><strong>Hibernate缓存分类：</strong></p><p>  Hibernate缓存包括两大类：Hibernate一级缓存和Hibernate二级缓存<br>Hibernate一级缓存又称为“Session的缓存”，它是内置的，意思就是说，只要你使用hibernate就必须使用session缓存。由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。在第一级缓存中，持久化类的每个实例都具有唯一的OID。 </p><p>Hibernate二级缓存又称为“SessionFactory的缓存”，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory不会启用这个插件。</p><p><strong>什么样的数据适合存放到第二级缓存中？</strong> 　</p><p>1 很少被修改的数据 　　<br>2 不是很重要的数据，允许出现偶尔并发的数据 　　<br>3 不会被并发访问的数据 　　<br>4 常量数据 　　</p><p><strong>不适合存放到第二级缓存的数据？</strong> 　　<br>1经常被修改的数据 　　<br>2 .绝对不允许出现并发访问的数据，如财务数据，绝对不允许出现并发 　　<br>3 与其他应用共享的数据。 </p><p><strong>Hibernate查找对象如何应用缓存？</strong><br>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存<br>删除、更新、增加数据的时候，同时更新缓存</p><p>Hibernate 的检索方式有哪些<br>无论何时，我们在管理Hibernate缓存（Managing the caches）时，当你给save()、update()或saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。 </p><p>当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。 </p><h2 id="如何优化Hibernate？-1"><a href="#如何优化Hibernate？-1" class="headerlink" title="如何优化Hibernate？"></a>如何优化Hibernate？</h2><p>1.使用双向一对多关联，不使用单向一对多<br>2.灵活使用单向一对多关联<br>3.不用一对一，用多对一取代<br>4.配置对象缓存，不使用集合缓存<br>5.一对多集合使用Bag,多对多集合使用Set  </p><ol start="6"><li><p>继承类使用显式多态</p></li><li><p>表字段要少，表关联不要怕多，有二级缓存撑腰</p></li></ol><h3 id="什么是Hibernate的并发机制？怎么去处理并发问题？"><a href="#什么是Hibernate的并发机制？怎么去处理并发问题？" class="headerlink" title="什么是Hibernate的并发机制？怎么去处理并发问题？"></a>什么是Hibernate的并发机制？怎么去处理并发问题？</h3><p>Hibernate并发机制：</p><p>a、Hibernate的Session对象是非线程安全的,对于单个请求,单个会话,单个的工作单元(即单个事务,单个线程),它通常只使用一次, 然后就丢弃。</p><p>如果一个Session 实例允许共享的话，那些支持并发运行的,例如Http request,session beans将会导致出现资源争用。</p><p>如果在Http Session中有hibernate的Session的话,就可能会出现同步访问Http Session。只要用户足够快的点击浏览器的“刷新”, 就会导致两个并发运行的线程使用同一个Session。</p><p>b、多个事务并发访问同一块资源,可能会引发第一类丢失更新，脏读，幻读，不可重复读，第二类丢失更新一系列的问题。</p><p><strong>解决方案：设置事务隔离级别。</strong><br>Serializable：串行化。隔离级别最高<br>Repeatable Read：可重复读<br>Read Committed：已提交数据读<br>Read Uncommitted：未提交数据读。隔离级别最差  </p><p><strong>设置锁：乐观锁和悲观锁</strong>。  </p><p><strong>乐观锁</strong>：使用版本号或时间戳来检测更新丢失,在的映射中设置 optimistic-lock=”all”可以在没有版本或者时间戳属性映射的情况下实现 版本检查，此时Hibernate将比较一行记录的每个字段的状态 行级悲观锁：Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！只要为JDBC连接指定一下隔 离级别，然后让数据库去搞定一切就够了。类LockMode 定义了Hibernate所需的不同的锁定级别：LockMode.UPGRADE,LockMode.UPGRADE_NOWAIT,LockMode.READ;</p><h3 id="update和saveOrUpdate的区别？"><a href="#update和saveOrUpdate的区别？" class="headerlink" title="update和saveOrUpdate的区别？"></a>update和saveOrUpdate的区别？</h3><p>update()和saveOrUpdate()是用来对跨Session的PO进行状态管理的。<br>update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。<br>saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。</p><h3 id="比较hibernate的三种检索策略优缺点-1"><a href="#比较hibernate的三种检索策略优缺点-1" class="headerlink" title="比较hibernate的三种检索策略优缺点"></a>比较hibernate的三种检索策略优缺点</h3><p><strong>1立即检索；</strong>  </p><p>优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；  </p><p>缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；  </p><p><strong>2延迟检索</strong>：  </p><p>优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；  </p><p>缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；  </p><p><strong>3 迫切左外连接检索</strong>  </p><p>优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；  </p><p>缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；</p><h3 id="如何在控制台看到hibernate生成并执行的sql"><a href="#如何在控制台看到hibernate生成并执行的sql" class="headerlink" title="如何在控制台看到hibernate生成并执行的sql"></a>如何在控制台看到hibernate生成并执行的sql</h3><p>在定义数据库和数据库属性的文件applicationConfig.xml里面，把hibernate.show_sql 设置为true<br>这样生成的SQL就会在控制台出现了<br>注意：这样做会加重系统的负担，不利于性能调优</p><h3 id="hibernate都支持哪些缓存策略-1"><a href="#hibernate都支持哪些缓存策略-1" class="headerlink" title="hibernate都支持哪些缓存策略"></a>hibernate都支持哪些缓存策略</h3><p><strong>Read-only:</strong> 这种策略适用于那些频繁读取却不会更新的数据，这是目前为止最简单和最有效的缓存策略<br>**Read/write:**这种策略适用于需要被更新的数据，比read-only更耗费资源，在非JTA环境下，每个事务需要在session.close和session.disconnect()被调用<br><strong>Nonstrict read/write:</strong> 这种策略不保障两个同时进行的事务会修改同一块数据，这种策略适用于那些经常读取但是极少更新的数据<br> <strong>Transactional:</strong> 这种策略是完全事务化得缓存策略，可以用在JTA环境下</p><h3 id="什么是SessionFactory，是线程安全么？"><a href="#什么是SessionFactory，是线程安全么？" class="headerlink" title="什么是SessionFactory，是线程安全么？"></a>什么是SessionFactory，是线程安全么？</h3><p>SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问。一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存.</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="2021/06/11/%E7%BD%91%E7%BB%9C/"/>
      <url>2021/06/11/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP、UDP-协议的区别？"><a href="#TCP、UDP-协议的区别？" class="headerlink" title="TCP、UDP 协议的区别？"></a>TCP、UDP 协议的区别？</h2><p>tcp 和 udp 是 OSI 模型中的传输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</p><p><strong>1） 连接</strong></p><p>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</p><p>UDP无连接。</p><p><strong>2） 服务对象</strong></p><p>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p><p>UDP支持一对一，一对多，多对一，多对多的交互通信。</p><p><strong>3） 可靠性</strong></p><p>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</p><p>UDP是尽最大努力交付，不保证可靠交付。</p><p><strong>4）拥塞控制，流量控制</strong></p><p>TCP有拥塞控制和流量控制保证数据传输的安全性。</p><p>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p><p><strong>5） 报文长度</strong></p><p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p><p>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p><p><strong>6) 首部开销</strong></p><p>TCP首部开销大，首部20个字节。</p><p>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p><h2 id="TCP和UDP各自适用的场景"><a href="#TCP和UDP各自适用的场景" class="headerlink" title="TCP和UDP各自适用的场景"></a>TCP和UDP各自适用的场景</h2><p>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p><p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p><h2 id="在浏览器中输入url地址到显示页面的过程？"><a href="#在浏览器中输入url地址到显示页面的过程？" class="headerlink" title="在浏览器中输入url地址到显示页面的过程？"></a>在浏览器中输入url地址到显示页面的过程？</h2><p><img src="https://img-blog.csdnimg.cn/20210128160947180.png"></p><p>总体来说分为以下几个过程:</p><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h2 id="HTTP长连接、短连接？"><a href="#HTTP长连接、短连接？" class="headerlink" title="HTTP长连接、短连接？"></a>HTTP长连接、短连接？</h2><p>在<code>HTTP/1.0</code>中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从<code>HTTP/1.1</code>起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><p>Connection:keep-alive</p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h2 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h2><p><img src="https://img-blog.csdnimg.cn/20210128163633691.png"></p><p><code>序列号seq</code>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p><p><code>确认号ack</code>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p><p><code>确认ACK</code>：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p><p><code>同步SYN</code>：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p><p><code>终止FIN</code>：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p><p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p><p><img src="https://img-blog.csdnimg.cn/20210128163725857.png"></p><h3 id="三次握手过程理解"><a href="#三次握手过程理解" class="headerlink" title="三次握手过程理解"></a>三次握手过程理解</h3><p><img src="https://img-blog.csdnimg.cn/20210128163755160.png"></p><p><code>第一次握手</code>：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p><code>第二次握手</code>：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p><code>第三次握手</code>：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><h3 id="四次挥手过程理解"><a href="#四次挥手过程理解" class="headerlink" title="四次挥手过程理解"></a>四次挥手过程理解</h3><p><img src="https://img-blog.csdnimg.cn/20210128163844574.png"></p><p><code>第一次挥手</code>：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态</p><p><code>第二次挥手</code>：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态</p><p><code>第三次挥手</code>：客户端收到服务器确认结果后， 进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）</p><p><code>第四次挥手</code>：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。</p><h3 id="为什么不能用两次握手进行连接？"><a href="#为什么不能用两次握手进行连接？" class="headerlink" title="为什么不能用两次握手进行连接？"></a>为什么不能用两次握手进行连接？</h3><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。</p><p>按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。</p><p>在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。</p><p>Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="为什么要进行三次握手？"><a href="#为什么要进行三次握手？" class="headerlink" title="为什么要进行三次握手？"></a>为什么要进行三次握手？</h3><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。</p><p>如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p><p>客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，</p><p>服务器端是不知道客户端有没有接收到服务器端返回的信息的。</p><h3 id="为什么要进行四次握手？"><a href="#为什么要进行四次握手？" class="headerlink" title="为什么要进行四次握手？"></a>为什么要进行四次握手？</h3><ul><li><p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p></li><li><p>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p></li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p><h2 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h2><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。 </p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h2 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h2><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。 防御手段：</p><p>验证请求来源地址； 关键操作添加验证码； 在请求地址添加 token 并验证。</p><h2 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>301：永久重定向；302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h2 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向：</p><p>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</p><p>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</p><p>效率：forward 比 redirect 效率高。</p><h2 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h2><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：负责建立和管理节点间的链路。</li><li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li></ul><h2 id="你知道TCP-IP协议、HTTP协议分别在哪一层吗？"><a href="#你知道TCP-IP协议、HTTP协议分别在哪一层吗？" class="headerlink" title="你知道TCP/IP协议、HTTP协议分别在哪一层吗？"></a>你知道TCP/IP协议、HTTP协议分别在哪一层吗？</h2><p>tcp属于传输层；</p><p>http属于应用层。</p><h2 id="请说明一下哪种应用场景会使用TCP协议"><a href="#请说明一下哪种应用场景会使用TCP协议" class="headerlink" title="请说明一下哪种应用场景会使用TCP协议"></a>请说明一下哪种应用场景会使用TCP协议</h2><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</p><h2 id="请你来说一说http协议"><a href="#请你来说一说http协议" class="headerlink" title="请你来说一说http协议"></a>请你来说一说http协议</h2><p><strong>1）HTTP协议：</strong></p><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><strong>2）HTTP协议特点</strong></p><p>1、简单快速：</p><p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：</p><p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3、无连接：</p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>4、无状态：</p><p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>5、支持B/S及C/S模式。</p><p>6、默认端口80</p><p>7、基于TCP协议</p><p><strong>3）HTTP过程概述：</strong></p><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p><strong>HTTP 请求/响应的步骤如下：</strong></p><p>1、客户端连接到Web服务器</p><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com./">http://www.baidu.com。</a></p><p>2、发送HTTP请求</p><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>3、服务器接受请求并返回HTTP响应</p><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>4、释放连接TCP连接</p><p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>5、客户端浏览器解析HTML内容</p><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><h2 id="请你讲讲http1-1和1-0的区别"><a href="#请你讲讲http1-1和1-0的区别" class="headerlink" title="请你讲讲http1.1和1.0的区别"></a>请你讲讲http1.1和1.0的区别</h2><p><strong>缓存处理</strong></p><p>在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，</p><p>HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接的使用</strong></p><p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，</p><p>HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>错误通知的管理</strong></p><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>Host头处理</strong></p><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>长连接</strong></p><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h2 id="请说明一下http和https的区别"><a href="#请说明一下http和https的区别" class="headerlink" title="请说明一下http和https的区别"></a>请说明一下http和https的区别</h2><p>1） https协议要申请证书到ca，需要一定经济成本；</p><p>2） http是明文传输，https是加密的安全传输；</p><p>3） 连接的端口不一样，http是80，https是443；</p><p>4）http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。</p><h2 id="HTTPS优缺点"><a href="#HTTPS优缺点" class="headerlink" title="HTTPS优缺点"></a>HTTPS优缺点</h2><p><strong>HTTPS优点：</strong></p><p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p><p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p><p><strong>HTTPS缺点：</strong></p><p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p><p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p><h2 id="请你说一说HTTP返回码"><a href="#请你说一说HTTP返回码" class="headerlink" title="请你说一说HTTP返回码"></a>请你说一说HTTP返回码</h2><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p><p>1xx：指示信息–表示请求已接收，继续处理。</p><p>2xx：成功–表示请求已被成功接收、理解、接受。</p><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>常见状态代码、状态描述的详细说明如下。</p><p>200 OK：客户端请求成功。</p><p>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</p><p>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</p><p>301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</p><p>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</p><p>304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</p><p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p><p>404 not Found：请求资源不存在，举个例子：输入了错误的URL。</p><h2 id="请你谈谈DNS的寻址过程"><a href="#请你谈谈DNS的寻址过程" class="headerlink" title="请你谈谈DNS的寻址过程"></a>请你谈谈DNS的寻址过程</h2><p>1、在浏览器中输入<a href="http://www.qq.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a></p><p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机./">www.qq.com主机。</a></p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><h2 id="请你说一下TCP怎么保证可靠性"><a href="#请你说一下TCP怎么保证可靠性" class="headerlink" title="请你说一下TCP怎么保证可靠性"></a>请你说一下TCP怎么保证可靠性</h2><p><strong>（1）序列号、确认应答、超时重传</strong></p><p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p><p><strong>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</strong></p><p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p><p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p><p><strong>（3）拥塞控制</strong></p><p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p><p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p><p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p><p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p><p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p><p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p><p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p><h2 id="请你说一说IP地址作用，以及MAC地址作用"><a href="#请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="请你说一说IP地址作用，以及MAC地址作用"></a>请你说一说IP地址作用，以及MAC地址作用</h2><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。</p><p>而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><h2 id="请你来说一下数字证书是什么，里面都包含那些内容"><a href="#请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="请你来说一下数字证书是什么，里面都包含那些内容"></a>请你来说一下数字证书是什么，里面都包含那些内容</h2><p><strong>1）概念：</strong></p><p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p><p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p><p><strong>2）数字证书颁发过程：</strong></p><p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p><p><strong>3）内容：</strong></p><p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p><p>1、证书的版本信息；</p><p>2、证书的序列号，每个证书都有一个唯一的证书序列号；</p><p>3、证书所使用的签名算法；</p><p>4、证书的发行机构名称，命名规则一般采用X.500格式；</p><p>5、证书的有效期，通用的证书一般采用UTC时间格式；</p><p>6、证书所有人的名称，命名规则一般采用X.500格式；</p><p>7、证书所有人的公开密钥；</p><p>8、证书发行者对证书的签名。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="jdk源码中用到了哪些设计模式？"><a href="#jdk源码中用到了哪些设计模式？" class="headerlink" title="jdk源码中用到了哪些设计模式？"></a>jdk源码中用到了哪些设计模式？</h2><h3 id="（1）单例模式"><a href="#（1）单例模式" class="headerlink" title="（1）单例模式"></a>（1）单例模式</h3><p>单例模式用于Runtime,Calendar和其他的一些类中。“饿汉式”是在不管你用的用不上，一开始就建立这个单例对象</p><p><img src="https://img-blog.csdnimg.cn/20210131130507884.png"></p><h3 id="（2）工厂模式"><a href="#（2）工厂模式" class="headerlink" title="（2）工厂模式"></a>（2）工厂模式</h3><p>被用于各种不可变的类如Boolean，像Boolean.valueOf方法。</p><h3 id="（3）装饰模式"><a href="#（3）装饰模式" class="headerlink" title="（3）装饰模式"></a>（3）装饰模式</h3><p>装饰器模式被用于多个javaIO类</p><p><img src="https://img-blog.csdnimg.cn/20210131130610766.png"></p><h3 id="（4）代理模式"><a href="#（4）代理模式" class="headerlink" title="（4）代理模式"></a>（4）代理模式</h3><p>Jdk动态代理。</p><h3 id="（5）迭代器模式"><a href="#（5）迭代器模式" class="headerlink" title="（5）迭代器模式"></a>（5）迭代器模式</h3><p>Java集合中的迭代器。</p><h3 id="（6）策略模式"><a href="#（6）策略模式" class="headerlink" title="（6）策略模式"></a>（6）策略模式</h3><p>Arrays.sort()</p><h3 id="（7）享元模式"><a href="#（7）享元模式" class="headerlink" title="（7）享元模式"></a>（7）享元模式</h3><p>Integer.valueof()</p><h3 id="（8）模板方法模式"><a href="#（8）模板方法模式" class="headerlink" title="（8）模板方法模式"></a>（8）模板方法模式</h3><p>loadClass()双亲委派模型</p><h3 id="（9）适配器模式"><a href="#（9）适配器模式" class="headerlink" title="（9）适配器模式"></a>（9）适配器模式</h3><p>new Thread(new Furturetask(new Callable()))   创建线程的第三种方式 使用furturetask来适配callable接口</p><h2 id="工厂模式和简单工厂模式的区别"><a href="#工厂模式和简单工厂模式的区别" class="headerlink" title="工厂模式和简单工厂模式的区别"></a>工厂模式和简单工厂模式的区别</h2><p>1、简单工厂模式中包含判断什么对象的逻辑，而工厂方法模式则需要调用者判断要实例化什么具体类型的工厂进而创建出想要的对象。</p><p>2、当增加新类时，简单工厂模式需要修改工厂类，而工厂方法模式不需要，因此工厂方法模式遵守了开闭原则，而简单工厂模式没遵守。</p><p>3、简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。</p><h2 id="静态代理模式和动态代理模式的区别"><a href="#静态代理模式和动态代理模式的区别" class="headerlink" title="静态代理模式和动态代理模式的区别"></a>静态代理模式和动态代理模式的区别</h2><p><strong>静态：</strong> 由程序员创建代理类。在程序运行前要代理的对象就已经指定了。</p><p><strong>动态：</strong> 在程序运行时运用反射机制动态创建而成。(InvocationHandler的应用)</p><h2 id="设计模式6大原则，以及哪些设计模式遵循了哪些原则"><a href="#设计模式6大原则，以及哪些设计模式遵循了哪些原则" class="headerlink" title="设计模式6大原则，以及哪些设计模式遵循了哪些原则"></a>设计模式6大原则，以及哪些设计模式遵循了哪些原则</h2><p><strong>（1）单一职责原则：</strong></p><p><strong>理解：</strong> 不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。</p><p><strong>（2）开放封闭原则</strong></p><p><strong>理解：</strong> 类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。</p><p><strong>总结：</strong> 对软件实体的改动，最好用扩展而非修改的方式。</p><p><strong>（3）里式替换原则</strong></p><p><strong>理解：</strong> 父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。</p><p><strong>总结：</strong> 在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。</p><p><strong>（4）最少知识原则</strong></p><p><strong>理解：</strong> 尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。</p><p><strong>总结：</strong> 一定要做到：低耦合、高内聚。</p><p><strong>（5）接口隔离原则</strong></p><p><strong>理解：</strong> 不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。</p><p><strong>总结：</strong> 不要对外暴露没有实际意义的接口。</p><p><strong>（6）依赖倒置原则</strong></p><p><strong>理解：</strong> 高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。</p><p><strong>总结：</strong> 面向接口编程，提取出事务的本质和共性。</p><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h3 id="懒汉式单例-线程不安全"><a href="#懒汉式单例-线程不安全" class="headerlink" title="懒汉式单例 线程不安全"></a>懒汉式单例 线程不安全</h3><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h3 id="懒汉式单例-线程安全"><a href="#懒汉式单例-线程安全" class="headerlink" title="懒汉式单例 线程安全"></a>懒汉式单例 线程安全</h3><p>为了解决线程安全的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><h3 id="饿汉式单例-静态final变量-线程安全"><a href="#饿汉式单例-静态final变量-线程安全" class="headerlink" title="饿汉式单例+ 静态final变量 线程安全"></a>饿汉式单例+ 静态final变量 线程安全</h3><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p><h3 id="双重检查加锁单例-线程安全"><a href="#双重检查加锁单例-线程安全" class="headerlink" title="双重检查加锁单例 线程安全"></a>双重检查加锁单例 线程安全</h3><p>双重检验加锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 uniqueInstance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题。主要在于uniqueInstance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ul><li><p>给 uniqueInstance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将uniqueInstance对象指向分配的内存空间（执行完这步 uniqueInstance 就为非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时uniqueInstance已经是非 null 了（但却没有初始化），所以线程二会直接返回 uniqueInstance，然后使用，然后顺理成章地报错。</p></li></ul><p>我们只需要将 uniqueInstance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 uniqueInstance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即使将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h3 id="静态内部类单例-线程安全"><a href="#静态内部类单例-线程安全" class="headerlink" title="静态内部类单例  线程安全"></a>静态内部类单例  线程安全</h3><p>这种方法是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.uniqueInstance; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒加载的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h3 id="枚举单例-线程安全"><a href="#枚举单例-线程安全" class="headerlink" title="枚举单例 线程安全"></a>枚举单例 线程安全</h3><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EasySingleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p><h2 id="谈一谈，开发中都用到了-哪些设计模式-用在什么场合"><a href="#谈一谈，开发中都用到了-哪些设计模式-用在什么场合" class="headerlink" title="谈一谈，开发中都用到了 哪些设计模式? 用在什么场合?"></a>谈一谈，开发中都用到了 哪些设计模式? 用在什么场合?</h2><p>把老哥B站上讲设计模式那个视频看了</p><h2 id="Spring单例和Java单例（设计模式）有什么区别？"><a href="#Spring单例和Java单例（设计模式）有什么区别？" class="headerlink" title="Spring单例和Java单例（设计模式）有什么区别？"></a>Spring单例和Java单例（设计模式）有什么区别？</h2><p>Java单例由Java类加载器确定范围，Spring单例由容器上下文确定范围。</p><p>从根本上讲，这意味着在Java中，可以确保单例仅在加载它的类加载器的上下文中才是真正的单例。尽管您在代码中尽力防止它发生，但其他类加载器也应该能够创建它的另一个实例（前提是这些类加载器不在同一类加载器层次结构中）。</p><p>在Spring中，如果您可以在两个不同的上下文中加载单例类，然后再次打破单例概念。</p><p>因此，总而言之，如果Java无法在给定的类加载器中创建该类的多个实例，则Java将其视为一个单例，而如果Java无法在给定的容器/中创建一个类的多个实例，则Spring将其视为一个单例。上下文。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="用户态和内核态的区别"><a href="#用户态和内核态的区别" class="headerlink" title="用户态和内核态的区别"></a>用户态和内核态的区别</h2><p><strong>内核态</strong>: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序</p><p><strong>用户态</strong>: 只能受限的访问内存, 且不允许访问外围设备。 占用CPU的能力被剥夺， CPU资源可以被其他程序获取</p><p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. </p><p>而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p><p>这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令，这种机制叫系统调用</p><h2 id="进程同步和线程同步"><a href="#进程同步和线程同步" class="headerlink" title="进程同步和线程同步"></a>进程同步和线程同步</h2><h3 id="为什么要进程同步"><a href="#为什么要进程同步" class="headerlink" title="为什么要进程同步"></a>为什么要进程同步</h3><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。</p><h3 id="同步机制需要遵循的原则："><a href="#同步机制需要遵循的原则：" class="headerlink" title="同步机制需要遵循的原则："></a>同步机制需要遵循的原则：</h3><p>①空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</p><p>②忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</p><p>③有限等待：对要求访问临界资源的进程，需要在有限时间呃逆进入临界区，防止出现死等</p><p>④让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等</p><h3 id="进程同步的方式：原子操作、信号量、管程。"><a href="#进程同步的方式：原子操作、信号量、管程。" class="headerlink" title="进程同步的方式：原子操作、信号量、管程。"></a>进程同步的方式：原子操作、信号量、管程。</h3><p><strong>线程同步方式：</strong></p><p>（1）互斥（信号)量，每个时刻只有一个线程可以访问公共资源。只有拥有互斥对象的线程才能访问公共资源，互斥对象只有一个，一个时刻只能有一个线程持有，所以保证了公共资源不会被多个线程同时访问。</p><p>（2）信号量，允许多个线程同时访问公共资源。当时控制了访问资源的线程的最大个数。</p><p>（3）临界区。任意时刻只能有一个线程进入临界区，访问临界资源。</p><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><p><strong>（1）匿名管道：</strong><br>在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。自带同步互斥机制。半双工，单向通信，两个管道实现双向通信。</p><p><strong>（2）命名管道：</strong></p><p>其思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。</p><p><strong>（3）消息队列</strong></p><p>内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。</p><p>消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。</p><p><strong>特点：</strong></p><p>①消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。</p><p>②消息队列允许一个或多个进程写入或者读取消息。</p><p>③消息队列的生命周期随内核。</p><p>④消息队列可实现双向通信。</p><p><strong>（4）信号量</strong></p><p>在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1，对临界资源进行保护。信号量的本质就是计数器</p><p><strong>（5）共享内存</strong> </p><p>在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。</p><p><img src="https://img-blog.csdnimg.cn/20210201001203542.png"></p><p><strong>为什么共享内存速度最快？</strong></p><p>借助上图说明：Proc A 进程给内存中写数据， Proc B 进程从内存中读取数据，在此期间一共发生了两次复制</p><p>（1）Proc A 到共享内存       </p><p>（2）共享内存到 Proc B，因为直接在内存上操作，所以共享内存的速度也就提高了。</p><p><strong>（6）信号</strong></p><p>在软件层上对终端机制的一种模拟，通知有事发生，与处理器收到一个中断请求是一致的。</p><p><strong>（7）套接字</strong></p><p>网络中不同机器间的进程的通信，应用广泛</p><h2 id="进程任务调度算法的特点以及使用场景"><a href="#进程任务调度算法的特点以及使用场景" class="headerlink" title="进程任务调度算法的特点以及使用场景"></a>进程任务调度算法的特点以及使用场景</h2><p>（1）时间片轮转调度算法（RR）：</p><p>（2）先来先服务调度算法（FCFS）：</p><p>（3）优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。</p><p>（4）多级反馈队列调度算法：先按按优先级分成不同的队列，再按时间片轮转。</p><p>（5）高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/进程执行时间”这个公式得到的响应比来进行调度。</p><h2 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h2><p>抢占式。时间分片。</p><h2 id="对mmap的理解"><a href="#对mmap的理解" class="headerlink" title="对mmap的理解"></a>对mmap的理解</h2><p>mmap()系统调用使得进程之间，通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()、write()等操作。 </p><h2 id="select、poll和epoll的区别"><a href="#select、poll和epoll的区别" class="headerlink" title="select、poll和epoll的区别"></a>select、poll和epoll的区别</h2><p>Linux中，提供了select、poll、epoll三种接口来实现IO复用</p><p>（1）select是第一个实现(1983左右在BSD里面实现的)，它存在很多问题：</p><ul><li><p>会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。</p></li><li><p>select只能监视1024个链接。</p></li><li><p>任何一个I/O流出现了数据，select仅仅会返回，但是并不会告诉哪个I/O流上有数据，需要自己去遍历查找。</p></li><li><p>select不是线程安全的。</p></li></ul><p>（2）poll是14年以后(1997年）一帮人实现的，修复了select的很多问题：</p><ul><li>不再修改传入的参数数组。</li><li>去掉了select只能监视1024个链接的限制。</li></ul><p>（3）epoll是5年以后,在2002,大神DavideLibenzi实现的，继续修复了select和poll的绝大部分问题：</p><ul><li>不仅告诉sock组里面数据，还会告诉具体哪个sock有数据。</li><li>线程安全的。</li></ul><p>Linux2.6之后支持epoll</p><p>windows支持select而不支持epoll</p><h2 id="进程、线程、协程的区别，为什么协程效率高"><a href="#进程、线程、协程的区别，为什么协程效率高" class="headerlink" title="进程、线程、协程的区别，为什么协程效率高"></a>进程、线程、协程的区别，为什么协程效率高</h2><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像，线程切换那样消耗资源。</p><h2 id="操作系统页置换算法"><a href="#操作系统页置换算法" class="headerlink" title="操作系统页置换算法"></a>操作系统页置换算法</h2><p>（1）先进先出算法</p><p>（2）最近最久未使用算法 (Least Recently Used, LRU)</p><p>（3）最不常用算法LFU：缺页时，置换访问次数最少的页面</p><p>（4）时钟置换算法（Clock）：仅对页面的访问情况进行大致统计，是LRU和FIFO的折中</p><p>一般选择时钟置换算法：LRU算法的性能接近于OPT，但是实现起来太麻烦，</p><p>LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!</p><p>LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!</p><h2 id="段式页式段页式优缺点总结"><a href="#段式页式段页式优缺点总结" class="headerlink" title="段式页式段页式优缺点总结"></a>段式页式段页式优缺点总结</h2><p><strong>（1）页式管理；</strong></p><p>基本原理是将各进程的虚拟空间划分为若干个长度相等的页。</p><p>优点：没有外碎片，每个内碎片不超过页的大小。</p><p>缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p><p><strong>（2）段式管理</strong></p><p>基本思想是把程序按内容或过程函数关系分成段，每段有自己的名字。</p><p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</p><p>缺点：会产生碎片。</p><p><strong>（3）段页式管理；</strong></p><p>段页式管理是段式管理和页式管理相结合而成，具有两者的优点。</p><h2 id="共享内存的优缺点"><a href="#共享内存的优缺点" class="headerlink" title="共享内存的优缺点"></a>共享内存的优缺点</h2><p><strong>优点：</strong> 我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。</p><p><strong>缺点：</strong> 共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。</p><p>我们可以使用共享内存作为一种独特的存储选项，提供快速读/写操作和进程互操作性等优势。对于 Web 应用程序，这意味着：</p><p>缓存存储（数据库查询、Web 服务数据、外部数据）、会话存储、应用程序之间的数据交换、此存储技术不仅对缓存有用，也对应用程序之间的数据交换也有用，只要数据以两端都可读的格式存储。不要低估共享内存在 Web 应用程序中的力量。可采用许多不同的方式来巧妙地实现这种存储，惟一的限制是开发人员的创造力和技能。</p><h2 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h2><p><strong>（1）先来先服务(FCFS):</strong></p><p>　　这是一种简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。但此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</p><p><strong>（2）最短寻道时间优先(SSTF):</strong></p><p>  　　该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，但这种调度算法却不能保证平均寻道时间最短。</p><p><strong>（3）扫描算法(SCAN):</strong></p><p>　　SCAN算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，SCAN算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。</p><p><strong>（4）循环扫描算法（CSCAN）</strong></p><p>　　CSCAN算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描</p><h2 id="操作系统怎么与硬件互动"><a href="#操作系统怎么与硬件互动" class="headerlink" title="操作系统怎么与硬件互动"></a>操作系统怎么与硬件互动</h2><p>（1）Shell将可执行文件加载到内存中以后，设置相关的寄存器。</p><p>（2）然后，开始执行里面的可执行文件，首先一条一条进行指令分析</p><p>（3）指令分析后，然后进行系统调用，产生中断信号。</p><p>（4）cpu收到中断信号跳转到中断服务程序</p><p>（5）中断服务程序，开始给硬件发送信号，进行驱动执行。</p><p>（6）计算机怎么与硬件沟通，通过寄存器地址访问硬件上的存储器，硬件把信息放在存储器里，每个存储器有个地址，cpu用地址号来读写数据。地址怎么产生的？程序代码里给出的，cpu加电从某个固定地址读出程序指令执行。</p><h2 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h2><h3 id="第一：CPU组成"><a href="#第一：CPU组成" class="headerlink" title="第一：CPU组成"></a>第一：CPU组成</h3><p>CPU基本部分有了运算器、cache、控制器三大部分，称为中央处理器。 </p><p><strong>控制器的功能：</strong></p><p>（1）从指令cache中取出一条指令，并指出下一条指令在指令cache中的位置。</p><p>（2）对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作。比如一次数据cache的读/写操作，一个算术逻辑运算操作，或一个输入/输出操作。</p><p>（3）指挥并控制CPU、数据cache和输入/输出设备之间数据流动的方向。<br>运算器：算术逻辑单元（ALU）、通用寄存器、数据缓冲寄存器DR和状态条件寄存器PSW组成。</p><p><strong>运算器的功能：</strong></p><p>（1）执行所有的算术运算。</p><p>（2）执行所有的逻辑运算，并进行逻辑测试，如零值测试或两个值的比较。通常，一个算术操作产生一个运算结果，而一个逻辑操作则产生一个判决。</p><h3 id="第二：CPU功能"><a href="#第二：CPU功能" class="headerlink" title="第二：CPU功能"></a>第二：CPU功能</h3><p>（1）指令控制：由于程序是一个指令序列，这些指令的相互顺序不能任意颠倒，必须严格按程序规定的顺序进行。</p><p>（2）操作控制： CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。</p><p>（3）时间控制：对各种操作实施时间上的定时。</p><p>（4）数据加工：对数据进行算术运算和逻辑运算处理。</p><h3 id="第三：CPU每个周期做什么事情"><a href="#第三：CPU每个周期做什么事情" class="headerlink" title="第三：CPU每个周期做什么事情"></a>第三：CPU每个周期做什么事情</h3><p>采用流水线划分的方式：取指 译码 执行</p><p><img src="https://img-blog.csdnimg.cn/20210201002106114.png"></p><h3 id="第四：不同的厂商CPU指令集是不一样的"><a href="#第四：不同的厂商CPU指令集是不一样的" class="headerlink" title="第四：不同的厂商CPU指令集是不一样的"></a>第四：不同的厂商CPU指令集是不一样的</h3><p>CPU指令集 取决于 CPU的体系架构，目前主流的就是两类，ARM 和 X86，其他的也有，当然非主流。</p><p>指令集上有啥不一样呢，小例子，ARM 体系的寄存器叫做 R1，R2，R3。。。</p><p>X86 体系的寄存器叫做EAX， EBX，ECX。。。</p><h3 id="第五：操作系统和CPU的关系"><a href="#第五：操作系统和CPU的关系" class="headerlink" title="第五：操作系统和CPU的关系"></a>第五：操作系统和CPU的关系</h3><p>一个.c应用程序，经操作系统编译为CPU指令，在CPU架构上执行。注意：一个应用程序，由操作系统编译为ARM指令，就只能在ARM体系架构上运行；编译为x86指令，就只能在x86体系架构上运行。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="2021/06/11/springCloud/"/>
      <url>2021/06/11/springCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><p>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。</p><p>这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</p><h2 id="为什么需要学习Spring-Cloud"><a href="#为什么需要学习Spring-Cloud" class="headerlink" title="为什么需要学习Spring Cloud"></a>为什么需要学习Spring Cloud</h2><ul><li><p>首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理</p></li><li><p>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</p></li><li><p>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</p></li></ul><h2 id="Spring-Cloud-是什么"><a href="#Spring-Cloud-是什么" class="headerlink" title="Spring Cloud 是什么"></a>Spring Cloud 是什么</h2><ul><li><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p></li><li><p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p></li></ul><h2 id="SpringCloud的优缺点"><a href="#SpringCloud的优缺点" class="headerlink" title="SpringCloud的优缺点"></a>SpringCloud的优缺点</h2><p><strong>优点：</strong></p><ul><li><p>1.耦合度比较低。不会影响其他模块的开发。</p></li><li><p>2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</p></li><li><p>3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。</p></li><li><p>4.微服务跨平台的，可以用任何一种语言开发。</p></li><li><p>5.每个微服务可以有自己的独立的数据库也有用公共的数据库。</p></li><li><p>6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>1.部署比较麻烦，给运维工程师带来一定的麻烦。</p></li><li><p>2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</p></li><li><p>3.系统集成测试比较麻烦</p></li><li><p>4.性能的监控比较麻烦。【最好开发一个大屏监控系统】</p></li></ul><p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p><h2 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h2><ul><li><p>SpringBoot专注于快速方便的开发单个个体微服务。</p></li><li><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p></li><li><p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p></li><li><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p></li><li><p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p></li></ul><h2 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h2><blockquote><table><thead><tr><th>Spring Cloud Version</th><th>SpringBoot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table></blockquote><h2 id="SpringCloud由什么组成"><a href="#SpringCloud由什么组成" class="headerlink" title="SpringCloud由什么组成"></a>SpringCloud由什么组成</h2><p>这就有很多了，我讲几个开发中最重要的</p><ul><li><p>Spring Cloud Eureka（现在闭源了）：服务注册与发现</p></li><li><p>Spring Cloud Zuul（gateway）：服务网关</p></li><li><p>Spring Cloud Ribbon：客户端负载均衡</p></li><li><p>Spring Cloud Feign：声明性的Web服务客户端</p></li><li><p>Spring Cloud Hystrix：断路器</p></li><li><p>Spring Cloud Config：分布式统一配置管理</p></li><li><p>等20几个框架，开源一直在更新</p></li></ul><h2 id="spring-cloud架构图"><a href="#spring-cloud架构图" class="headerlink" title="spring cloud架构图"></a>spring cloud架构图</h2><p><img src="https://img-blog.csdnimg.cn/2021012815435240.png"></p><h2 id="使用-Spring-Boot-开发分布式微服务时，我们面临什么问题"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临什么问题" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临什么问题"></a>使用 Spring Boot 开发分布式微服务时，我们面临什么问题</h2><ul><li><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p></li><li><p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p></li><li><p>（3）冗余-分布式系统中的冗余问题。</p></li><li><p>（4）负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p></li><li><p>（5）性能-问题 由于各种运营开销导致的性能问题。</p></li></ul><h2 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h2><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。</p><p>有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h2 id="什么是Eureka"><a href="#什么是Eureka" class="headerlink" title="什么是Eureka"></a>什么是Eureka</h2><p>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。</p><h2 id="eureka-原理图"><a href="#eureka-原理图" class="headerlink" title="eureka 原理图"></a>eureka 原理图</h2><p><img src="https://img-blog.csdnimg.cn/20210128154502803.png"></p><h2 id="Eureka怎么实现高可用"><a href="#Eureka怎么实现高可用" class="headerlink" title="Eureka怎么实现高可用"></a>Eureka怎么实现高可用</h2><p>Eureka 的集群搭建方法很简单：每一台 Eureka 只需要在配置中指定另外多个 Eureka 的地址就可以实现一个集群的搭建了。</p><h2 id="什么是Eureka的自我保护模式，"><a href="#什么是Eureka的自我保护模式，" class="headerlink" title="什么是Eureka的自我保护模式，"></a>什么是Eureka的自我保护模式，</h2><p>默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式</p><p>在测试环境中不建议开启这个参数，生产环境中建议开启</p><h2 id="DiscoveryClient的作用"><a href="#DiscoveryClient的作用" class="headerlink" title="DiscoveryClient的作用"></a>DiscoveryClient的作用</h2><ul><li>可以从注册中心中根据服务别名获取注册的服务器信息。</li></ul><h2 id="Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别"><a href="#Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别" class="headerlink" title="Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别"></a>Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</h2><p>Dubbo作为服务框架的，一般注册中心会选择zk<br>Spring Cloud作为服务框架的，一般服务注册中心会选择Eureka</p><p><strong>（1）服务注册发现的原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210128153000177.png"></p><p>Eureka，peer-to-peer，部署一个集群，但是集群里每个机器的地位是对等的，各个服务可以向任何一个Eureka实例服务注册和服务发现，集群里任何一个Euerka实例接收到写请求之后，会自动同步给其他所有的Eureka实例 </p><p><img src="https://img-blog.csdnimg.cn/20210128153045165.png"></p><p>ZooKeeper，服务注册和发现的原理，Leader + Follower两种角色，只有Leader可以负责写也就是服务注册，他可以把数据同步给Follower，读的时候leader/follower都可以读</p><ol><li><p>ZooKeeper中的节点服务挂了就要选举<br> 在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的，<br> 选举就是改微服务做了集群，必须有一台主其他的都是从</p></li><li><p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。<br> 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p></li><li><p> Eureka本质上是一个工程，而ZooKeeper只是一个进程</p></li><li><p> Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像ZooKeeper 一样使得整个注册系统瘫痪</p></li><li><p> ZooKeeper保证的是CP，Eureka保证的是AP</p></li></ol><p><strong>2）一致性保障：</strong>  </p><p>C：一致性，Consistency;<br>取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性)  </p><p>A：可用性，Availability;  </p><p>P：分区容错性，Partition tolerance;</p><p>ZooKeeper是有一个leader节点会接收数据， 然后同步写其他节点，一旦leader挂了，要重新选举leader，这个过程里为了保证C，就牺牲了A，不可用一段时间，但是一个leader选举好了，那么就可以继续写数据了，保证一致性</p><p>Eureka是peer模式，可能还没同步数据过去，结果自己就死了，此时还是可以继续从别的机器上拉取注册表，但是看到的就不是最新的数据了，但是保证了可用性，强一致，最终一致性</p><p><strong>（3）服务注册发现的时效性</strong></p><p>zk，时效性更好，注册或者是挂了，一般秒级就能感知到</p><p>eureka，默认配置非常糟糕，服务发现感知要到几十秒，甚至分钟级别，上线一个新的服务实例，到其他人可以发现他，极端情况下，可能要1分钟的时间，ribbon去获取每个服务上缓存的eureka的注册表进行负载均衡</p><p>服务故障，隔60秒才去检查心跳，发现这个服务上一次心跳是在60秒之前，隔60秒去检查心跳，超过90秒没有心跳，才会认为他死了，2分钟都过去<br>30秒，才会更新缓存，30秒，其他服务才会来拉取最新的注册表</p><p>三分钟都过去了，如果你的服务实例挂掉了，此时别人感知到，可能要两三分钟的时间，一两分钟的时间，很漫长</p><p><strong>(4)容量</strong></p><p>zk，不适合大规模的服务实例，因为服务上下线的时候，需要瞬间推送数据通知到所有的其他服务实例，所以一旦服务规模太大，到了几千个服务实例的时候，会导致网络带宽被大量占用</p><p>eureka，也很难支撑大规模的服务实例，因为每个eureka实例都要接受所有的请求，实例多了压力太大，扛不住，也很难到几千服务实例</p><p>之前dubbo技术体系都是用zk当注册中心，spring cloud技术体系都是用eureka当注册中心这两种是运用最广泛的，但是现在很多中小型公司以spring cloud居多，所以后面基于eureka说一下服务注册中心的生产优化</p><h2 id="你们系统遇到过服务发现过慢的问题吗？怎么优化和解决的？"><a href="#你们系统遇到过服务发现过慢的问题吗？怎么优化和解决的？" class="headerlink" title="你们系统遇到过服务发现过慢的问题吗？怎么优化和解决的？"></a>你们系统遇到过服务发现过慢的问题吗？怎么优化和解决的？</h2><p>zk，一般来说还好，服务注册和发现，都是很快的</p><p>eureka，必须优化参数</p><ul><li>服务器到注册中心心跳时间设置</li><li>注册中心定时检测心跳时间设置</li><li>心跳失效时间设置</li><li>readWrite缓存定更新到readOnly时间设置</li><li>客户端定时拉取readWrite缓存时间设置</li></ul><h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关?"></a>什么是网关?</h2><p>服务网关是统一管理API的一个网络关口、通道，是整个微服务平台所有请求的唯一入口，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。</p><p>1、路由转发：接收一切外界请求，转发到后端的微服务上去；</p><p>2、过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，</p><p>这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）。</p><h2 id="网关的作用是什么"><a href="#网关的作用是什么" class="headerlink" title="网关的作用是什么"></a>网关的作用是什么</h2><ul><li>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、限流、安全控制黑名单和白名单等</li></ul><h2 id="什么是Spring-Cloud-Zuul（服务网关）"><a href="#什么是Spring-Cloud-Zuul（服务网关）" class="headerlink" title="什么是Spring Cloud Zuul（服务网关）"></a>什么是Spring Cloud Zuul（服务网关）</h2><ul><li><p>Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。<br>三个重要概念：动态路由表，路由定位，反向代理：</p><ul><li>动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新</li><li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li><li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端</li></ul></li><li><p>它可以和Eureka、Ribbon、Hystrix等组件配合使用，</p></li><li><p>Zuul的应用场景：</p><ul><li>对外暴露，权限校验，限流等</li></ul></li></ul><h2 id="网关与过滤器有什么区别"><a href="#网关与过滤器有什么区别" class="headerlink" title="网关与过滤器有什么区别"></a>网关与过滤器有什么区别</h2><ul><li>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</li></ul><h2 id="常用网关框架有那些？"><a href="#常用网关框架有那些？" class="headerlink" title="常用网关框架有那些？"></a>常用网关框架有那些？</h2><ul><li>Nginx、Zuul、Gateway</li></ul><h2 id="Zuul与Nginx有什么区别？"><a href="#Zuul与Nginx有什么区别？" class="headerlink" title="Zuul与Nginx有什么区别？"></a>Zuul与Nginx有什么区别？</h2><ol><li><p>首先 , Nginx是C语言开发,而 Zuul 是Java语言开发</p></li><li><p>其次，Nginx负载均衡实现,采用服务器实现负载均衡,而Zuul负载均衡的实现是采用 Ribbon  + Eureka 来实现本地负载均衡.</p></li><li><p>Nginx适合于服务器端负载均衡,Zuul适合微服务中实现网关</p></li><li><p>Nginx相比Zuul功能会更加强大,因为Nginx整合一些脚本语言( Nginx + lua )</p></li><li><p>Nginc 是一个高性能的HTTP 和反向代理服务器, 也是一个 IMAP / POP3 /SMIP 服务器. Zuul是 Spring Cloud  Netflix 中的开源的一个API Gateway 服务器,本质上是一个web servlet 应用, 提供动态路由,监控,弹性,安全等边缘服务的框架. Zuul 相当于是设备和Netflix 流应用的Web 网站后端所有请求的前门</p></li></ol><h2 id="如何设计一套API接口"><a href="#如何设计一套API接口" class="headerlink" title="如何设计一套API接口"></a>如何设计一套API接口</h2><p>考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。</p><h2 id="ZuulFilter常用有那些方法"><a href="#ZuulFilter常用有那些方法" class="headerlink" title="ZuulFilter常用有那些方法"></a>ZuulFilter常用有那些方法</h2><ul><li><p>Run()：过滤器的具体业务逻辑</p></li><li><p>shouldFilter()：判断过滤器是否有效</p></li><li><p>filterOrder()：过滤器执行顺序</p></li><li><p>filterType()：过滤器拦截位置</p></li></ul><h2 id="如何实现动态Zuul网关路由转发"><a href="#如何实现动态Zuul网关路由转发" class="headerlink" title="如何实现动态Zuul网关路由转发"></a>如何实现动态Zuul网关路由转发</h2><p>通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。</p><h2 id="Zuul网关如何搭建集群"><a href="#Zuul网关如何搭建集群" class="headerlink" title="Zuul网关如何搭建集群"></a>Zuul网关如何搭建集群</h2><p>使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</p><h2 id="Zuul一版本和Zuul二版本的区别"><a href="#Zuul一版本和Zuul二版本的区别" class="headerlink" title="Zuul一版本和Zuul二版本的区别"></a>Zuul一版本和Zuul二版本的区别</h2><p>目前spring cloud只集成了zuul1。zuul2是Netflix在2018年5月推出，它最大的特点就是支持异步调用 (zuul1仅支持同步) ，可惜springcloud暂时没有计划集成zuul2，而且还推出spring cloud gateway来替代zuul1。</p><p><strong>zuul一版本（同步阻塞）：</strong></p><p>本质上就是一个同步 Servlet，每来一个请求，zuul会专门分配一个线程去处理，然后转发到后端服务，后端再启线程处理请求，后端处理时网关的线程会阻塞，当请求数量比较大时，很容易造成线程池被沾满而无法接受新的请求，Netflix 为此还专门研发了Hystrix熔断组件来解决慢服务耗尽资源问题。</p><p><strong>zuul2的编程模型（异步非阻塞）：</strong></p><p>zuul2是基于Netty实现的异步非阻塞编程模型，一般异步模式的本质都是使用队列 Queue(或称总线 Bus)。网关中会有一个队列专门处理用户请求，一个队列专门负责后端服务调用，中间有个事件环线程 (Event Loop Thread)同时监听两个队列，它的主要作用是将请求转发给后端，并将后端服务的处理结果返回给客户端，用队列的形式减轻了前端请求数量的压力。</p><p><img src="https://img-blog.csdnimg.cn/20210128143433786.png"></p><p>Zuul1 同步编程模型简单，门槛低，开发运维方便，容易调试定位问题。Zuul2 门槛高，调试不方便。 </p><p>Zuul1 监控埋点容易，比如和调用链监控工具 CAT 集成，如果你用 Zuul2 的话，CAT 不好埋点是个问题。 </p><p>Zuul1 已经开源超过 6 年，稳定成熟，坑已经被踩平。Zuul2 刚开源很新，实际落地案例不多，难说有 bug 需要踩坑。 大部分公司达不到 Netflix 那个量级，Netflix 是要应对每日千亿级流量，它们才挖空心思搞异步，一般公司亿级可能都不到，Zuul1 绰绰有余。 </p><p>Zuul1 可以集成 Hystrix 熔断组件，可以部分解决后台服务慢阻塞网关线程的问题。 Zuul1 可以使用 Servlet 3.0 规范支持的 AsyncServlet 进行优化，可以实现前端异步，支持更多的连接数，达到和 Zuul2 一样的效果，但是不用引入太多异步复杂性。</p><h2 id="如果网关需要抗每秒10万的高并发访问，你应该怎么对网关进行生产优化？"><a href="#如果网关需要抗每秒10万的高并发访问，你应该怎么对网关进行生产优化？" class="headerlink" title="如果网关需要抗每秒10万的高并发访问，你应该怎么对网关进行生产优化？"></a>如果网关需要抗每秒10万的高并发访问，你应该怎么对网关进行生产优化？</h2><p><img src="https://img-blog.csdnimg.cn/20210128153713345.png"></p><p>Zuul网关部署的是什么配置的机器，部署32核64G，对网关路由转发的请求，每秒抗个小几万请求是不成问题的，几台Zuul网关机器</p><p>每秒是1万请求，8核16G的机器部署Zuul网关，5台机器就够了</p><h2 id="如果需要部署上万服务实例，现有的服务注册中心能否抗住？如何优化？"><a href="#如果需要部署上万服务实例，现有的服务注册中心能否抗住？如何优化？" class="headerlink" title="如果需要部署上万服务实例，现有的服务注册中心能否抗住？如何优化？"></a>如果需要部署上万服务实例，现有的服务注册中心能否抗住？如何优化？</h2><p>Eureka 和 ZK都是扛不住了，（可以主动说出注册中心的缺点）</p><p>eureka：peer-to-peer，每台机器都是高并发请求，有瓶颈</p><p>zookeeper：服务上下线，全量通知其他服务，网络带宽被打满，有瓶颈</p><p>1、可以加一个数据库层（或者是 redis缓存层），每个服务定时通过数据库（redis缓存层）来更新服务注册表，然后数据库（redis缓存层）定时拉取注册中心来更新注册表。</p><p>2、可以自研，类似于 redis 集群 加主备架构，将压力分散开。按需拉取局部的注册表。比如说服务A在，注册中心1，那么只用拉取注册中心1的注册表。而不用将注册中心1,2,3,4等等其他注册拉取过来。缓解压力。</p><p><img src="https://img-blog.csdnimg.cn/20210128154142558.png"></p><h2 id="说说生产环境下，你们是怎么实现网关对服务的动态路由的？"><a href="#说说生产环境下，你们是怎么实现网关对服务的动态路由的？" class="headerlink" title="说说生产环境下，你们是怎么实现网关对服务的动态路由的？"></a>说说生产环境下，你们是怎么实现网关对服务的动态路由的？</h2><p>• 通过数据库+网关定时拉取数据库 服务注册中心配置。<br>• 首先开发注册中心配置系统，通过页面可以动态的将增加新老服务。写入到数据库。<br>• 同时也可以通过拉取eureka来最新的服务注册中心配置。写入到数据库。<br>• 网关定时10秒拉取数据库的最新配置。<br>这样好处减少了eureka的压力，同时当注册中心服务宕机，也不影响当前网关的路由。</p><h2 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h2><ul><li><p>简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。</p></li><li><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p></li></ul><h2 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h2><ul><li><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</p></li><li><p>Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）</p></li></ul><h2 id="Nginx与Ribbon的区别"><a href="#Nginx与Ribbon的区别" class="headerlink" title="Nginx与Ribbon的区别"></a>Nginx与Ribbon的区别</h2><p>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。</p><p>Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</p><h2 id="Ribbon底层实现原理"><a href="#Ribbon底层实现原理" class="headerlink" title="Ribbon底层实现原理"></a>Ribbon底层实现原理</h2><p>底层的话，使用HTTP通信的框架组件，HttpClient，先得使用Ribbon去本地的Eureka注册表的缓存里获取出来对方机器的列表，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，进行负载均衡，选出一台机器，接着针对那台机器发送 Http请求过去即可</p><h2 id="LoadBalanced注解的作用"><a href="#LoadBalanced注解的作用" class="headerlink" title="@LoadBalanced注解的作用"></a>@LoadBalanced注解的作用</h2><p>开启客户端负载均衡。</p><h2 id="什么是断路器"><a href="#什么是断路器" class="headerlink" title="什么是断路器"></a>什么是断路器</h2><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</p><p><strong>断路器有三种状态</strong></p><ul><li>打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</li><li>半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</li><li>关闭状态：当服务一直处于正常状态 能正常调用</li></ul><h2 id="什么是-Hystrix？"><a href="#什么是-Hystrix？" class="headerlink" title="什么是 Hystrix？"></a>什么是 Hystrix？</h2><p>在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。</p><ul><li><p>Hystrix有四种防雪崩方式:</p><ul><li><p>服务降级：接口调用失败就调用本地的方法返回一个空</p></li><li><p>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</p></li><li><p>服务隔离：隔离服务之间相互影响</p></li><li><p>服务监控：在服务发生调用时，会将每秒请求数、成功请求数等运行指标记录下来。</p></li></ul></li></ul><h2 id="谈谈服务雪崩效应"><a href="#谈谈服务雪崩效应" class="headerlink" title="谈谈服务雪崩效应"></a>谈谈服务雪崩效应</h2><p>雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机，大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中，从而使整个项目的服务宕机崩溃，发生雪崩效应的原因有以下几点</p><ul><li><p>单个服务的代码存在bug.</p></li><li><p>请求访问量激增导致服务发生崩溃(如大型商城的枪红包，秒杀功能).</p></li><li><p>服务器的硬件故障也会导致部分服务不可用.</p></li></ul><h2 id="在微服务中，如何保护服务"><a href="#在微服务中，如何保护服务" class="headerlink" title="在微服务中，如何保护服务?"></a>在微服务中，如何保护服务?</h2><p>一般使用使用Hystrix框架，实现服务隔离来避免出现服务的雪崩效应，从而达到保护服务的效果。当微服务中，高并发的数据库访问量导致服务线程阻塞，使单个服务宕机，服务的不可用会蔓延到其他服务，引起整体服务灾难性后果，使用服务降级能有效为不同的服务分配资源，一旦服务不可用则返回友好提示，不占用其他服务资源，从而避免单个服务崩溃引发整体服务的不可用.</p><h2 id="服务雪崩效应产生的原因"><a href="#服务雪崩效应产生的原因" class="headerlink" title="服务雪崩效应产生的原因"></a>服务雪崩效应产生的原因</h2><p>因为Tomcat默认情况下只有一个线程池来维护客户端发送的所有的请求，这时候某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程，其他请求处于等待状态，无法连接到服务接口。</p><h2 id="谈谈服务降级、熔断、服务隔离"><a href="#谈谈服务降级、熔断、服务隔离" class="headerlink" title="谈谈服务降级、熔断、服务隔离"></a>谈谈服务降级、熔断、服务隔离</h2><ul><li><p>服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</p></li><li><p>服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。</p></li><li><p>服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。</p></li></ul><h2 id="服务降级底层是如何实现的？"><a href="#服务降级底层是如何实现的？" class="headerlink" title="服务降级底层是如何实现的？"></a>服务降级底层是如何实现的？</h2><p>Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。</p><h2 id="什么是Feign？"><a href="#什么是Feign？" class="headerlink" title="什么是Feign？"></a>什么是Feign？</h2><p>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易</p><p>他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</p><h2 id="Feign-原理"><a href="#Feign-原理" class="headerlink" title="Feign 原理"></a>Feign 原理</h2><p>在配置类上，加上@EnableFeginClients，那么该注解是基于@Import注解，注册有关Fegin的解析注册类，这个类是实现 ImportBeanDefinitionRegistrar 这个接口，重写registryBeanDefinition 方法。</p><p>他会扫描所有加了@FeginClient 的接口，然后针对这个注解的接口生成动态代理，然后你针对fegin的动态代理去调用他方法的时候，此时会在底层生成http协议格式的请求。</p><h2 id="SpringCloud有几种调用接口方式"><a href="#SpringCloud有几种调用接口方式" class="headerlink" title="SpringCloud有几种调用接口方式"></a>SpringCloud有几种调用接口方式</h2><ul><li><p>Feign</p></li><li><p>RestTemplate</p></li></ul><h2 id="Ribbon和Feign调用服务的区别"><a href="#Ribbon和Feign调用服务的区别" class="headerlink" title="Ribbon和Feign调用服务的区别"></a>Ribbon和Feign调用服务的区别</h2><ul><li><p>调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐</p></li><li><p>而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</p></li></ul><h2 id="什么是-Spring-Cloud-Bus？"><a href="#什么是-Spring-Cloud-Bus？" class="headerlink" title="什么是 Spring Cloud Bus？"></a>什么是 Spring Cloud Bus？</h2><ul><li><p>Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。</p></li><li><p>Spring Cloud Bus 不能单独完成通信，需要配合MQ支持</p></li><li><p>Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的</p></li><li><p>Springcloud config实时刷新也必须采用SpringCloud Bus消息总线</p></li></ul><h2 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h2><p>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。</p><p>Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。</p><h2 id="分布式配置中心有那些框架？"><a href="#分布式配置中心有那些框架？" class="headerlink" title="分布式配置中心有那些框架？"></a>分布式配置中心有那些框架？</h2><ul><li>Apollo、zookeeper、springcloud config。</li></ul><h2 id="分布式配置中心的作用？"><a href="#分布式配置中心的作用？" class="headerlink" title="分布式配置中心的作用？"></a>分布式配置中心的作用？</h2><ul><li><p>动态变更项目配置信息而不必重新部署项目。</p></li><li><p>统一修改多个项目中的配置，避免错改漏改的一些情况</p></li></ul><h2 id="SpringCloud-Config-可以实现实时刷新吗？"><a href="#SpringCloud-Config-可以实现实时刷新吗？" class="headerlink" title="SpringCloud Config 可以实现实时刷新吗？"></a>SpringCloud Config 可以实现实时刷新吗？</h2><ul><li>springcloud config实时刷新采用SpringCloud Bus消息总线。</li></ul><h2 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h2><p>Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成，开发体验相对来说十分不错。由于zuul2没有被spring cloud所集成，所以拿zuul1与spring cloud gateway做一些简单的比较。</p><p>网关提供API全托管服务，丰富的API管理功能，辅助企业管理大规模的API，以降低管理成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等贡呢。一般来说网关对外暴露的URL或者接口信息，我们统称为路由信息。如果研发过网关中间件或者使用过Zuul的人，会知道网关的核心是Filter以及Filter Chain（Filter责任链）。Sprig Cloud Gateway也具有路由和Filter的概念。下面介绍一下Spring Cloud Gateway中几个重要的概念。</p><ul><li><p>路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter组成。如果断言路由为真，则说明请求的URL和配置匹配</p></li><li><p>断言。Java8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。</p></li><li><p>过滤器。一个标准的Spring webFilter。Spring cloud gateway中的filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理</p></li></ul><h2 id="Zuul和Gateway的区别"><a href="#Zuul和Gateway的区别" class="headerlink" title="Zuul和Gateway的区别"></a>Zuul和Gateway的区别</h2><h3 id="Zuul1-x："><a href="#Zuul1-x：" class="headerlink" title="Zuul1.x："></a>Zuul1.x：</h3><ul><li><p>使用的是阻塞式的 API，不支持长连接，比如 websockets。</p></li><li><p>底层是servlet，Zuul处理的是http请求</p></li><li><p>没有提供异步支持，流控等均由hystrix支持。</p></li><li><p>依赖包spring-cloud-starter-netflix-zuul。</p></li></ul><h3 id="Gateway："><a href="#Gateway：" class="headerlink" title="Gateway："></a>Gateway：</h3><ul><li><p>Spring Boot和Spring Webflux提供的Netty底层环境，不能和传统的Servlet容器一起使用，也不能打包成一个WAR包。</p></li><li><p>依赖spring-boot-starter-webflux和/ spring-cloud-starter-gateway</p></li><li><p>提供了异步支持，提供了抽象负载均衡，提供了抽象流控，并默认实现了RedisRateLimiter限流。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210128144012403.png"></p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><ul><li><p>Config能够管理所有微服务的配置文件</p></li><li><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p></li></ul><h3 id="Spring-Cloud-Netflix-重点，这些组件用的最多"><a href="#Spring-Cloud-Netflix-重点，这些组件用的最多" class="headerlink" title="Spring Cloud Netflix(重点，这些组件用的最多)"></a>Spring Cloud Netflix(重点，这些组件用的最多)</h3><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><ul><li><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p></li><li><p>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</p></li><li><p>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p></li><li><p>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</p></li><li><p>Zuul：API网关组件，对请求提供路由及过滤功能。</p></li></ul><p><code>我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用</code></p><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><ul><li><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。</p></li><li><p>简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。需要利用中间插件MQ</p></li></ul><h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。</p><p>Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</p><h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><ul><li><p>安全工具包，他可以对</p><ul><li>对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌</li><li>资源服务器之间的中继令牌</li><li>使Feign客户端表现得像<code>OAuth2RestTemplate</code>（获取令牌等）的拦截器</li><li>在Zuul代理中配置下游身份验证</li></ul></li><li><p>Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统，通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。</p></li></ul><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求（如下图）。</p><p>如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂，假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了，那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。</p><p>Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。  </p><p><img src="https://img-blog.csdnimg.cn/20200411194744815.jpg"></p><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><ul><li>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li></ul><h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。</p><p>在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。</p><p>Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。</p><h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><ul><li><p>SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper</p></li><li><p>Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。</p></li></ul><h3 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h3><p>Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</p><h2 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h2><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 </p><p>为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 </p><p>当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p><h3 id="Spring-Cloud和SpringBoot版本对应关系-1"><a href="#Spring-Cloud和SpringBoot版本对应关系-1" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h3><blockquote><table><thead><tr><th>Spring Cloud Version</th><th>SpringBoot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table></blockquote><h3 id="Spring-Cloud和各子项目版本对应关系"><a href="#Spring-Cloud和各子项目版本对应关系" class="headerlink" title="Spring Cloud和各子项目版本对应关系"></a>Spring Cloud和各子项目版本对应关系</h3><ul><li><p>Edgware.SR6：我理解为最低版本号</p></li><li><p>Greenwich.SR2 :我理解为最高版本号</p></li><li><p>Greenwich.BUILD-SNAPSHOT（快照）：是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，几乎每天都要提交更新的版本，如果每次提交都申明一个版本号那不是版本号都不够用？</p></li></ul><blockquote><table><thead><tr><th>Component</th><th>Edgware.SR6</th><th>Greenwich.SR2</th><th>Greenwich.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.7.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.4.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.6.RELEASE</td><td>2.1.1.RELEASE</td><td>2.1.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR5</td><td>Fishtown.SR3</td><td>Fishtown.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.21.RELEASE</td><td>2.1.5.RELEASE</td><td>2.1.8.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-vault</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-function</td><td>1.0.2.RELEASE</td><td>2.0.2.RELEASE</td><td>2.0.3.BUILD-SNAPSHOT</td></tr></tbody></table></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 框架 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="2021/06/11/redis/"/>
      <url>2021/06/11/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis五大数据类型"><a href="#redis五大数据类型" class="headerlink" title="redis五大数据类型"></a>redis五大数据类型</h2><p><img src="https://img-blog.csdnimg.cn/20210127224920889.png"></p><h2 id="redis键（key）"><a href="#redis键（key）" class="headerlink" title="redis键（key）"></a>redis键（key）</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>keys *</td><td>获取所有的key</td></tr><tr><td>select 0（库角标）</td><td>选择第几个库</td></tr><tr><td>move key 0（库角标）</td><td>将当前的数据库key移动到某个数据库,目标库有，则不能移动</td></tr><tr><td>flush 0（库角标）</td><td>清除指定库</td></tr><tr><td>randomkey</td><td>获取随机key</td></tr><tr><td>type key</td><td>key的类型</td></tr><tr><td>set key value</td><td>设置key和value</td></tr><tr><td>get key</td><td>获取key的value</td></tr><tr><td>mset key1 value1 key2 value2</td><td>批量设置key、value</td></tr><tr><td>mget key1 key2 key3</td><td>批量获取value</td></tr><tr><td>del key</td><td>删除key</td></tr><tr><td>exists key</td><td>判断是否存在key</td></tr><tr><td>expire key second（秒）</td><td>给key设置过期时间</td></tr><tr><td>pexpire key millisecond （毫秒）</td><td>给key设置过期时间</td></tr><tr><td>persist key</td><td>删除过期时间，持久保存key</td></tr></tbody></table><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>String类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>String类型是Redis最基本的数据类型，一个redis中字符串value最多可以是<code>512M</code></p><p>存储结构类似：<code>key:value</code></p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>set key value</td><td>设置值</td></tr><tr><td>get key</td><td>获取值</td></tr><tr><td>getrange key start end</td><td>获取指定范围的value</td></tr><tr><td>getset key value</td><td>设置新value，并返回旧value</td></tr><tr><td>getbit key offset</td><td>获取字符串中某个位置的字符</td></tr><tr><td>mget key1 key2</td><td>获取多个value</td></tr><tr><td>setex key second（秒） value</td><td>设置key、value，同时设置过期时间</td></tr><tr><td>setnx key value</td><td>key不存在时设置key</td></tr><tr><td>setrange key offset value</td><td>用新value替换老value部分字符，从offset开始替换</td></tr><tr><td>strlen key</td><td>获取value长度</td></tr><tr><td>mset key1 value1 key2 value2</td><td>批量设置key、value</td></tr><tr><td>msetnx key1 value1 key2 value2</td><td>批量设置，当且仅当所有要设置的key都不存在时</td></tr><tr><td>psetex key milliseconds（毫秒） value</td><td>设置过期时间，单位毫秒</td></tr><tr><td>incr key</td><td>如果value是数字，使用这个语法使数字自增1</td></tr><tr><td>incrby key increment</td><td>给value增加指定的值increment</td></tr><tr><td>decr key</td><td>给value减去1</td></tr><tr><td>decrby key decrement</td><td>给value减去指定的值decrement</td></tr><tr><td>append key value</td><td>将value追加到key原来的value尾部</td></tr></tbody></table><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>它是一个字符串链表，left、right都可以插入添加；</p><p>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。</p><p>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p><p><code>key</code>是列表的名称，<code>value</code>是列表。</p><p>存储结构类似：<code>key:[value1, value2, value3, value4]</code></p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>blpop key timeout</td><td>在timeout时间内，获取并移除列表的第一个元素</td></tr><tr><td>brpop key1 timeout</td><td>在timeout时间内，获取并移除列表的最后一个元素</td></tr><tr><td>brpoplpush source destination timeout</td><td>在timeout时间内，从source列表中取出一个值，放到destination列表中</td></tr><tr><td>lindex key index</td><td>获取列表index位置的值</td></tr><tr><td>linsert key BEFORE</td><td>AFTER value1 value2</td></tr><tr><td>llen key</td><td>返回列表的长度</td></tr><tr><td>lpop key</td><td>获取并移除列表的第一个元素</td></tr><tr><td>lpush key value value2</td><td>将一个或多个value插入到列表的头部</td></tr><tr><td>lpushx key value</td><td>当key已经存在的时候，向列表的头部插入value</td></tr><tr><td>lrange key start end</td><td>获取列表部分数据，从start到end范围</td></tr><tr><td>lrem key count value</td><td>count&gt;0，从列表的头部开始算起，移除count个value相同的数据；count&lt;0，从列表的尾部开始算起，移除count绝对值个value相同的数据；count=0，全部移除value相同的数据</td></tr><tr><td>lset key index value</td><td>在列表index位置设置value</td></tr><tr><td>ltrim key start end</td><td>保留start到end内的数据，其余的全部删除</td></tr><tr><td>rpop key</td><td>获取并移除列表最后一个元素</td></tr><tr><td>rpoplpush source destination</td><td>移除source列表最后一个元素，并把该元素添加到destination列表的头部</td></tr><tr><td>RPUSH key value1 value2</td><td>将一个或多个value添加到列表的尾部</td></tr><tr><td>rpushx key value</td><td>为已经存在的列表添加值</td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p><p>存储结构类似：<code>key:&#123;field1:value1, field2:value2, field3:value3&#125;</code></p><p>如：HMSET <code>keyName</code> <code>name</code> “redis tutorial” <code>description</code> “redis basic commands for caching”</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>hdel key field1 field2</td><td>删除key中一个或多个field及value</td></tr><tr><td>hexists key field</td><td>查看哈希表key中，指定的field字段是否存在</td></tr><tr><td>hget key field</td><td>在key中查找filed字段的value值</td></tr><tr><td>hgetall key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>hincrby key field increment</td><td>为哈希表 key 中的指定字段的整数值加上增量increment</td></tr><tr><td>hincrbyfloat key field increment</td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td>hkeys key</td><td>获取所有哈希表中的字段</td></tr><tr><td>hlen key</td><td>获取哈希表中字段的数量</td></tr><tr><td>hmget key field1 field2</td><td>获取所有指定字段的值</td></tr><tr><td>hmset key field1 value1 field2 value2</td><td>同时将多个 field-value对设置到哈希表 key 中</td></tr><tr><td>hset key field value</td><td>将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td>hsetnx key field value</td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td>hvals key</td><td>获取哈希表中所有值。</td></tr><tr><td>hscan key cursor [MATCH pattern] [COUNT count]</td><td>迭代哈希表中的键值对。</td></tr></tbody></table><h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>存储结构类似：<code>key:(&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;)</code></p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>sadd key value1 value2</td><td>向集合添加一个或多个成员</td></tr><tr><td>scard key</td><td>获取集合的成员数大小</td></tr><tr><td>sdiff key1 key2 key3</td><td>返回第一个集合与其他集合之间的差异。</td></tr><tr><td>sdiffstore destination key1 key2</td><td>返回给定所有集合的差集并存储在 destination 新key中</td></tr><tr><td>sinter key1 key2</td><td>返回给定所有集合的交集</td></tr><tr><td>sinterstore destination key1 key2</td><td>返回给定所有集合的交集并存储在 destination 新key中</td></tr><tr><td>sismember key value</td><td>判断key的集合中是否存在value</td></tr><tr><td>smembers key</td><td>返回key集合中所有的value</td></tr><tr><td>smove source destination value</td><td>将 value 元素从 source的key 集合移动到 destination的key 集合中</td></tr><tr><td>spop key</td><td>随机获取并移除key中的一个value</td></tr><tr><td>srandmember key count</td><td>随机返回集合中count个value</td></tr><tr><td>srem key value1 value2</td><td>移除集合中一个或多个value</td></tr><tr><td>sunion key1 key2</td><td>返回所有给定集合的并集</td></tr><tr><td>sunionstore destination key1 key2</td><td>所有给定集合的并集存储在 destination key集合中</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代集合中的元素</td></tr></tbody></table><h3 id="Zset-sorted-set-类型"><a href="#Zset-sorted-set-类型" class="headerlink" title="Zset(sorted set)类型"></a>Zset(sorted set)类型</h3><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p>存储结构类似：<code>key:&#123;score1:value1, score2:value2, score3:value3, &#125;</code></p><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>zadd key score1 value1 score2 value2</td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td>zcard key</td><td>获取有序集合的成员数</td></tr><tr><td>zcount key min max</td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td>zincrby key increment value</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>zinterstore destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td>zlexcount key min max</td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td>zrange key start stop [WITHSCORES]</td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td>zrangebylex key min max [LIMIT offset count]</td><td>通过字典区间返回有序集合的成员</td></tr><tr><td>zrangebyscore key min max [WITHSCORES] [LIMIT]</td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td>zrank key value</td><td>返回有序集合中指定成员的索引</td></tr><tr><td>zrem key value [value …]</td><td>移除有序集合中的一个或多个成员</td></tr><tr><td>zremrangebylex key min max</td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td>zremrangebyrank key start end</td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td>zremrangebyscore key min max</td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td>zrevrange key start stop [WITHSCORES]</td><td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>zrevrangebyscore key max min [WITHSCORES]</td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td>zrevrank key value</td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td>zscore key value</td><td>返回有序集中，成员的分数值</td></tr><tr><td>zunionstore destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td>zscan key cursor [MATCH pattern] [COUNT count]</td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h2 id="Redis持久化两种方式"><a href="#Redis持久化两种方式" class="headerlink" title="Redis持久化两种方式"></a>Redis持久化两种方式</h2><p><img src="https://img-blog.csdnimg.cn/20210127225839437.png"></p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><h3 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h3><p>RDB持久化的机制是在<code>一段时间内</code>达到<code>某修改次数</code>，就把内存数据快照Snapshot<code>持久化</code>到硬盘上，比如：配置1分钟内修改100次，达到这个条件时，就会进行持久化操作。RDB文件格式是<code>dump.rdb</code></p><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p><img src="https://img-blog.csdnimg.cn/20210127225801367.png"></p><p>即：在redis.conf文件里配置，截图上的save &lt;seconds&gt; &lt;changes&gt; </p><p>如：save 1 100（一分钟内修改100次）</p><p>如何停止：在redis.conf文件里配置<code>save &quot;&quot;</code>，或者通过命令<code>config set save &quot;&quot;</code></p><h3 id="触发RDB几种方式"><a href="#触发RDB几种方式" class="headerlink" title="触发RDB几种方式"></a>触发RDB几种方式</h3><ul><li><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><blockquote><p>就是上面说的redis.conf里的save配置</p></blockquote></li><li><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><blockquote><p>执行<code>save</code>命令：save时只管保存，其它不管，全部阻塞</p></blockquote></li></ul><blockquote><p>执行<code>bgsave</code>命令：Redis会在后台异步进行快照操作，<br>快照同时还可以响应客户端请求。可以通过lastsave<br>命令获取最后一次成功执行快照的时间</p></blockquote><blockquote><p>执行<code>flushall</code>命令，也会产生dump.rdb文件，但里面是空的，无意义</p></blockquote><h3 id="持久化原理-fork"><a href="#持久化原理-fork" class="headerlink" title="持久化原理-fork"></a>持久化原理-fork</h3><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到<br>一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><p>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感。</p><p>那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等），数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p><h3 id="将持久化文件重新加载到内存中"><a href="#将持久化文件重新加载到内存中" class="headerlink" title="将持久化文件重新加载到内存中"></a>将持久化文件重新加载到内存中</h3><p>Redis是<code>基于内存</code>的，所以要将<code>硬盘</code>上的数据重新<code>加载到内存</code>中提供服务。</p><ul><li><p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p></li><li><p>获取 redis 的安装目录可以使用 config get dir 命令</p></li></ul><h3 id="RDB优势与劣势"><a href="#RDB优势与劣势" class="headerlink" title="RDB优势与劣势"></a>RDB优势与劣势</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高</p></li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li><p>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p></li><li><p>Fork的时候，内存中的数据被<code>克隆</code>了一份，<code>大致2倍</code>的膨胀性能需要考虑</p></li></ul><h3 id="RDB总结"><a href="#RDB总结" class="headerlink" title="RDB总结"></a>RDB总结</h3><p><img src="https://img-blog.csdnimg.cn/20210127225739269.png"></p><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么"></a>AOF是什么</h3><p>Aof保存的是<code>appendonly.aof</code>文件，是将Redis所有的<code>写命令</code>（增删改）记录到这个日志文件中，<code>读命令</code>不记录。</p><p>只允许在文件末尾追加内容，不允许改写文件。</p><p>Redis启动的时候就会读取该文件，简而言之，就是将文件中的命令<code>重新执行</code>一遍，完成数据恢复到内存的工作。</p><h3 id="如何配置-1"><a href="#如何配置-1" class="headerlink" title="如何配置"></a>如何配置</h3><p><img src="https://img-blog.csdnimg.cn/20210127225717481.png"></p><p>即：在redis.conf文件里配置，截图上的改成<code>appendonly yes</code>。</p><h4 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h4><p>通过Appendfsync配置</p><ul><li><p>Appendfsync Always</p><blockquote><p><code>每次发生</code>数据<code>变更</code>会被立即<code>记录</code>到磁盘，<code>性能较差</code>但<code>数据完整性比较好</code></p></blockquote></li><li><p>Appendfsync Everysec</p></li></ul><blockquote><p>出厂默认推荐，异步操作，<code>每秒</code>记录，如果<code>一秒</code>内<code>宕机</code>，有数据<code>丢失</code></p></blockquote><h3 id="AOF启动-恢复-修复"><a href="#AOF启动-恢复-修复" class="headerlink" title="AOF启动/恢复/修复"></a>AOF启动/恢复/修复</h3><p>同样我们需要将AOF文件<code>加载</code>到<code>内存</code>中之后才能<code>使用</code>，如果<code>AOF</code>文件被<code>破坏</code>了，我们该如何<code>修复</code>呢？</p><ul><li><p>正常恢复到内存中</p><blockquote><p>将有数据的aof文件复制一份保存到对应目录，目录路径可以通过<code>config get dir</code>命令获取，重新启动Redis就可以了</p></blockquote></li><li><p>异常恢复文件到内存中</p><blockquote><p>备份异常AOF文件，使用命令对文件进行修复：<code>redis-check-aof --fix 文件名</code>，然后重新启动Redis就可以了</p></blockquote></li></ul><h3 id="Rewrite重写AOF文件"><a href="#Rewrite重写AOF文件" class="headerlink" title="Rewrite重写AOF文件"></a>Rewrite重写AOF文件</h3><h4 id="什么是Rewrite"><a href="#什么是Rewrite" class="headerlink" title="什么是Rewrite"></a>什么是Rewrite</h4><blockquote><p>AOF采用<code>文件追加</code>方式，文件会<code>越来越大</code>为避免出现此种情况，新增了重写机制。</p></blockquote><blockquote><p>当AOF<code>文件的大小</code>超过所设定的<code>阈值</code>时，Redis就会<code>启动</code>AOF文件的内容<code>压缩</code>，只保留可以恢复数据的<code>最小指令集</code>.可以使用命令<code>bgrewriteaof</code>进行重写文件</p></blockquote><h4 id="Rewrite原理"><a href="#Rewrite原理" class="headerlink" title="Rewrite原理"></a>Rewrite原理</h4><blockquote><p>AOF文件持续增长而过大时，会fork出一条<code>新进程</code>来将文件重写(也是先写临时文件最后再rename)。</p></blockquote><blockquote><p>遍历<code>新进程</code>的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件。</p></blockquote><blockquote><p>而是将整个内存中的数据库内容用命令的方式重写了一个<code>新的aof</code>文件，这点和快照有点类似</p></blockquote><h4 id="触发重写机制"><a href="#触发重写机制" class="headerlink" title="触发重写机制"></a>触发重写机制</h4><blockquote><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍，且文件大于64M时触发</p></blockquote><h3 id="AOF优势-劣势"><a href="#AOF优势-劣势" class="headerlink" title="AOF优势/劣势"></a>AOF优势/劣势</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li><p>每次修改同步：appendfsync always同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</p></li><li><p>每秒同步：appendfsync everysec异步操作，每秒记录，如果一秒内宕机，仅一秒内的数据丢失</p></li></ul><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li><p>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</p></li><li><p>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</p></li></ul><h3 id="AOF总结"><a href="#AOF总结" class="headerlink" title="AOF总结"></a>AOF总结</h3><p><img src="https://img-blog.csdnimg.cn/20210127225621155.png"></p><h2 id="哨兵简介"><a href="#哨兵简介" class="headerlink" title="哨兵简介"></a>哨兵简介</h2><p><img src="https://img-blog.csdnimg.cn/20210127230255517.png"></p><p><code>Sentinel</code>（哨兵）是Redis<code>高可用</code>的解决方案，可以运行多个Sentinel组成一个哨兵分布式系统。</p><p>这里我们的<code>哨兵机制</code>就是解决这个问题：<code>故障转移</code>，如果主节点挂掉，就进行<code>主从切换</code>，让从节点<code>升级</code>为主节点，继续对外提供服务。</p><p>使用流言协议(gossip protocols)来接收主机<code>是否下线</code>；并使用投票协议(agreement protocols)来决定是否执行<code>自动故障迁移</code>； 以及选择哪个从服务器作为<code>新的主服务器</code>。</p><h4 id="Sentinel哨兵职责如下："><a href="#Sentinel哨兵职责如下：" class="headerlink" title="Sentinel哨兵职责如下："></a>Sentinel哨兵职责如下：</h4><ul><li><p><code>监控</code>(Monitoring)：Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</p></li><li><p><code>提醒</code>(Notification): 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p></li><li><p><code>自动故障迁移</code>(Automaticfailover): 当一个主服务器<code>不能正常工作</code>时， Sentinel 会开始一次<code>自动故障迁移</code>操作，它会将失效主服务器的其中一个从服务器<code>升级</code>为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器; 当<code>客户端</code>试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</p></li><li><p><code>统一的配置管理</code>：连接者询问sentinel取得主从的地址。</p></li></ul><h2 id="哨兵搭建"><a href="#哨兵搭建" class="headerlink" title="哨兵搭建"></a>哨兵搭建</h2><h3 id="机器准备"><a href="#机器准备" class="headerlink" title="机器准备"></a>机器准备</h3><p><code>主从复制</code>的搭建，之前的文章讲过了，大家可以去参考</p><table><thead><tr><th>服务器名称</th><th>节点类型</th><th>IP地址</th><th>端口</th></tr></thead><tbody><tr><td>Node1</td><td>Redis服务1(主节点Master)</td><td>192.168.14.101</td><td>6379</td></tr><tr><td>Node2</td><td>Redis服务2(从节点slave1)</td><td>192.168.14.102</td><td>6380</td></tr><tr><td>Node3</td><td>Redis服务3(从节点slave2)</td><td>192.168.14.103</td><td>6381</td></tr><tr><td>Sentinel1</td><td>哨兵服务1</td><td>192.168.14.101</td><td>26379</td></tr><tr><td>Sentinel2</td><td>哨兵服务2</td><td>192.168.14.102</td><td>26380</td></tr><tr><td>Sentinel3</td><td>肖兵服务3</td><td>192.168.14.103</td><td>26381</td></tr></tbody></table><h3 id="五个主要配置讲解"><a href="#五个主要配置讲解" class="headerlink" title="五个主要配置讲解"></a>五个主要配置讲解</h3><p>在每个主从Redis目录下新建一个名为sentinel.conf的文件，在该文件下配置如下命令。</p><p><code>命令总格式</code>：sentinel <option_name> <master_name> <option_value></p><h4 id="一：配置sentinel监控master"><a href="#一：配置sentinel监控master" class="headerlink" title="一：配置sentinel监控master"></a>一：配置sentinel监控master</h4><p><code>示例</code>：sentinel monitor mymaster 127.0.0.1 6380 1</p><p><code>详解</code>：sentinel监控的master的名字叫做mymaster，地址为127.0.0.1:6380；sentinel在集群中，需要多个sentinel互相沟通来确认某个master是否真的死了；数字1代表，当集群中有1个sentinel认为master死了时，才能真正认为该master已经不可用了。</p><h4 id="二：配置sentinel心跳"><a href="#二：配置sentinel心跳" class="headerlink" title="二：配置sentinel心跳"></a>二：配置sentinel心跳</h4><p><code>示例</code>：sentinel down-after-milliseconds mymaster 5000</p><p><code>详解</code>：sentinel向master发送心跳PING，确认master是否存活，如果master在<code>down-after-milliseconds</code>时间（单位毫秒）范围内没有给sentinel回应<code>PONG</code>，或者回复一个错误消息，那么sentinel就主观的认为这个master不可用了</p><h4 id="三：配置主从切换时，同步新master的salve个数"><a href="#三：配置主从切换时，同步新master的salve个数" class="headerlink" title="三：配置主从切换时，同步新master的salve个数"></a>三：配置主从切换时，同步新master的salve个数</h4><p><code>示例</code>：sentinel parallel-syncs mymaster 1</p><p><code>详解</code>：在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步数据。这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以设为 1 来保证每次只有一个slave处于不能处理命令请求的状态</p><h4 id="四：配置故障转移最大时间"><a href="#四：配置故障转移最大时间" class="headerlink" title="四：配置故障转移最大时间"></a>四：配置故障转移最大时间</h4><p><code>示例</code>：sentinel failover-timeout mymaster 60000（毫秒）</p><p><code>详解</code>：若Sentinel进程在该配置值内未能完成故障转移的操作，则认为本次故障转移操作失败。</p><h4 id="五：配置报警脚本"><a href="#五：配置报警脚本" class="headerlink" title="五：配置报警脚本"></a>五：配置报警脚本</h4><p><code>示例</code>：sentinel notification-script mymaster <script-path></p><p><code>详解</code>：Sentinel检测到Master主服务器异常时，所要调用的报警脚本。</p><h3 id="sentinel配置文件示例"><a href="#sentinel配置文件示例" class="headerlink" title="sentinel配置文件示例"></a>sentinel配置文件示例</h3><p>大家按照这个配置，分别给3个sentinel节点进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line">#以守护进程模式启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"></span><br><span class="line">#日志文件名</span><br><span class="line">logfile &quot;sentinel_26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master主机</span><br><span class="line">sentinel monitor mymaster 192.168.1.108 6379 2</span><br><span class="line"></span><br><span class="line"># sentinel连接主从密码验证，注意必须为主从设置一样的密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster 1234</span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 失效转移最大时间设置</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">#如果了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line">sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh  </span><br></pre></td></tr></table></figure><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><p><code>方式1</code>：redis-sentinel redis-sentinel.conf</p><p><code>方式2</code>：redis-server sentinel.conf –sentinel</p><h3 id="验证主从切换"><a href="#验证主从切换" class="headerlink" title="验证主从切换"></a>验证主从切换</h3><p>kill掉master主节点，模拟主机出现故障</p><p><img src="https://img-blog.csdnimg.cn/20210127230144868.png"></p><p>上面截图红框框住的几个重要信息，这里先介绍最后一行，<code>switch-master mymaster</code> 192.168.14.101 6379 192.168.14.103 6381，表示master服务器由<code>6379</code>切换为<code>6381</code>端口的redis服务器。</p><p><code>PS:+switch-master</code> 表示切换主节点</p><h4 id="查看6381端口Redis服务器"><a href="#查看6381端口Redis服务器" class="headerlink" title="查看6381端口Redis服务器"></a>查看6381端口Redis服务器</h4><p>通过命令info replication查看，我们发现,6381的Redis服务已经切换成master节点了. </p><p>另外，也可以查看sentinel.conf 配置文件，里面的 sentinel monitor mymaster 192.168.14.101 6379 2 也自动更改为6381了</p><p><img src="https://img-blog.csdnimg.cn/20210127230110302.png"></p><p>至此，哨兵模式搭建验证完成。</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Redis的主从复制概念和MySQL的主从复制大概类似。一台<code>主机master</code>，一台<code>从机slaver</code>。master主机数据更新后根据配置和策略，自动同步到slaver从机，Master以<code>写为主</code>，Slave以<code>读为主</code>。</p><p><img src="https://img-blog.csdnimg.cn/20210127230837106.png"></p><h4 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h4><ul><li><p><code>读写分离</code>：适用于读多写少的应用，增加多个从机，提高读的速度，提高程序并发</p></li><li><p><code>数据容灾恢复</code>：从机复制主机的数据，相当于数据备份，如果主机数据丢失，那么可以通过从机存储的数据进行恢复。</p></li><li><p><code>高并发、高可用集群实现的基础</code>：在高并发的场景下，就算主机挂了，从机可以进行<code>主从切换</code>，从机自动成为主机对外提供服务。</p></li></ul><h3 id="一主多从配置"><a href="#一主多从配置" class="headerlink" title="一主多从配置"></a>一主多从配置</h3><p><img src="https://img-blog.csdnimg.cn/20210127230811137.png"></p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>老哥太穷了，就用一台机器模拟三个机器。</p><ul><li><p><code>第一步：</code>将redis.conf复制3份，分别是redis6379.conf、redis6380.conf、redis6381.conf</p></li><li><p><code>第二步：</code> 修改三个redis.conf文件里的port端口、pid文件名、日志文件名、rdb文件名</p></li><li><p><code>第三步：</code> 分别打开三个窗口模拟三台服务器，并开启redis服务。</p></li></ul><h4 id="查看当前3台机器主从角色"><a href="#查看当前3台机器主从角色" class="headerlink" title="查看当前3台机器主从角色"></a>查看当前3台机器主从角色</h4><p>先用命令<code>info replication</code>看看3台机器目前的<code>角色</code>是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 三台机器都是这个状态</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># 角色是master主机</span><br><span class="line">role:master</span><br><span class="line"># 从机个数为0</span><br><span class="line">connected_slaves:0</span><br></pre></td></tr></table></figure><h4 id="设置主从关系"><a href="#设置主从关系" class="headerlink" title="设置主从关系"></a>设置主从关系</h4><p>这里注意，我们只设置从机就可以了，不用设置主机。我们选择<code>6380</code>和<code>6381</code>作为<code>从机</code>。<code>6379</code>作为<code>主机</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 6380 端口</span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"># 6381 端口</span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure><h4 id="再次查看3台机器目前角色"><a href="#再次查看3台机器目前角色" class="headerlink" title="再次查看3台机器目前角色"></a>再次查看3台机器目前角色</h4><p>再次执行命令：<code>info replication</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 主机</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">role:master # 角色：主机</span><br><span class="line">connected_slaves:2 #连接的从机个数，以及从机IP和端口</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;98,lag&#x3D;1</span><br><span class="line">slave1:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;98,lag&#x3D;1</span><br><span class="line"></span><br><span class="line"># 从机1</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">role:slave # 角色：从机</span><br><span class="line">master_host:127.0.0.1 # 主机的IP和端口</span><br><span class="line">master_port:6379</span><br><span class="line"></span><br><span class="line"># 从机2</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line">role:slave # 角色：从机</span><br><span class="line">master_host:127.0.0.1 # 主机的IP和端口</span><br><span class="line">master_port:6379</span><br></pre></td></tr></table></figure><h4 id="搭建成功，试验一把"><a href="#搭建成功，试验一把" class="headerlink" title="搭建成功，试验一把"></a>搭建成功，试验一把</h4><ul><li><p><code>全量复制：</code> 从机会把主机之前的数据全部都同步过来，大家可以在从机上get 某key试试。</p></li><li><p><code>增量复制：</code> 当主机新增数据时，从机会将该新增数据同步过来，大家可以在主机上执行命令set key value，然后在从机上get 该key，看是否能获取到。</p></li></ul><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>Redis的从机<code>默认</code>不允许进行<code>写操作</code>，大家可以在从机上执行命令<code>set key value</code>，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 6380从机</span><br><span class="line">127.0.0.1:6380&gt; set k3 v3</span><br><span class="line">(error) READONLY You can&#39;t write against a read only slave.</span><br></pre></td></tr></table></figure><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p><img src="https://img-blog.csdnimg.cn/20210127230730365.png"></p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><img src="https://img-blog.csdnimg.cn/20210127230644869.png"></p><p><strong>①</strong>slave发送psync，由于是第一次复制，不知道master的runid，自然也不知道offset，所以发送psync ？ -1</p><p><strong>②</strong>master收到请求，发送master的runid和offset给从节点。</p><p><strong>③</strong>从节点slave保存master的信息</p><p><strong>④</strong>主节点bgsave保存rdb文件</p><p><strong>⑤</strong>主机点发送rdb文件</p><p>并且在<strong>④</strong>和<strong>⑤</strong>的这个过程中产生的数据，会写到复制缓冲区repl_back_buffer之中去。</p><p><strong>⑥</strong>主节点发送上面两个步骤产生的buffer到从节点slave</p><p><strong>⑦</strong>从节点清空原来的数据，如果它之前有数据，那么久会清空数据</p><p><strong>⑧</strong>从节点slave把rdb文件的数据装载进自身。</p><h4 id="全量复制的开销"><a href="#全量复制的开销" class="headerlink" title="全量复制的开销"></a>全量复制的开销</h4><p><strong>①</strong>bgsave时间</p><p><strong>②</strong>rdb文件网络传输时间</p><p><strong>③</strong>从节点清空数据的</p><p><strong>④</strong>从节点加载rdb的时间</p><p><strong>⑤</strong>可能的aof重写时间，这是针对从节点，例如开启了aof之后，从节点添加buffer数据时候，可能需要aof重写</p><p>基于上面的原因，有的情况下不适合使用全量复制，例如网络抖动之后，从节点只需要传送一部分数据，不需要传送全部数据，<code>redis2.8</code>之后实现了部分复制功能</p><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p><img src="https://img-blog.csdnimg.cn/20210127230613452.png"></p><p><strong>①</strong>假设发送网络抖动或者别的情况，暂时失去了连接</p><p><strong>②</strong>这个时候，master还在继续往buffer里面写数据</p><p><strong>③</strong>slave重新连接上了master</p><p><strong>④</strong>slave向master发送自己的offset和runid</p><p><strong>⑤</strong>master判断slave的offset是否在buffer的队列里面，如果是，那就返回continue给slave，否则需要进行全量复制（因为这说明已经错过了很多数据了）</p><p><strong>⑥</strong>master发送从slave的offset开始到缓冲区队列结尾的数据给slave</p><h2 id="为什么要用-redis-？为什么要用缓存？"><a href="#为什么要用-redis-？为什么要用缓存？" class="headerlink" title="为什么要用 redis ？为什么要用缓存？"></a>为什么要用 redis ？为什么要用缓存？</h2><p>高性能：</p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>高并发：</p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="为什么要用-redis-而不用-map-guava-做缓存"><a href="#为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 redis 而不用 map/guava 做缓存?"></a>为什么要用 redis 而不用 map/guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p><h2 id="redis-的线程模型是怎么样的？"><a href="#redis-的线程模型是怎么样的？" class="headerlink" title="redis 的线程模型是怎么样的？"></a>redis 的线程模型是怎么样的？</h2><p>redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li><p>多个 socket</p></li><li><p>IO 多路复用程序</p></li><li><p>文件事件分派器</p></li><li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）<br>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p></li></ul><h2 id="redis-和-memcached-的区别？"><a href="#redis-和-memcached-的区别？" class="headerlink" title="redis 和 memcached 的区别？"></a>redis 和 memcached 的区别？</h2><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</p><p>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</p><p>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p><h2 id="如何实现-redis-事务？"><a href="#如何实现-redis-事务？" class="headerlink" title="如何实现 redis 事务？"></a>如何实现 redis 事务？</h2><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><h2 id="什么是-RedLock？"><a href="#什么是-RedLock？" class="headerlink" title="什么是 RedLock？"></a>什么是 RedLock？</h2><p>获取当前时间（start）。</p><p>依次向 N 个 Redis节点请求锁。请求锁的方式与从单节点 Redis获取锁的方式一致。为了保证在某个 Redis节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。这样才能保证客户端在向某个 Redis节点获取锁失败之后，可以立刻尝试下一个节点。</p><p>计算获取锁的过程总共消耗多长时间（consumeTime = end - start）。如果客户端从大多数 Redis节点（&gt;= N/2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。</p><p>如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 consumeTime。</p><p>如果最终获取锁失败，客户端应该立刻向所有 Redis节点发起释放锁的请求。</p><h2 id="说说-Redis-都有哪些应用场景？"><a href="#说说-Redis-都有哪些应用场景？" class="headerlink" title="说说 Redis 都有哪些应用场景？"></a>说说 Redis 都有哪些应用场景？</h2><p><code>缓存</code>：这应该是 Redis 最主要的功能了，也是大型网站必备机制，合理地使用缓存不仅可以加 快数据的访问速度，而且能够有效地降低后端数据源的压力。</p><p><code>共享Session</code>：对于一些依赖 session 功能的服务来说，如果需要从单机变成集群的话，可以选择 redis 来统一管理 session。</p><p><code>消息队列系统</code>：消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务 解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列的功 能，虽然和专业的消息队列比还不够足够强大，但是对于一般的消息队列功 能基本可以满足。比如在分布式爬虫系统中，使用 redis 来统一管理 url队列。</p><p><code>分布式锁</code>：在分布式服务中。可以利用Redis的setnx功能来编写分布式的锁，虽然这个可能不是太常用。 当然还有诸如排行榜、点赞功能都可以使用 Redis 来实现，但是 Redis 也不是什么都可以做，比如数据量特别大时，不适合 Redis，我们知道 Redis 是基于内存的，虽然内存很便宜，但是如果你每天的数据量特别大，比如几亿条的用户行为日志数据，用 Redis 来存储的话，成本相当的高。</p><h2 id="单线程的-Redis-为什么这么快？"><a href="#单线程的-Redis-为什么这么快？" class="headerlink" title="单线程的 Redis 为什么这么快？"></a>单线程的 Redis 为什么这么快？</h2><p>Redis 有多快？官方给出的答案是读写速度 10万/秒，如果说这是在单线程情况下跑出来的成绩，你会不会惊讶？为什么单线程的 Redis 速度这么快？原因有以下几点：</p><p>纯内存操作：</p><ul><li><p>Redis 是完全基于内存的，所以读写效率非常的高，当然 Redis 存在持久化操作，在持久化操作是都是 fork 子进程和利用 Linux 系统的页缓存技术来完成，并不会影响 Redis 的性能。 </p></li><li><p>单线程操作：单线程并不是坏事，单线程可以避免了频繁的上下文切换，频繁的上下文切换也会影响性能的。 </p></li><li><p>合理高效的数据结构 </p></li><li><p>采用了非阻塞 I/O 多路复用机制：多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p></li></ul><h2 id="说一说-Redis-的数据过期淘汰策略？"><a href="#说一说-Redis-的数据过期淘汰策略？" class="headerlink" title="说一说 Redis 的数据过期淘汰策略？"></a>说一说 Redis 的数据过期淘汰策略？</h2><p>Redis 中数据过期策略采用定期删除+惰性删除策略。</p><h3 id="1、定期删除、惰性删除策略是什么？"><a href="#1、定期删除、惰性删除策略是什么？" class="headerlink" title="1、定期删除、惰性删除策略是什么？"></a>1、定期删除、惰性删除策略是什么？</h3><ul><li><p><code>定期删除策略</code>：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。 </p></li><li><p><code>惰性删除策略</code>：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。 </p></li></ul><h3 id="2、定期删除-惰性删除策略是如何工作的？"><a href="#2、定期删除-惰性删除策略是如何工作的？" class="headerlink" title="2、定期删除+惰性删除策略是如何工作的？"></a>2、定期删除+惰性删除策略是如何工作的？</h3><p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。</p><p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。Redis 内存淘汰机制有以下几种策略：</p><ul><li><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p></li><li><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</p></li><li><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-eviction：禁止驱逐数据，永不过期，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！（默认值）</p></li></ul><p><strong>4.0版本后增加以下两种：</strong></p><ul><li><p>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</p></li><li><p>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</p></li></ul><h2 id="手写一个-LRU-算法"><a href="#手写一个-LRU-算法" class="headerlink" title="手写一个 LRU 算法"></a>手写一个 LRU 算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jedis-和-Redisson-有哪些区别？"><a href="#jedis-和-Redisson-有哪些区别？" class="headerlink" title="jedis 和 Redisson 有哪些区别？"></a>jedis 和 Redisson 有哪些区别？</h2><p>jedis：提供了比较全面的 Redis 命令的支持。</p><p>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><h2 id="请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的"><a href="#请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的" class="headerlink" title="请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?"></a>请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</h2><p>因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：</p><p><strong>1）操作redis时，额外做一步rehash</strong></p><p>对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。</p><p><strong>2）后台定时任务调用rehash</strong></p><p>后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率</p><h2 id="请问Redis的数据类型底层怎么实现"><a href="#请问Redis的数据类型底层怎么实现" class="headerlink" title="请问Redis的数据类型底层怎么实现?"></a>请问Redis的数据类型底层怎么实现?</h2><p>1）字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)</p><p>2）列表：压缩列表、双端链表</p><p>3）哈希：压缩列表、字典</p><p>4）集合：整数集合、字典</p><p>5）有序集合：压缩列表、跳跃表和字典</p><h2 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h2><p>SDS是”simple dynamic string”的缩写。 redis中所有场景中出现的字符串，基本都是由SDS来实现的</p><ul><li>所有非数字的key。例如set msg “hello world” 中的key msg.</li><li>字符串数据类型的值。例如`` set msg “hello world”中的msg的值”hello wolrd”</li><li>非字符串数据类型中的“字符串值”。例如RPUSH fruits “apple” “banana” “cherry”中的”apple” “banana” “cherry”</li></ul><p><strong>SDS长这样：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210127231343543.png"></p><ul><li>free:还剩多少空间 </li><li>len:字符串长度 </li><li>buf:存放的字符数组</li></ul><p><strong>空间预分配</strong></p><p>为减少修改字符串带来的内存重分配次数，sds采用了“一次管够”的策略：</p><ul><li>若修改之后sds长度小于1MB,则多分配现有len长度的空间</li><li>若修改之后sds长度大于等于1MB，则扩充除了满足修改之后的长度外，额外多1MB空间</li></ul><p><strong>惰性空间释放</strong></p><p>为避免缩短字符串时候的内存重分配操作，sds在数据减少时，并不立刻释放空间。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="https://img-blog.csdnimg.cn/20210127231738933.png"></p><p>分两部分，一部分是“统筹部分”：橘黄色，</p><p>一部分是“具体实施方“：蓝色。</p><p>主体”统筹部分“：</p><ul><li>head指向具体双向链表的头</li><li>tail指向具体双向链表的尾</li><li>len双向链表的长度</li></ul><p>具体”实施方”：一目了然的双向链表结构，有前驱pre有后继next</p><p>由list和listNode两个数据结构构成。</p><h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>压缩列表。 redis的列表键和哈希键的底层实现之一。此数据结构是为了节约内存而开发的。</p><p>和各种语言的数组类似，它是由连续的内存块组成的，这样一来，由于内存是连续的，就减少了很多内存碎片和指针的内存占用，进而节约了内存。</p><p><img src="https://img-blog.csdnimg.cn/20210127231856265.png"></p><p>然后文中的entry的结构是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20210127231924589.png"></p><p>元素的遍历</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec2447c53c3024?imageslim"></p><p>然后再根据ziplist节点元素中的previous_entry_length属性，来逐个遍历:</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec2449a7dc6360?imageslim"></p><p><strong>连锁更新</strong></p><p>再次看看entry元素的结构，有一个previous_entry_length字段，他的长度要么都是1个字节，要么都是5个字节：</p><ul><li>前一节点的长度小于254字节，则previous_entry_length长度为1字节</li><li>前一节点的长度大于254字节，则previous_entry_length长度为5字节</li></ul><p>假设现在存在一组压缩列表，长度都在250字节至253字节之间，突然新增一新节点new， 长度大于等于254字节，会出现：</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec2449a7fb8404?imageslim"></p><p>程序需要不断的对压缩列表进行空间重分配工作，直到结束。</p><p>除了增加操作，删除操作也有可能带来“连锁更新”。 请看下图，ziplist中所有entry节点的长度都在250字节至253字节之间，big节点长度大于254字节，small节点小于254字节。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec2449a8205b33?imageslim"></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表略微有点复杂。哈希表的制作方法一般有两种，一种是：开放寻址法，一种是拉链法。redis的哈希表的制作使用的是拉链法。</p><p>整体结构如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210127232430163.png"></p><p>也是分为两部分：左边橘黄色部分和右边蓝色部分，同样，也是”统筹“和”实施“的关系。 具体哈希表的实现，都是在蓝色部分实现的。 先来看看蓝色部分：</p><p><img src="https://img-blog.csdnimg.cn/20210127232455517.png"></p><p>这也分为左右两边“统筹”和“实施”的两部分。</p><p>右边部分很容易理解：就是通常拉链表实现的哈希表的样式；数组就是bucket，一般不同的key首先会定位到不同的bucket，若key重复，就用链表把冲突的key串起来。</p><p><strong>新建key的过程：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec244b575509bb?imageslim"></p><p><strong>假如重复了:</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec244dd6e6a6ba?imageslim"></p><p><strong>rehash</strong></p><p>再来看看哈希表总体图中左边橘黄色的“统筹”部分，其中有两个关键的属性：ht和rehashidx。<br>ht是一个数组，有且只有俩元素ht[0]和ht[1];其中，ht[0]存放的是redis中使用的哈希表，而ht[1]和rehashidx和哈希表的rehash有关。</p><p>rehash指的是重新计算键的哈希值和索引值，然后将键值对重排的过程。</p><p>加载因子（load factor） = ht[0].used / ht[0].size。</p><p><strong>扩容和收缩标准</strong></p><p>扩容：</p><ul><li><p>没有执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的加载因子大于等于1。</p></li><li><p>正在执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的加载因子大于等于5。</p></li></ul><p>收缩:</p><ul><li>加载因子小于0.1时，程序自动开始对哈希表进行收缩操作。</li></ul><p><strong>扩容和收缩的数量</strong></p><p>扩容：第一个大于等于ht[0].used * 2的2^n(2的n次方幂)。</p><p>收缩：第一个大于等于ht[0].used的2^n(2的n次方幂)。</p><h2 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h2><p>整数集合是集合键的底层实现方式之一。</p><p><img src="https://img-blog.csdnimg.cn/20210127233528661.png"></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表这种数据结构长这样：</p><p><img src="https://img-blog.csdnimg.cn/20210127233556388.png"></p><p>redis中把跳表抽象成如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210127233621889.png"></p><p>看这个图，左边“统筹”，右边实现。 统筹部分有以下几点说明：</p><ul><li>header: 跳表表头</li><li>tail:跳表表尾</li><li>level:层数最大的那个节点的层数</li><li>length：跳表的长度</li></ul><p>实现部分有以下几点说明：</p><ul><li>表头：是链表的哨兵节点，不记录主体数据。</li><li>是个双向链表</li><li>分值是有顺序的</li><li>o1、o2、o3是节点所保存的成员，是一个指针，可以指向一个SDS值。</li><li>层级高度最高是32。没每次创建一个新的节点的时候，程序都会随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是“高度”</li></ul><h2 id="redis五种数据结构的实现"><a href="#redis五种数据结构的实现" class="headerlink" title="redis五种数据结构的实现"></a>redis五种数据结构的实现</h2><h3 id="redis对象"><a href="#redis对象" class="headerlink" title="redis对象"></a>redis对象</h3><p>redis中并没有直接使用以上所说的各种数据结构来实现键值数据库，而是基于一种对象，对象底层再间接的引用上文所说的具体的数据结构。</p><p>结构如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210127233751867.png"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="https://img-blog.csdnimg.cn/20210127233834474.png"></p><p>其中：embstr和raw都是由SDS动态字符串构成的。唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和在一块儿内存中。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img src="https://img-blog.csdnimg.cn/20210127233904573.png"></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><img src="https://img-blog.csdnimg.cn/20210127233931536.png"></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="https://img-blog.csdnimg.cn/20210127233954733.png"></p><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p><img src="https://img-blog.csdnimg.cn/20210127234030208.png"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="https://img-blog.csdnimg.cn/20210127234543130.png"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>双十一期间，所有用户一打开淘宝就是进入<code>首页</code>，首页的压力非常大，为了提高并发，将网站<code>首页数据</code>都缓存到<code>redis</code>里，所有的redis key<code>失效时间</code>都是<code>3小时</code>。</p><p>双十一当天大量用户<code>剁手狂欢</code>，这时候3个小时过去了，redis里首页的key<code>缓存全部失效</code>，这时候redis里查询不到数据了，只能去<code>数据库</code>中查询，造成数据库无法响应<code>挂掉</code>。</p><p>用户进不去首页没法剁手了，<code>马爸爸</code>就<code>不开心</code>了，把这个程序员外派到<code>非洲</code>了。</p><h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p>在<code>高并发</code>下，大量缓存key在<code>同一时间失效</code>，大量请求直接落在数据库上，导致数据库宕机。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>随机设置key失效时间，避免大量key集体失效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（Key，value，time + Math.random() * <span class="number">10000</span>）；</span><br></pre></td></tr></table></figure><ul><li><p>若是集群部署，可将热点数据均匀分布在不同的Redis库中也能够避免key全部失效问题</p></li><li><p>不设置过期时间</p></li><li><p>跑定时任务，在缓存失效前刷进新的缓存</p></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://img-blog.csdnimg.cn/"></p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>老哥做了一个网站<code>火了</code>，动了别人的蛋糕，于是开始<code>疯狂攻击</code>老哥的网站，由于老哥<code>网络安全</code>方面学艺不精被人钻了空子。</p><p>某人用脚本疯狂的给老哥发送请求，查询 <code>id = -1</code> 的数据，redis并没有这样的数据，这时候就<code>穿透redis</code>，直接打到了<code>数据库</code>上。</p><p>半夜老哥在睡觉并没有察觉，他疯狂攻击老哥一晚上，结果把<code>数据库</code>搞挂了，然后老哥的<code>网站</code>也挂了。</p><h3 id="一句话总结-1"><a href="#一句话总结-1" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><code>redis缓存</code>和<code>数据库</code>中没有相关数据(例用户直接携带<code>id&lt;=0</code>的参数不断发起请求)，redis中没有这样的数据，<code>无法进行拦截</code>，直接被穿透到<code>数据库</code>，导致数据库压力过大宕机。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>对不存在的数据缓存到redis中，设置key，value值为null(不管是数据未null还是系统bug问题)，并设置一个短期过期时间段，避免过期时间过长影响正常用户使用。</p></li><li><p>拉黑该IP地址</p></li><li><p>对参数进行校验，不合法参数进行拦截</p></li><li><p>布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap(位图)中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://img-blog.csdnimg.cn/20210127234652977.png"></p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>双十一<code>马爸爸</code>突发奇想，想<code>拍卖</code>自己<code>穿了20年的老布鞋</code>，并且附带本人签名，程序员将该鞋的信息存到了redis中，设置了<code>3小时</code>过期。寻思3小时够他们抢了吧，但他低估了马爸爸的魅力。</p><p>该商品引起了一千万人关注，这些人不断的竞拍这双鞋，价格越拍越高，马爸爸乐开了花。</p><p>竞拍了<code>2小时59</code>分，马上要拍到一个亿了，突然这双鞋在redis里的key数据<code>过期了</code>，导致该key的大量请求，都打到了数据库，直接导致数据库挂掉了，服务无法响应。</p><p>竞拍到此结束，鞋没卖出去，马爸爸又不开心了，把这个程序员也<code>外派到非洲</code>了。</p><h3 id="一句话总结-2"><a href="#一句话总结-2" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><code>某一个</code>热点key，在不停地扛着高并发，当这个热点key在<code>失效的一瞬间</code>，持续的高并发访问就<code>击破缓存</code>直接访问数据库，导致数据库宕机。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>设置热点数据”永不过期”</p></li><li><p>加上互斥锁：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后将数据放到redis缓存起来。后面的线程进来发现已经有缓存了，就直接走缓存</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 简单的分布式锁实现，之后我们重点会讲分布式锁</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">  String value = redis.get(key);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">    <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">    String keynx = key.concat(<span class="string">&quot;:nx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(keynx, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123; <span class="comment">//代表设置成功</span></span><br><span class="line">      value = db.get(key);</span><br><span class="line">      redis.set(key, value, expire_secs);</span><br><span class="line">      redis.del(keynx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">      sleep(<span class="number">50</span>);</span><br><span class="line">      get(key); <span class="comment">//重试</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>雪崩是<code>大面积</code>的key缓存失效；穿透是redis里<code>不存在</code>这个缓存key；击穿是redis<code>某一个热点</code>key突然失效，最终的受害者都是数据库。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>未雨绸缪</code>：将redis、MySQL等搭建成高可用的集群，防止单点。</p><p><code>亡羊补牢</code>：服务中进行限流 + 降级，防止MySQL被打崩溃。</p><p><code>重振旗鼓</code>：Redis 持久化 RDB+AOF，宕机重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器（Bloom Filter），是1970年，由一个叫布隆的小伙子提出的，距今已经五十年了，和老哥一样老。</p><p>它实际上是一个很长的二进制向量和一系列随机映射函数，二进制大家应该都清楚，存储的数据不是0就是1，默认是0。</p><p>主要用于判断一个元素是否在一个集合中，0代表不存在某个数据，1代表存在某个数据。<br>                                                       <img src="https://img-blog.csdnimg.cn/20210127235443711.png"></p><h2 id="布隆过滤器用途"><a href="#布隆过滤器用途" class="headerlink" title="布隆过滤器用途"></a>布隆过滤器用途</h2><ul><li><p>解决Redis缓存穿透（今天重点讲解）</p></li><li><p>在爬虫时，对爬虫网址进行过滤，已经存在布隆中的网址，不在爬取。</p></li><li><p>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件。</p></li></ul><p>以上只是简单的用途举例，大家可以举一反三，灵活运用在工作中。</p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><h3 id="存入数据过程"><a href="#存入数据过程" class="headerlink" title="存入数据过程"></a>存入数据过程</h3><p>布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼（这里有缺点，下面会讲）：</p><ul><li><p>通过K个哈希函数计算该数据，返回K个计算出的hash值</p></li><li><p>这些K个hash值映射到对应的K个二进制的数组下标</p></li><li><p>将K个下标对应的二进制数据改成1。       </p></li></ul><p>例如，第一个哈希函数返回x，第二个第三个哈希函数返回y与z，那么：X、Y、Z对应的二进制改成1。</p><p><img src="https://img-blog.csdnimg.cn/20210127235644503.png"></p><h3 id="查询数据过程"><a href="#查询数据过程" class="headerlink" title="查询数据过程"></a>查询数据过程</h3><p>布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：</p><ul><li><p>通过K个哈希函数计算该数据，对应计算出的K个hash值</p></li><li><p>通过hash值找到对应的二进制的数组下标</p></li><li><p>判断：如果存在一处位置的二进制数据是0，那么该数据不存在。如果都是1，该数据存在集合中。（这里有缺点，下面会讲）</p></li></ul><h3 id="删除数据过程"><a href="#删除数据过程" class="headerlink" title="删除数据过程"></a>删除数据过程</h3><p>一般不能删除布隆过滤器里的数据，这是一个缺点之一，我们下面会分析。</p><h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>由于存储的是二进制数据，所以占用的空间很小</p></li><li><p>它的插入和查询速度是非常快的，时间复杂度是O（K），可以联想一下HashMap的过程</p></li><li><p>保密性很好，因为本身不存储任何原始数据，只有二进制数据</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这就要回到我们上面所说的那些缺点了。</p></li></ul><p>添加数据是通过计算数据的hash值，那么很有可能存在这种情况：两个不同的数据计算得到相同的hash值。</p><p><img src="https://img-blog.csdnimg.cn/20210128000047782.png"></p><p>例如图中的“你好”和“hello”，假如最终算出hash值相同，那么他们会将同一个下标的二进制数据改为1。</p><p>这个时候，你就不知道下标为2的二进制，到底是代表“你好”还是“hello”。</p><p><strong>由此得出如下缺点：</strong></p><p><strong>一、存在误判</strong></p><p>假如上面的图没有存”hello”，只存了”你好”，那么用”hello”来查询的时候，会判断”hello”存在集合中。</p><p><strong>二、删除困难</strong></p><p>还是用上面的举例，因为“你好”和“hello”的hash值相同，对应的数组下标也是一样的。</p><p>这时候老哥想去删除“你好”，将下标为2里的二进制数据，由1改成了0。</p><p>那么我们是不是连“hello”都一起删了呀。（0代表有这个数据，1代表没有这个数据）</p><h2 id="实现布隆过滤器方式"><a href="#实现布隆过滤器方式" class="headerlink" title="实现布隆过滤器方式"></a>实现布隆过滤器方式</h2><p>有很多种实现方式，其中一种就是Guava提供的实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 期望的误判率</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 布隆过滤器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入10万样本数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用另外十万测试数据，测试误判率</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; size + <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;误判了&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;总共的误判数:&quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20210128000333819.png"></p><p>10万数据里有947个误判，约等于0.01%，也就是我们代码里设置的误判率：fpp = 0.01。</p><h2 id="布隆过滤器深入分析代码"><a href="#布隆过滤器深入分析代码" class="headerlink" title="布隆过滤器深入分析代码"></a>布隆过滤器深入分析代码</h2><p>核心BloomFilter.create方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四个参数：</p><ul><li><p>funnel：数据类型(一般是调用Funnels工具类中的)</p></li><li><p>expectedInsertions：期望插入的值的个数</p></li><li><p>fpp：误判率(默认值为0.03)</p></li><li><p>strategy：哈希算法</p></li></ul><p>我们重点讲一下fpp参数</p><h3 id="fpp误判率"><a href="#fpp误判率" class="headerlink" title="fpp误判率"></a>fpp误判率</h3><p><strong>情景一：fpp = 0.01</strong></p><p>误判个数：947</p><p><img src="https://img-blog.csdnimg.cn/20210128000512120.png"></p><p>占内存大小：9585058位数</p><p><img src="https://img-blog.csdnimg.cn/20210128000528946.png0"></p><p><strong>情景二：fpp = 0.03（默认参数）</strong></p><p>误判个数：3033</p><p><img src="https://img-blog.csdnimg.cn/20210128000614741.png"></p><p>占内存大小：7298440位数</p><p><img src="https://img-blog.csdnimg.cn/20210128000634945.png"></p><h3 id="情景总结"><a href="#情景总结" class="headerlink" title="情景总结"></a>情景总结</h3><ul><li><p>误判率可以通过fpp参数进行调节</p></li><li><p>fpp越小，需要的内存空间就越大：0.01需要900多万位数，0.03需要700多万位数。</p></li><li><p>fpp越小，集合添加数据时，就需要更多的hash函数运算更多的hash值，去存储到对应的数组下标里。（忘了去看上面的布隆过滤存入数据的过程）</p></li></ul><p>上面的numBits，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要481000000=3200万位。</p><p>如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的numHashFunctions表示需要几个hash函数运算，去映射不同的下标存这些数字是否存在（0 or 1）。</p><h2 id="布隆过滤器解决缓存穿透"><a href="#布隆过滤器解决缓存穿透" class="headerlink" title="布隆过滤器解决缓存穿透"></a>布隆过滤器解决缓存穿透</h2><p>其实布隆过滤器本质来讲，就是起到一个黑名单或者白名单的作用。我们从这两个角度去分析缓存穿透问题。</p><h3 id="白名单解决缓存穿透"><a href="#白名单解决缓存穿透" class="headerlink" title="白名单解决缓存穿透"></a>白名单解决缓存穿透</h3><p><img src="https://img-blog.csdnimg.cn/20210128001031675.png"></p><p><strong>注意问题</strong></p><ul><li><p>如果没在白名单里的数据被误判存在于过滤器里的话，会穿透到数据库，不过误判的几率本来就很小，所以穿透问题不大。</p></li><li><p>必须将所有的查询key都放到布隆过滤器和Redis里，否则请求会被直接返回空数据。</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.bilibili.itlaoge.model.User;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBucket;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决缓存穿透—白名单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造Redisson</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> RedissonClient redisson = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> RBloomFilter&lt;String&gt; bloomFilter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      Config config = <span class="keyword">new</span> Config();</span><br><span class="line">      config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//构造Redisson</span></span><br><span class="line">      redisson = Redisson.create(config);</span><br><span class="line">      <span class="comment">//构造布隆过滤器</span></span><br><span class="line">      bloomFilter = redisson.getBloomFilter(<span class="string">&quot;userIdFilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将查询数据放入Redis缓存和布隆过滤器里</span></span><br><span class="line">      initData(redisson, bloomFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">(RedissonClient redisson, RBloomFilter&lt;String&gt; bloomFilter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">      bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将id为1的数据，插入到布隆过滤器中</span></span><br><span class="line">      bloomFilter.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      bloomFilter.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将id为1对应的user数据，插入到Redis缓存中</span></span><br><span class="line">      redisson.getBucket(<span class="string">&quot;1&quot;</span>).set(<span class="string">&quot;&#123;id:1, userName:&#x27;张三&#x27;, age:18&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      User user = getUserById(<span class="number">2L</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;user对象为：&quot;</span> + JSON.toJSONString(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == id) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String idKey = id.toString();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始模拟缓存穿透</span></span><br><span class="line">      <span class="comment">// 前端查询请求key</span></span><br><span class="line">      <span class="keyword">if</span> (bloomFilter.contains(idKey)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 通过了过滤器白名单校验，去Redis里查询真正的数据</span></span><br><span class="line">          RBucket&lt;Object&gt; bucket = redisson.getBucket(idKey);</span><br><span class="line">          Object object = bucket.get();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果Redis有数据，直接返回该数据</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> != object) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;从Redis里面查询出来的&quot;</span>);</span><br><span class="line">              String userStr = object.toString();</span><br><span class="line">              <span class="keyword">return</span> JSON.parseObject(userStr, User.class);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果Redis为空，去查询数据库</span></span><br><span class="line">          User user = selectByDb(idKey);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == user) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 将数据重新刷进缓存</span></span><br><span class="line">              redisson.getBucket(id.toString()).set(JSON.toJSONString(user));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> user;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">selectByDb</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;从MySQL里面查询出来的&quot;</span>);</span><br><span class="line">      User user = <span class="keyword">new</span> User();</span><br><span class="line">      user.setId(<span class="number">1L</span>);</span><br><span class="line">      user.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      user.setAge(<span class="number">18</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String maYunPhone = <span class="string">&quot;18890019390&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="黑名单解决缓存穿透"><a href="#黑名单解决缓存穿透" class="headerlink" title="黑名单解决缓存穿透"></a>黑名单解决缓存穿透</h3><p><img src="https://img-blog.csdnimg.cn/20210128001215801.png"></p><p><strong>注意问题</strong></p><ul><li><p>布隆过滤器里的数据，存在误判，如果正常数据被误判存在黑名单里的话，会直接返回空数据。</p></li><li><p>黑名单里的数据要很全面才行，否则会有比较严重的穿透问题。</p></li><li><p>本来是在黑名单里的非法数据，之后有可能是正常数据。如：用id大于100万的数来请求，我们数据库里只有10万数据，这时候如果把id放进黑名单里。等数据达到100万的时候，就会出现问题。</p></li></ul><h2 id="布隆过滤器其他应用场景举例"><a href="#布隆过滤器其他应用场景举例" class="headerlink" title="布隆过滤器其他应用场景举例"></a>布隆过滤器其他应用场景举例</h2><h3 id="视频推送场景（黑名单）"><a href="#视频推送场景（黑名单）" class="headerlink" title="视频推送场景（黑名单）"></a>视频推送场景（黑名单）</h3><p><img src="https://img-blog.csdnimg.cn/20210128001336702.png"></p><p>背景：某视频网站给用户推送视频</p><p>布隆过滤器作用：当黑名单使用。</p><p>要求：对于某用户，已经推送过的视频，不在进行推送。</p><p>流程：当推送给用户一批视频时，先判断这些视频是否存在过滤器里；如果存在就不推送给用户，不存在就推送给用户；同时将推送过的视频存入过滤器黑名单里，防止下次重复推送。</p><h3 id="转载视频-文章案例（白名单）"><a href="#转载视频-文章案例（白名单）" class="headerlink" title="转载视频/文章案例（白名单）"></a>转载视频/文章案例（白名单）</h3><p><img src="https://img-blog.csdnimg.cn/20210128001405878.png"></p><p>背景：某用户想转载老哥的文章。</p><p>布隆过滤器作用：当白名单使用。</p><p>要求：在老哥转发白名单里的，有转发文章的权限。</p><p>流程：某用户想转发老哥的文章，由于没在白名单里，转发失败。于是找到老哥开白名单，老哥把他加入了白名单里后，允许转发了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 基础 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="2021/03/11/page/"/>
      <url>2021/03/11/page/</url>
      
        <content type="html"><![CDATA[<h1 id="java-基础语法"><a href="#java-基础语法" class="headerlink" title="java  基础语法"></a>java  基础语法</h1><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li>对象：    对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li><li>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li><li>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li></ul><h1 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h1><p>下面看一个简单的 Java 程序，它将输出字符串 Hello World</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg"></p><p>下面将逐步介绍如何保存、编译以及运行这个程序：</p><ul><li><p>打开代码编辑器，把上面的代码添加进去；</p></li><li><p>把文件名保存为：HelloWorld.java；</p></li><li><p>打开 cmd 命令窗口，进入目标文件所在的位置，假设是 C:\</p></li><li><p>在命令行窗口输入 javac HelloWorld.java 按下回车键编译代码。如果代码没有错误，cmd 命令提示符会进入下一行（假设环境变量都设置好了）。</p></li><li><p>再键输入 java HelloWorld 按下回车键就可以运行程序了</p></li></ul><p>你将会在窗口看到 Hello World</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld </span><br><span class="line">Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果遇到编码问题，我们可以使用 -encoding 选项设置 utf-8 来编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding UTF-8 HelloWorld.java </span><br><span class="line">java HelloWorld </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Gif 图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-HelloWorld.gif"></p><hr><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>编写 Java 程序时，应注意以下几点：</p><ul><li><p>大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p></li><li><p>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</p></li><li><p>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p></li><li><p>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</p></li><li><p>主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。</p></li></ul><hr><h1 id="java-标识符"><a href="#java-标识符" class="headerlink" title="java 标识符"></a>java 标识符</h1><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li><p>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</p></li><li><p>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</p></li><li><p>关键字不能用作标识符</p></li><li><p>标识符是大小写敏感的</p></li><li><p>合法标识符举例：age、$salary、_value、__1_value</p></li><li><p>非法标识符举例：123abc、-salary</p></li></ul><hr><h1 id="java-修饰符"><a href="#java-修饰符" class="headerlink" title="java 修饰符"></a>java 修饰符</h1><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ul><li><p>访问控制修饰符 : default, public , protected, private</p></li><li><p>非访问控制修饰符 : final, abstract, static, synchronized</p></li></ul><p>在后面的章节中我们会深入讨论 Java 修饰符。</p><hr><h1 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h1><p>Java 中主要有如下几种类型的变量</p><ul><li><p>局部变量</p></li><li><p>类变量（静态变量）</p></li><li><p>成员变量（非静态变量）</p></li></ul><hr><h1 id="java-数组"><a href="#java-数组" class="headerlink" title="java 数组"></a>java 数组</h1><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p><hr><h1 id="java-枚举"><a href="#java-枚举" class="headerlink" title="java 枚举"></a>java 枚举</h1><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class FreshJuice &#123;</span><br><span class="line">   enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125;</span><br><span class="line">   FreshJuiceSize size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class FreshJuiceTest &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      FreshJuice juice &#x3D; new FreshJuice();</span><br><span class="line">      juice.size &#x3D; FreshJuice.FreshJuiceSize.MEDIUM  ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p><hr><h1 id="java-关键字"><a href="#java-关键字" class="headerlink" title="java 关键字"></a>java 关键字</h1><p>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p><p><img src="/javaimg/javajichu.png"></p><hr><h1 id="java-注释"><a href="#java-注释" class="headerlink" title="java 注释"></a>java 注释</h1><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">   &#x2F;* 这是第一个Java程序</span><br><span class="line">    * 它将输出 Hello World</span><br><span class="line">    * 这是一个多行注释的示例</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       &#x2F;&#x2F; 这是单行注释的示例</span><br><span class="line">       &#x2F;* 这个也是单行注释的示例 *&#x2F;</span><br><span class="line">       System.out.println(&quot;Hello World&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><hr><h1 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h1><p>如下图所示:<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 基础 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
